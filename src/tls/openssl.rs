/* automatically generated by rust-bindgen */

pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const OPENSSL_VERSION_NUMBER: u32 = 268443919;
pub const OPENSSL_VERSION_TEXT: &'static [u8; 28usize] = b"OpenSSL 1.0.2p  14 Aug 2018\0";
pub const OPENSSL_VERSION_PTEXT: &'static [u8; 37usize] = b" part of OpenSSL 1.0.2p  14 Aug 2018\0";
pub const SHLIB_VERSION_HISTORY: &'static [u8; 1usize] = b"\0";
pub const SHLIB_VERSION_NUMBER: &'static [u8; 6usize] = b"1.0.0\0";
pub const SSLEAY_VERSION_NUMBER: u32 = 268443919;
pub const SSLEAY_VERSION: u32 = 0;
pub const SSLEAY_CFLAGS: u32 = 2;
pub const SSLEAY_BUILT_ON: u32 = 3;
pub const SSLEAY_PLATFORM: u32 = 4;
pub const SSLEAY_DIR: u32 = 5;
pub const CRYPTO_LOCK_ERR: u32 = 1;
pub const CRYPTO_LOCK_EX_DATA: u32 = 2;
pub const CRYPTO_LOCK_X509: u32 = 3;
pub const CRYPTO_LOCK_X509_INFO: u32 = 4;
pub const CRYPTO_LOCK_X509_PKEY: u32 = 5;
pub const CRYPTO_LOCK_X509_CRL: u32 = 6;
pub const CRYPTO_LOCK_X509_REQ: u32 = 7;
pub const CRYPTO_LOCK_DSA: u32 = 8;
pub const CRYPTO_LOCK_RSA: u32 = 9;
pub const CRYPTO_LOCK_EVP_PKEY: u32 = 10;
pub const CRYPTO_LOCK_X509_STORE: u32 = 11;
pub const CRYPTO_LOCK_SSL_CTX: u32 = 12;
pub const CRYPTO_LOCK_SSL_CERT: u32 = 13;
pub const CRYPTO_LOCK_SSL_SESSION: u32 = 14;
pub const CRYPTO_LOCK_SSL_SESS_CERT: u32 = 15;
pub const CRYPTO_LOCK_SSL: u32 = 16;
pub const CRYPTO_LOCK_SSL_METHOD: u32 = 17;
pub const CRYPTO_LOCK_RAND: u32 = 18;
pub const CRYPTO_LOCK_RAND2: u32 = 19;
pub const CRYPTO_LOCK_MALLOC: u32 = 20;
pub const CRYPTO_LOCK_BIO: u32 = 21;
pub const CRYPTO_LOCK_GETHOSTBYNAME: u32 = 22;
pub const CRYPTO_LOCK_GETSERVBYNAME: u32 = 23;
pub const CRYPTO_LOCK_READDIR: u32 = 24;
pub const CRYPTO_LOCK_RSA_BLINDING: u32 = 25;
pub const CRYPTO_LOCK_DH: u32 = 26;
pub const CRYPTO_LOCK_MALLOC2: u32 = 27;
pub const CRYPTO_LOCK_DSO: u32 = 28;
pub const CRYPTO_LOCK_DYNLOCK: u32 = 29;
pub const CRYPTO_LOCK_ENGINE: u32 = 30;
pub const CRYPTO_LOCK_UI: u32 = 31;
pub const CRYPTO_LOCK_ECDSA: u32 = 32;
pub const CRYPTO_LOCK_EC: u32 = 33;
pub const CRYPTO_LOCK_ECDH: u32 = 34;
pub const CRYPTO_LOCK_BN: u32 = 35;
pub const CRYPTO_LOCK_EC_PRE_COMP: u32 = 36;
pub const CRYPTO_LOCK_STORE: u32 = 37;
pub const CRYPTO_LOCK_COMP: u32 = 38;
pub const CRYPTO_LOCK_FIPS: u32 = 39;
pub const CRYPTO_LOCK_FIPS2: u32 = 40;
pub const CRYPTO_NUM_LOCKS: u32 = 41;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const CRYPTO_MEM_CHECK_OFF: u32 = 0;
pub const CRYPTO_MEM_CHECK_ON: u32 = 1;
pub const CRYPTO_MEM_CHECK_ENABLE: u32 = 2;
pub const CRYPTO_MEM_CHECK_DISABLE: u32 = 3;
pub const V_CRYPTO_MDEBUG_TIME: u32 = 1;
pub const V_CRYPTO_MDEBUG_THREAD: u32 = 2;
pub const V_CRYPTO_MDEBUG_ALL: u32 = 3;
pub const CRYPTO_EX_INDEX_BIO: u32 = 0;
pub const CRYPTO_EX_INDEX_SSL: u32 = 1;
pub const CRYPTO_EX_INDEX_SSL_CTX: u32 = 2;
pub const CRYPTO_EX_INDEX_SSL_SESSION: u32 = 3;
pub const CRYPTO_EX_INDEX_X509_STORE: u32 = 4;
pub const CRYPTO_EX_INDEX_X509_STORE_CTX: u32 = 5;
pub const CRYPTO_EX_INDEX_RSA: u32 = 6;
pub const CRYPTO_EX_INDEX_DSA: u32 = 7;
pub const CRYPTO_EX_INDEX_DH: u32 = 8;
pub const CRYPTO_EX_INDEX_ENGINE: u32 = 9;
pub const CRYPTO_EX_INDEX_X509: u32 = 10;
pub const CRYPTO_EX_INDEX_UI: u32 = 11;
pub const CRYPTO_EX_INDEX_ECDSA: u32 = 12;
pub const CRYPTO_EX_INDEX_ECDH: u32 = 13;
pub const CRYPTO_EX_INDEX_COMP: u32 = 14;
pub const CRYPTO_EX_INDEX_STORE: u32 = 15;
pub const CRYPTO_EX_INDEX_USER: u32 = 100;
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX: u32 = 100;
pub const CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID: u32 = 103;
pub const CRYPTO_F_CRYPTO_GET_NEW_LOCKID: u32 = 101;
pub const CRYPTO_F_CRYPTO_SET_EX_DATA: u32 = 102;
pub const CRYPTO_F_DEF_ADD_INDEX: u32 = 104;
pub const CRYPTO_F_DEF_GET_CLASS: u32 = 105;
pub const CRYPTO_F_FIPS_MODE_SET: u32 = 109;
pub const CRYPTO_F_INT_DUP_EX_DATA: u32 = 106;
pub const CRYPTO_F_INT_FREE_EX_DATA: u32 = 107;
pub const CRYPTO_F_INT_NEW_EX_DATA: u32 = 108;
pub const CRYPTO_R_FIPS_MODE_NOT_SUPPORTED: u32 = 101;
pub const CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK: u32 = 100;
pub const COMP_F_BIO_ZLIB_FLUSH: u32 = 99;
pub const COMP_F_BIO_ZLIB_NEW: u32 = 100;
pub const COMP_F_BIO_ZLIB_READ: u32 = 101;
pub const COMP_F_BIO_ZLIB_WRITE: u32 = 102;
pub const COMP_R_ZLIB_DEFLATE_ERROR: u32 = 99;
pub const COMP_R_ZLIB_INFLATE_ERROR: u32 = 100;
pub const COMP_R_ZLIB_NOT_SUPPORTED: u32 = 101;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_PROXY_CLIENT: u32 = 526;
pub const BIO_TYPE_PROXY_SERVER: u32 = 527;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BER: u32 = 530;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_CTRL_DGRAM_CONNECT: u32 = 31;
pub const BIO_CTRL_DGRAM_SET_CONNECTED: u32 = 32;
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT: u32 = 33;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT: u32 = 34;
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT: u32 = 35;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT: u32 = 36;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP: u32 = 37;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP: u32 = 38;
pub const BIO_CTRL_DGRAM_MTU_DISCOVER: u32 = 39;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_DGRAM_GET_MTU: u32 = 41;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_SET_PEER: u32 = 44;
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: u32 = 45;
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG: u32 = 48;
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD: u32 = 49;
pub const BIO_FP_READ: u32 = 2;
pub const BIO_FP_WRITE: u32 = 4;
pub const BIO_FP_APPEND: u32 = 8;
pub const BIO_FP_TEXT: u32 = 16;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_UPLINK: u32 = 0;
pub const BIO_GHBN_CTRL_HITS: u32 = 1;
pub const BIO_GHBN_CTRL_MISSES: u32 = 2;
pub const BIO_GHBN_CTRL_CACHE_SIZE: u32 = 3;
pub const BIO_GHBN_CTRL_GET_ENTRY: u32 = 4;
pub const BIO_GHBN_CTRL_FLUSH: u32 = 5;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_RR_SSL_X509_LOOKUP: u32 = 1;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_CONN_S_BEFORE: u32 = 1;
pub const BIO_CONN_S_GET_IP: u32 = 2;
pub const BIO_CONN_S_GET_PORT: u32 = 3;
pub const BIO_CONN_S_CREATE_SOCKET: u32 = 4;
pub const BIO_CONN_S_CONNECT: u32 = 5;
pub const BIO_CONN_S_OK: u32 = 6;
pub const BIO_CONN_S_BLOCKED_CONNECT: u32 = 7;
pub const BIO_CONN_S_NBIO: u32 = 8;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_PROXY_PARAM: u32 = 103;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_GET_SSL: u32 = 110;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_GET_PROXY_PARAM: u32 = 121;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_CONNECT: u32 = 123;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES: u32 = 125;
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES: u32 = 126;
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT: u32 = 127;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_MAKE_BIO_PAIR: u32 = 138;
pub const BIO_C_DESTROY_BIO_PAIR: u32 = 139;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_BIND_NORMAL: u32 = 0;
pub const BIO_BIND_REUSEADDR_IF_UNUSED: u32 = 1;
pub const BIO_BIND_REUSEADDR: u32 = 2;
pub const BIO_F_ACPT_STATE: u32 = 100;
pub const BIO_F_BIO_ACCEPT: u32 = 101;
pub const BIO_F_BIO_BER_GET_HEADER: u32 = 102;
pub const BIO_F_BIO_CALLBACK_CTRL: u32 = 131;
pub const BIO_F_BIO_CTRL: u32 = 103;
pub const BIO_F_BIO_GETHOSTBYNAME: u32 = 120;
pub const BIO_F_BIO_GETS: u32 = 104;
pub const BIO_F_BIO_GET_ACCEPT_SOCKET: u32 = 105;
pub const BIO_F_BIO_GET_HOST_IP: u32 = 106;
pub const BIO_F_BIO_GET_PORT: u32 = 107;
pub const BIO_F_BIO_MAKE_PAIR: u32 = 121;
pub const BIO_F_BIO_NEW: u32 = 108;
pub const BIO_F_BIO_NEW_FILE: u32 = 109;
pub const BIO_F_BIO_NEW_MEM_BUF: u32 = 126;
pub const BIO_F_BIO_NREAD: u32 = 123;
pub const BIO_F_BIO_NREAD0: u32 = 124;
pub const BIO_F_BIO_NWRITE: u32 = 125;
pub const BIO_F_BIO_NWRITE0: u32 = 122;
pub const BIO_F_BIO_PUTS: u32 = 110;
pub const BIO_F_BIO_READ: u32 = 111;
pub const BIO_F_BIO_SOCK_INIT: u32 = 112;
pub const BIO_F_BIO_WRITE: u32 = 113;
pub const BIO_F_BUFFER_CTRL: u32 = 114;
pub const BIO_F_CONN_CTRL: u32 = 127;
pub const BIO_F_CONN_STATE: u32 = 115;
pub const BIO_F_DGRAM_SCTP_READ: u32 = 132;
pub const BIO_F_DGRAM_SCTP_WRITE: u32 = 133;
pub const BIO_F_FILE_CTRL: u32 = 116;
pub const BIO_F_FILE_READ: u32 = 130;
pub const BIO_F_LINEBUFFER_CTRL: u32 = 129;
pub const BIO_F_MEM_READ: u32 = 128;
pub const BIO_F_MEM_WRITE: u32 = 117;
pub const BIO_F_SSL_NEW: u32 = 118;
pub const BIO_F_WSASTARTUP: u32 = 119;
pub const BIO_R_ACCEPT_ERROR: u32 = 100;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 101;
pub const BIO_R_BAD_HOSTNAME_LOOKUP: u32 = 102;
pub const BIO_R_BROKEN_PIPE: u32 = 124;
pub const BIO_R_CONNECT_ERROR: u32 = 103;
pub const BIO_R_EOF_ON_MEMORY_BIO: u32 = 127;
pub const BIO_R_ERROR_SETTING_NBIO: u32 = 104;
pub const BIO_R_ERROR_SETTING_NBIO_ON_ACCEPTED_SOCKET: u32 = 105;
pub const BIO_R_ERROR_SETTING_NBIO_ON_ACCEPT_SOCKET: u32 = 106;
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET: u32 = 107;
pub const BIO_R_INVALID_ARGUMENT: u32 = 125;
pub const BIO_R_INVALID_IP_ADDRESS: u32 = 108;
pub const BIO_R_IN_USE: u32 = 123;
pub const BIO_R_KEEPALIVE: u32 = 109;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 110;
pub const BIO_R_NO_ACCEPT_PORT_SPECIFIED: u32 = 111;
pub const BIO_R_NO_HOSTNAME_SPECIFIED: u32 = 112;
pub const BIO_R_NO_PORT_DEFINED: u32 = 113;
pub const BIO_R_NO_PORT_SPECIFIED: u32 = 114;
pub const BIO_R_NO_SUCH_FILE: u32 = 128;
pub const BIO_R_NULL_PARAMETER: u32 = 115;
pub const BIO_R_TAG_MISMATCH: u32 = 116;
pub const BIO_R_UNABLE_TO_BIND_SOCKET: u32 = 117;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 118;
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET: u32 = 119;
pub const BIO_R_UNINITIALIZED: u32 = 120;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 121;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 126;
pub const BIO_R_WSASTARTUP: u32 = 122;
pub const BUF_F_BUF_MEMDUP: u32 = 103;
pub const BUF_F_BUF_MEM_GROW: u32 = 100;
pub const BUF_F_BUF_MEM_GROW_CLEAN: u32 = 105;
pub const BUF_F_BUF_MEM_NEW: u32 = 101;
pub const BUF_F_BUF_STRDUP: u32 = 102;
pub const BUF_F_BUF_STRNDUP: u32 = 104;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const PKCS5_SALT_LEN: u32 = 8;
pub const PKCS5_DEFAULT_ITER: u32 = 2048;
pub const SN_undef: &'static [u8; 6usize] = b"UNDEF\0";
pub const LN_undef: &'static [u8; 10usize] = b"undefined\0";
pub const NID_undef: u32 = 0;
pub const OBJ_undef: u32 = 0;
pub const SN_itu_t: &'static [u8; 6usize] = b"ITU-T\0";
pub const LN_itu_t: &'static [u8; 6usize] = b"itu-t\0";
pub const NID_itu_t: u32 = 645;
pub const OBJ_itu_t: u32 = 0;
pub const NID_ccitt: u32 = 404;
pub const OBJ_ccitt: u32 = 0;
pub const SN_iso: &'static [u8; 4usize] = b"ISO\0";
pub const LN_iso: &'static [u8; 4usize] = b"iso\0";
pub const NID_iso: u32 = 181;
pub const OBJ_iso: u32 = 1;
pub const SN_joint_iso_itu_t: &'static [u8; 16usize] = b"JOINT-ISO-ITU-T\0";
pub const LN_joint_iso_itu_t: &'static [u8; 16usize] = b"joint-iso-itu-t\0";
pub const NID_joint_iso_itu_t: u32 = 646;
pub const OBJ_joint_iso_itu_t: u32 = 2;
pub const NID_joint_iso_ccitt: u32 = 393;
pub const OBJ_joint_iso_ccitt: u32 = 2;
pub const SN_member_body: &'static [u8; 12usize] = b"member-body\0";
pub const LN_member_body: &'static [u8; 16usize] = b"ISO Member Body\0";
pub const NID_member_body: u32 = 182;
pub const SN_identified_organization: &'static [u8; 24usize] = b"identified-organization\0";
pub const NID_identified_organization: u32 = 676;
pub const SN_hmac_md5: &'static [u8; 9usize] = b"HMAC-MD5\0";
pub const LN_hmac_md5: &'static [u8; 9usize] = b"hmac-md5\0";
pub const NID_hmac_md5: u32 = 780;
pub const SN_hmac_sha1: &'static [u8; 10usize] = b"HMAC-SHA1\0";
pub const LN_hmac_sha1: &'static [u8; 10usize] = b"hmac-sha1\0";
pub const NID_hmac_sha1: u32 = 781;
pub const SN_certicom_arc: &'static [u8; 13usize] = b"certicom-arc\0";
pub const NID_certicom_arc: u32 = 677;
pub const SN_international_organizations: &'static [u8; 28usize] = b"international-organizations\0";
pub const LN_international_organizations: &'static [u8; 28usize] = b"International Organizations\0";
pub const NID_international_organizations: u32 = 647;
pub const SN_wap: &'static [u8; 4usize] = b"wap\0";
pub const NID_wap: u32 = 678;
pub const SN_wap_wsg: &'static [u8; 8usize] = b"wap-wsg\0";
pub const NID_wap_wsg: u32 = 679;
pub const SN_selected_attribute_types: &'static [u8; 25usize] = b"selected-attribute-types\0";
pub const LN_selected_attribute_types: &'static [u8; 25usize] = b"Selected Attribute Types\0";
pub const NID_selected_attribute_types: u32 = 394;
pub const SN_clearance: &'static [u8; 10usize] = b"clearance\0";
pub const NID_clearance: u32 = 395;
pub const SN_ISO_US: &'static [u8; 7usize] = b"ISO-US\0";
pub const LN_ISO_US: &'static [u8; 19usize] = b"ISO US Member Body\0";
pub const NID_ISO_US: u32 = 183;
pub const SN_X9_57: &'static [u8; 6usize] = b"X9-57\0";
pub const LN_X9_57: &'static [u8; 6usize] = b"X9.57\0";
pub const NID_X9_57: u32 = 184;
pub const SN_X9cm: &'static [u8; 5usize] = b"X9cm\0";
pub const LN_X9cm: &'static [u8; 11usize] = b"X9.57 CM ?\0";
pub const NID_X9cm: u32 = 185;
pub const SN_dsa: &'static [u8; 4usize] = b"DSA\0";
pub const LN_dsa: &'static [u8; 14usize] = b"dsaEncryption\0";
pub const NID_dsa: u32 = 116;
pub const SN_dsaWithSHA1: &'static [u8; 9usize] = b"DSA-SHA1\0";
pub const LN_dsaWithSHA1: &'static [u8; 12usize] = b"dsaWithSHA1\0";
pub const NID_dsaWithSHA1: u32 = 113;
pub const SN_ansi_X9_62: &'static [u8; 11usize] = b"ansi-X9-62\0";
pub const LN_ansi_X9_62: &'static [u8; 11usize] = b"ANSI X9.62\0";
pub const NID_ansi_X9_62: u32 = 405;
pub const SN_X9_62_prime_field: &'static [u8; 12usize] = b"prime-field\0";
pub const NID_X9_62_prime_field: u32 = 406;
pub const SN_X9_62_characteristic_two_field: &'static [u8; 25usize] = b"characteristic-two-field\0";
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const SN_X9_62_id_characteristic_two_basis: &'static [u8; 28usize] =
    b"id-characteristic-two-basis\0";
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const SN_X9_62_onBasis: &'static [u8; 8usize] = b"onBasis\0";
pub const NID_X9_62_onBasis: u32 = 681;
pub const SN_X9_62_tpBasis: &'static [u8; 8usize] = b"tpBasis\0";
pub const NID_X9_62_tpBasis: u32 = 682;
pub const SN_X9_62_ppBasis: &'static [u8; 8usize] = b"ppBasis\0";
pub const NID_X9_62_ppBasis: u32 = 683;
pub const SN_X9_62_id_ecPublicKey: &'static [u8; 15usize] = b"id-ecPublicKey\0";
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const SN_X9_62_c2pnb163v1: &'static [u8; 11usize] = b"c2pnb163v1\0";
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const SN_X9_62_c2pnb163v2: &'static [u8; 11usize] = b"c2pnb163v2\0";
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const SN_X9_62_c2pnb163v3: &'static [u8; 11usize] = b"c2pnb163v3\0";
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const SN_X9_62_c2pnb176v1: &'static [u8; 11usize] = b"c2pnb176v1\0";
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const SN_X9_62_c2tnb191v1: &'static [u8; 11usize] = b"c2tnb191v1\0";
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const SN_X9_62_c2tnb191v2: &'static [u8; 11usize] = b"c2tnb191v2\0";
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const SN_X9_62_c2tnb191v3: &'static [u8; 11usize] = b"c2tnb191v3\0";
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const SN_X9_62_c2onb191v4: &'static [u8; 11usize] = b"c2onb191v4\0";
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const SN_X9_62_c2onb191v5: &'static [u8; 11usize] = b"c2onb191v5\0";
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const SN_X9_62_c2pnb208w1: &'static [u8; 11usize] = b"c2pnb208w1\0";
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const SN_X9_62_c2tnb239v1: &'static [u8; 11usize] = b"c2tnb239v1\0";
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const SN_X9_62_c2tnb239v2: &'static [u8; 11usize] = b"c2tnb239v2\0";
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const SN_X9_62_c2tnb239v3: &'static [u8; 11usize] = b"c2tnb239v3\0";
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const SN_X9_62_c2onb239v4: &'static [u8; 11usize] = b"c2onb239v4\0";
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const SN_X9_62_c2onb239v5: &'static [u8; 11usize] = b"c2onb239v5\0";
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const SN_X9_62_c2pnb272w1: &'static [u8; 11usize] = b"c2pnb272w1\0";
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const SN_X9_62_c2pnb304w1: &'static [u8; 11usize] = b"c2pnb304w1\0";
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const SN_X9_62_c2tnb359v1: &'static [u8; 11usize] = b"c2tnb359v1\0";
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const SN_X9_62_c2pnb368w1: &'static [u8; 11usize] = b"c2pnb368w1\0";
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const SN_X9_62_c2tnb431r1: &'static [u8; 11usize] = b"c2tnb431r1\0";
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const SN_X9_62_prime192v1: &'static [u8; 11usize] = b"prime192v1\0";
pub const NID_X9_62_prime192v1: u32 = 409;
pub const SN_X9_62_prime192v2: &'static [u8; 11usize] = b"prime192v2\0";
pub const NID_X9_62_prime192v2: u32 = 410;
pub const SN_X9_62_prime192v3: &'static [u8; 11usize] = b"prime192v3\0";
pub const NID_X9_62_prime192v3: u32 = 411;
pub const SN_X9_62_prime239v1: &'static [u8; 11usize] = b"prime239v1\0";
pub const NID_X9_62_prime239v1: u32 = 412;
pub const SN_X9_62_prime239v2: &'static [u8; 11usize] = b"prime239v2\0";
pub const NID_X9_62_prime239v2: u32 = 413;
pub const SN_X9_62_prime239v3: &'static [u8; 11usize] = b"prime239v3\0";
pub const NID_X9_62_prime239v3: u32 = 414;
pub const SN_X9_62_prime256v1: &'static [u8; 11usize] = b"prime256v1\0";
pub const NID_X9_62_prime256v1: u32 = 415;
pub const SN_ecdsa_with_SHA1: &'static [u8; 16usize] = b"ecdsa-with-SHA1\0";
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const SN_ecdsa_with_Recommended: &'static [u8; 23usize] = b"ecdsa-with-Recommended\0";
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const SN_ecdsa_with_Specified: &'static [u8; 21usize] = b"ecdsa-with-Specified\0";
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const SN_ecdsa_with_SHA224: &'static [u8; 18usize] = b"ecdsa-with-SHA224\0";
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const SN_ecdsa_with_SHA256: &'static [u8; 18usize] = b"ecdsa-with-SHA256\0";
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const SN_ecdsa_with_SHA384: &'static [u8; 18usize] = b"ecdsa-with-SHA384\0";
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const SN_ecdsa_with_SHA512: &'static [u8; 18usize] = b"ecdsa-with-SHA512\0";
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const SN_secp112r1: &'static [u8; 10usize] = b"secp112r1\0";
pub const NID_secp112r1: u32 = 704;
pub const SN_secp112r2: &'static [u8; 10usize] = b"secp112r2\0";
pub const NID_secp112r2: u32 = 705;
pub const SN_secp128r1: &'static [u8; 10usize] = b"secp128r1\0";
pub const NID_secp128r1: u32 = 706;
pub const SN_secp128r2: &'static [u8; 10usize] = b"secp128r2\0";
pub const NID_secp128r2: u32 = 707;
pub const SN_secp160k1: &'static [u8; 10usize] = b"secp160k1\0";
pub const NID_secp160k1: u32 = 708;
pub const SN_secp160r1: &'static [u8; 10usize] = b"secp160r1\0";
pub const NID_secp160r1: u32 = 709;
pub const SN_secp160r2: &'static [u8; 10usize] = b"secp160r2\0";
pub const NID_secp160r2: u32 = 710;
pub const SN_secp192k1: &'static [u8; 10usize] = b"secp192k1\0";
pub const NID_secp192k1: u32 = 711;
pub const SN_secp224k1: &'static [u8; 10usize] = b"secp224k1\0";
pub const NID_secp224k1: u32 = 712;
pub const SN_secp224r1: &'static [u8; 10usize] = b"secp224r1\0";
pub const NID_secp224r1: u32 = 713;
pub const SN_secp256k1: &'static [u8; 10usize] = b"secp256k1\0";
pub const NID_secp256k1: u32 = 714;
pub const SN_secp384r1: &'static [u8; 10usize] = b"secp384r1\0";
pub const NID_secp384r1: u32 = 715;
pub const SN_secp521r1: &'static [u8; 10usize] = b"secp521r1\0";
pub const NID_secp521r1: u32 = 716;
pub const SN_sect113r1: &'static [u8; 10usize] = b"sect113r1\0";
pub const NID_sect113r1: u32 = 717;
pub const SN_sect113r2: &'static [u8; 10usize] = b"sect113r2\0";
pub const NID_sect113r2: u32 = 718;
pub const SN_sect131r1: &'static [u8; 10usize] = b"sect131r1\0";
pub const NID_sect131r1: u32 = 719;
pub const SN_sect131r2: &'static [u8; 10usize] = b"sect131r2\0";
pub const NID_sect131r2: u32 = 720;
pub const SN_sect163k1: &'static [u8; 10usize] = b"sect163k1\0";
pub const NID_sect163k1: u32 = 721;
pub const SN_sect163r1: &'static [u8; 10usize] = b"sect163r1\0";
pub const NID_sect163r1: u32 = 722;
pub const SN_sect163r2: &'static [u8; 10usize] = b"sect163r2\0";
pub const NID_sect163r2: u32 = 723;
pub const SN_sect193r1: &'static [u8; 10usize] = b"sect193r1\0";
pub const NID_sect193r1: u32 = 724;
pub const SN_sect193r2: &'static [u8; 10usize] = b"sect193r2\0";
pub const NID_sect193r2: u32 = 725;
pub const SN_sect233k1: &'static [u8; 10usize] = b"sect233k1\0";
pub const NID_sect233k1: u32 = 726;
pub const SN_sect233r1: &'static [u8; 10usize] = b"sect233r1\0";
pub const NID_sect233r1: u32 = 727;
pub const SN_sect239k1: &'static [u8; 10usize] = b"sect239k1\0";
pub const NID_sect239k1: u32 = 728;
pub const SN_sect283k1: &'static [u8; 10usize] = b"sect283k1\0";
pub const NID_sect283k1: u32 = 729;
pub const SN_sect283r1: &'static [u8; 10usize] = b"sect283r1\0";
pub const NID_sect283r1: u32 = 730;
pub const SN_sect409k1: &'static [u8; 10usize] = b"sect409k1\0";
pub const NID_sect409k1: u32 = 731;
pub const SN_sect409r1: &'static [u8; 10usize] = b"sect409r1\0";
pub const NID_sect409r1: u32 = 732;
pub const SN_sect571k1: &'static [u8; 10usize] = b"sect571k1\0";
pub const NID_sect571k1: u32 = 733;
pub const SN_sect571r1: &'static [u8; 10usize] = b"sect571r1\0";
pub const NID_sect571r1: u32 = 734;
pub const SN_wap_wsg_idm_ecid_wtls1: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls1\0";
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const SN_wap_wsg_idm_ecid_wtls3: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls3\0";
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const SN_wap_wsg_idm_ecid_wtls4: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls4\0";
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const SN_wap_wsg_idm_ecid_wtls5: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls5\0";
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const SN_wap_wsg_idm_ecid_wtls6: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls6\0";
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const SN_wap_wsg_idm_ecid_wtls7: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls7\0";
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const SN_wap_wsg_idm_ecid_wtls8: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls8\0";
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const SN_wap_wsg_idm_ecid_wtls9: &'static [u8; 23usize] = b"wap-wsg-idm-ecid-wtls9\0";
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const SN_wap_wsg_idm_ecid_wtls10: &'static [u8; 24usize] = b"wap-wsg-idm-ecid-wtls10\0";
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const SN_wap_wsg_idm_ecid_wtls11: &'static [u8; 24usize] = b"wap-wsg-idm-ecid-wtls11\0";
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const SN_wap_wsg_idm_ecid_wtls12: &'static [u8; 24usize] = b"wap-wsg-idm-ecid-wtls12\0";
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const SN_cast5_cbc: &'static [u8; 10usize] = b"CAST5-CBC\0";
pub const LN_cast5_cbc: &'static [u8; 10usize] = b"cast5-cbc\0";
pub const NID_cast5_cbc: u32 = 108;
pub const SN_cast5_ecb: &'static [u8; 10usize] = b"CAST5-ECB\0";
pub const LN_cast5_ecb: &'static [u8; 10usize] = b"cast5-ecb\0";
pub const NID_cast5_ecb: u32 = 109;
pub const SN_cast5_cfb64: &'static [u8; 10usize] = b"CAST5-CFB\0";
pub const LN_cast5_cfb64: &'static [u8; 10usize] = b"cast5-cfb\0";
pub const NID_cast5_cfb64: u32 = 110;
pub const SN_cast5_ofb64: &'static [u8; 10usize] = b"CAST5-OFB\0";
pub const LN_cast5_ofb64: &'static [u8; 10usize] = b"cast5-ofb\0";
pub const NID_cast5_ofb64: u32 = 111;
pub const LN_pbeWithMD5AndCast5_CBC: &'static [u8; 22usize] = b"pbeWithMD5AndCast5CBC\0";
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const SN_id_PasswordBasedMAC: &'static [u8; 20usize] = b"id-PasswordBasedMAC\0";
pub const LN_id_PasswordBasedMAC: &'static [u8; 19usize] = b"password based MAC\0";
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const SN_id_DHBasedMac: &'static [u8; 14usize] = b"id-DHBasedMac\0";
pub const LN_id_DHBasedMac: &'static [u8; 25usize] = b"Diffie-Hellman based MAC\0";
pub const NID_id_DHBasedMac: u32 = 783;
pub const SN_rsadsi: &'static [u8; 7usize] = b"rsadsi\0";
pub const LN_rsadsi: &'static [u8; 24usize] = b"RSA Data Security, Inc.\0";
pub const NID_rsadsi: u32 = 1;
pub const SN_pkcs: &'static [u8; 5usize] = b"pkcs\0";
pub const LN_pkcs: &'static [u8; 29usize] = b"RSA Data Security, Inc. PKCS\0";
pub const NID_pkcs: u32 = 2;
pub const SN_pkcs1: &'static [u8; 6usize] = b"pkcs1\0";
pub const NID_pkcs1: u32 = 186;
pub const LN_rsaEncryption: &'static [u8; 14usize] = b"rsaEncryption\0";
pub const NID_rsaEncryption: u32 = 6;
pub const SN_md2WithRSAEncryption: &'static [u8; 8usize] = b"RSA-MD2\0";
pub const LN_md2WithRSAEncryption: &'static [u8; 21usize] = b"md2WithRSAEncryption\0";
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const SN_md4WithRSAEncryption: &'static [u8; 8usize] = b"RSA-MD4\0";
pub const LN_md4WithRSAEncryption: &'static [u8; 21usize] = b"md4WithRSAEncryption\0";
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const SN_md5WithRSAEncryption: &'static [u8; 8usize] = b"RSA-MD5\0";
pub const LN_md5WithRSAEncryption: &'static [u8; 21usize] = b"md5WithRSAEncryption\0";
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const SN_sha1WithRSAEncryption: &'static [u8; 9usize] = b"RSA-SHA1\0";
pub const LN_sha1WithRSAEncryption: &'static [u8; 22usize] = b"sha1WithRSAEncryption\0";
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const SN_rsaesOaep: &'static [u8; 11usize] = b"RSAES-OAEP\0";
pub const LN_rsaesOaep: &'static [u8; 10usize] = b"rsaesOaep\0";
pub const NID_rsaesOaep: u32 = 919;
pub const SN_mgf1: &'static [u8; 5usize] = b"MGF1\0";
pub const LN_mgf1: &'static [u8; 5usize] = b"mgf1\0";
pub const NID_mgf1: u32 = 911;
pub const SN_pSpecified: &'static [u8; 11usize] = b"PSPECIFIED\0";
pub const LN_pSpecified: &'static [u8; 11usize] = b"pSpecified\0";
pub const NID_pSpecified: u32 = 935;
pub const SN_rsassaPss: &'static [u8; 11usize] = b"RSASSA-PSS\0";
pub const LN_rsassaPss: &'static [u8; 10usize] = b"rsassaPss\0";
pub const NID_rsassaPss: u32 = 912;
pub const SN_sha256WithRSAEncryption: &'static [u8; 11usize] = b"RSA-SHA256\0";
pub const LN_sha256WithRSAEncryption: &'static [u8; 24usize] = b"sha256WithRSAEncryption\0";
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const SN_sha384WithRSAEncryption: &'static [u8; 11usize] = b"RSA-SHA384\0";
pub const LN_sha384WithRSAEncryption: &'static [u8; 24usize] = b"sha384WithRSAEncryption\0";
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const SN_sha512WithRSAEncryption: &'static [u8; 11usize] = b"RSA-SHA512\0";
pub const LN_sha512WithRSAEncryption: &'static [u8; 24usize] = b"sha512WithRSAEncryption\0";
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const SN_sha224WithRSAEncryption: &'static [u8; 11usize] = b"RSA-SHA224\0";
pub const LN_sha224WithRSAEncryption: &'static [u8; 24usize] = b"sha224WithRSAEncryption\0";
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const SN_pkcs3: &'static [u8; 6usize] = b"pkcs3\0";
pub const NID_pkcs3: u32 = 27;
pub const LN_dhKeyAgreement: &'static [u8; 15usize] = b"dhKeyAgreement\0";
pub const NID_dhKeyAgreement: u32 = 28;
pub const SN_pkcs5: &'static [u8; 6usize] = b"pkcs5\0";
pub const NID_pkcs5: u32 = 187;
pub const SN_pbeWithMD2AndDES_CBC: &'static [u8; 12usize] = b"PBE-MD2-DES\0";
pub const LN_pbeWithMD2AndDES_CBC: &'static [u8; 21usize] = b"pbeWithMD2AndDES-CBC\0";
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const SN_pbeWithMD5AndDES_CBC: &'static [u8; 12usize] = b"PBE-MD5-DES\0";
pub const LN_pbeWithMD5AndDES_CBC: &'static [u8; 21usize] = b"pbeWithMD5AndDES-CBC\0";
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const SN_pbeWithMD2AndRC2_CBC: &'static [u8; 15usize] = b"PBE-MD2-RC2-64\0";
pub const LN_pbeWithMD2AndRC2_CBC: &'static [u8; 21usize] = b"pbeWithMD2AndRC2-CBC\0";
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const SN_pbeWithMD5AndRC2_CBC: &'static [u8; 15usize] = b"PBE-MD5-RC2-64\0";
pub const LN_pbeWithMD5AndRC2_CBC: &'static [u8; 21usize] = b"pbeWithMD5AndRC2-CBC\0";
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const SN_pbeWithSHA1AndDES_CBC: &'static [u8; 13usize] = b"PBE-SHA1-DES\0";
pub const LN_pbeWithSHA1AndDES_CBC: &'static [u8; 22usize] = b"pbeWithSHA1AndDES-CBC\0";
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const SN_pbeWithSHA1AndRC2_CBC: &'static [u8; 16usize] = b"PBE-SHA1-RC2-64\0";
pub const LN_pbeWithSHA1AndRC2_CBC: &'static [u8; 22usize] = b"pbeWithSHA1AndRC2-CBC\0";
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const LN_id_pbkdf2: &'static [u8; 7usize] = b"PBKDF2\0";
pub const NID_id_pbkdf2: u32 = 69;
pub const LN_pbes2: &'static [u8; 6usize] = b"PBES2\0";
pub const NID_pbes2: u32 = 161;
pub const LN_pbmac1: &'static [u8; 7usize] = b"PBMAC1\0";
pub const NID_pbmac1: u32 = 162;
pub const SN_pkcs7: &'static [u8; 6usize] = b"pkcs7\0";
pub const NID_pkcs7: u32 = 20;
pub const LN_pkcs7_data: &'static [u8; 11usize] = b"pkcs7-data\0";
pub const NID_pkcs7_data: u32 = 21;
pub const LN_pkcs7_signed: &'static [u8; 17usize] = b"pkcs7-signedData\0";
pub const NID_pkcs7_signed: u32 = 22;
pub const LN_pkcs7_enveloped: &'static [u8; 20usize] = b"pkcs7-envelopedData\0";
pub const NID_pkcs7_enveloped: u32 = 23;
pub const LN_pkcs7_signedAndEnveloped: &'static [u8; 29usize] = b"pkcs7-signedAndEnvelopedData\0";
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const LN_pkcs7_digest: &'static [u8; 17usize] = b"pkcs7-digestData\0";
pub const NID_pkcs7_digest: u32 = 25;
pub const LN_pkcs7_encrypted: &'static [u8; 20usize] = b"pkcs7-encryptedData\0";
pub const NID_pkcs7_encrypted: u32 = 26;
pub const SN_pkcs9: &'static [u8; 6usize] = b"pkcs9\0";
pub const NID_pkcs9: u32 = 47;
pub const LN_pkcs9_emailAddress: &'static [u8; 13usize] = b"emailAddress\0";
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const LN_pkcs9_unstructuredName: &'static [u8; 17usize] = b"unstructuredName\0";
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const LN_pkcs9_contentType: &'static [u8; 12usize] = b"contentType\0";
pub const NID_pkcs9_contentType: u32 = 50;
pub const LN_pkcs9_messageDigest: &'static [u8; 14usize] = b"messageDigest\0";
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const LN_pkcs9_signingTime: &'static [u8; 12usize] = b"signingTime\0";
pub const NID_pkcs9_signingTime: u32 = 52;
pub const LN_pkcs9_countersignature: &'static [u8; 17usize] = b"countersignature\0";
pub const NID_pkcs9_countersignature: u32 = 53;
pub const LN_pkcs9_challengePassword: &'static [u8; 18usize] = b"challengePassword\0";
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const LN_pkcs9_unstructuredAddress: &'static [u8; 20usize] = b"unstructuredAddress\0";
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const LN_pkcs9_extCertAttributes: &'static [u8; 30usize] = b"extendedCertificateAttributes\0";
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const SN_ext_req: &'static [u8; 7usize] = b"extReq\0";
pub const LN_ext_req: &'static [u8; 18usize] = b"Extension Request\0";
pub const NID_ext_req: u32 = 172;
pub const SN_SMIMECapabilities: &'static [u8; 11usize] = b"SMIME-CAPS\0";
pub const LN_SMIMECapabilities: &'static [u8; 20usize] = b"S/MIME Capabilities\0";
pub const NID_SMIMECapabilities: u32 = 167;
pub const SN_SMIME: &'static [u8; 6usize] = b"SMIME\0";
pub const LN_SMIME: &'static [u8; 7usize] = b"S/MIME\0";
pub const NID_SMIME: u32 = 188;
pub const SN_id_smime_mod: &'static [u8; 13usize] = b"id-smime-mod\0";
pub const NID_id_smime_mod: u32 = 189;
pub const SN_id_smime_ct: &'static [u8; 12usize] = b"id-smime-ct\0";
pub const NID_id_smime_ct: u32 = 190;
pub const SN_id_smime_aa: &'static [u8; 12usize] = b"id-smime-aa\0";
pub const NID_id_smime_aa: u32 = 191;
pub const SN_id_smime_alg: &'static [u8; 13usize] = b"id-smime-alg\0";
pub const NID_id_smime_alg: u32 = 192;
pub const SN_id_smime_cd: &'static [u8; 12usize] = b"id-smime-cd\0";
pub const NID_id_smime_cd: u32 = 193;
pub const SN_id_smime_spq: &'static [u8; 13usize] = b"id-smime-spq\0";
pub const NID_id_smime_spq: u32 = 194;
pub const SN_id_smime_cti: &'static [u8; 13usize] = b"id-smime-cti\0";
pub const NID_id_smime_cti: u32 = 195;
pub const SN_id_smime_mod_cms: &'static [u8; 17usize] = b"id-smime-mod-cms\0";
pub const NID_id_smime_mod_cms: u32 = 196;
pub const SN_id_smime_mod_ess: &'static [u8; 17usize] = b"id-smime-mod-ess\0";
pub const NID_id_smime_mod_ess: u32 = 197;
pub const SN_id_smime_mod_oid: &'static [u8; 17usize] = b"id-smime-mod-oid\0";
pub const NID_id_smime_mod_oid: u32 = 198;
pub const SN_id_smime_mod_msg_v3: &'static [u8; 20usize] = b"id-smime-mod-msg-v3\0";
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const SN_id_smime_mod_ets_eSignature_88: &'static [u8; 31usize] =
    b"id-smime-mod-ets-eSignature-88\0";
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const SN_id_smime_mod_ets_eSignature_97: &'static [u8; 31usize] =
    b"id-smime-mod-ets-eSignature-97\0";
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const SN_id_smime_mod_ets_eSigPolicy_88: &'static [u8; 31usize] =
    b"id-smime-mod-ets-eSigPolicy-88\0";
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const SN_id_smime_mod_ets_eSigPolicy_97: &'static [u8; 31usize] =
    b"id-smime-mod-ets-eSigPolicy-97\0";
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const SN_id_smime_ct_receipt: &'static [u8; 20usize] = b"id-smime-ct-receipt\0";
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const SN_id_smime_ct_authData: &'static [u8; 21usize] = b"id-smime-ct-authData\0";
pub const NID_id_smime_ct_authData: u32 = 205;
pub const SN_id_smime_ct_publishCert: &'static [u8; 24usize] = b"id-smime-ct-publishCert\0";
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const SN_id_smime_ct_TSTInfo: &'static [u8; 20usize] = b"id-smime-ct-TSTInfo\0";
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const SN_id_smime_ct_TDTInfo: &'static [u8; 20usize] = b"id-smime-ct-TDTInfo\0";
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const SN_id_smime_ct_contentInfo: &'static [u8; 24usize] = b"id-smime-ct-contentInfo\0";
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const SN_id_smime_ct_DVCSRequestData: &'static [u8; 28usize] = b"id-smime-ct-DVCSRequestData\0";
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const SN_id_smime_ct_DVCSResponseData: &'static [u8; 29usize] =
    b"id-smime-ct-DVCSResponseData\0";
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const SN_id_smime_ct_compressedData: &'static [u8; 27usize] = b"id-smime-ct-compressedData\0";
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const SN_id_ct_asciiTextWithCRLF: &'static [u8; 24usize] = b"id-ct-asciiTextWithCRLF\0";
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const SN_id_smime_aa_receiptRequest: &'static [u8; 27usize] = b"id-smime-aa-receiptRequest\0";
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const SN_id_smime_aa_securityLabel: &'static [u8; 26usize] = b"id-smime-aa-securityLabel\0";
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const SN_id_smime_aa_mlExpandHistory: &'static [u8; 28usize] = b"id-smime-aa-mlExpandHistory\0";
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const SN_id_smime_aa_contentHint: &'static [u8; 24usize] = b"id-smime-aa-contentHint\0";
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const SN_id_smime_aa_msgSigDigest: &'static [u8; 25usize] = b"id-smime-aa-msgSigDigest\0";
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const SN_id_smime_aa_encapContentType: &'static [u8; 29usize] =
    b"id-smime-aa-encapContentType\0";
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const SN_id_smime_aa_contentIdentifier: &'static [u8; 30usize] =
    b"id-smime-aa-contentIdentifier\0";
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const SN_id_smime_aa_macValue: &'static [u8; 21usize] = b"id-smime-aa-macValue\0";
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const SN_id_smime_aa_equivalentLabels: &'static [u8; 29usize] =
    b"id-smime-aa-equivalentLabels\0";
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const SN_id_smime_aa_contentReference: &'static [u8; 29usize] =
    b"id-smime-aa-contentReference\0";
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const SN_id_smime_aa_encrypKeyPref: &'static [u8; 26usize] = b"id-smime-aa-encrypKeyPref\0";
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const SN_id_smime_aa_signingCertificate: &'static [u8; 31usize] =
    b"id-smime-aa-signingCertificate\0";
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const SN_id_smime_aa_smimeEncryptCerts: &'static [u8; 30usize] =
    b"id-smime-aa-smimeEncryptCerts\0";
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const SN_id_smime_aa_timeStampToken: &'static [u8; 27usize] = b"id-smime-aa-timeStampToken\0";
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const SN_id_smime_aa_ets_sigPolicyId: &'static [u8; 28usize] = b"id-smime-aa-ets-sigPolicyId\0";
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const SN_id_smime_aa_ets_commitmentType: &'static [u8; 31usize] =
    b"id-smime-aa-ets-commitmentType\0";
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const SN_id_smime_aa_ets_signerLocation: &'static [u8; 31usize] =
    b"id-smime-aa-ets-signerLocation\0";
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const SN_id_smime_aa_ets_signerAttr: &'static [u8; 27usize] = b"id-smime-aa-ets-signerAttr\0";
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const SN_id_smime_aa_ets_otherSigCert: &'static [u8; 29usize] =
    b"id-smime-aa-ets-otherSigCert\0";
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const SN_id_smime_aa_ets_contentTimestamp: &'static [u8; 33usize] =
    b"id-smime-aa-ets-contentTimestamp\0";
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const SN_id_smime_aa_ets_CertificateRefs: &'static [u8; 32usize] =
    b"id-smime-aa-ets-CertificateRefs\0";
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const SN_id_smime_aa_ets_RevocationRefs: &'static [u8; 31usize] =
    b"id-smime-aa-ets-RevocationRefs\0";
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const SN_id_smime_aa_ets_certValues: &'static [u8; 27usize] = b"id-smime-aa-ets-certValues\0";
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const SN_id_smime_aa_ets_revocationValues: &'static [u8; 33usize] =
    b"id-smime-aa-ets-revocationValues\0";
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const SN_id_smime_aa_ets_escTimeStamp: &'static [u8; 29usize] =
    b"id-smime-aa-ets-escTimeStamp\0";
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const SN_id_smime_aa_ets_certCRLTimestamp: &'static [u8; 33usize] =
    b"id-smime-aa-ets-certCRLTimestamp\0";
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const SN_id_smime_aa_ets_archiveTimeStamp: &'static [u8; 33usize] =
    b"id-smime-aa-ets-archiveTimeStamp\0";
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const SN_id_smime_aa_signatureType: &'static [u8; 26usize] = b"id-smime-aa-signatureType\0";
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const SN_id_smime_aa_dvcs_dvc: &'static [u8; 21usize] = b"id-smime-aa-dvcs-dvc\0";
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const SN_id_smime_alg_ESDHwith3DES: &'static [u8; 26usize] = b"id-smime-alg-ESDHwith3DES\0";
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const SN_id_smime_alg_ESDHwithRC2: &'static [u8; 25usize] = b"id-smime-alg-ESDHwithRC2\0";
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const SN_id_smime_alg_3DESwrap: &'static [u8; 22usize] = b"id-smime-alg-3DESwrap\0";
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const SN_id_smime_alg_RC2wrap: &'static [u8; 21usize] = b"id-smime-alg-RC2wrap\0";
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const SN_id_smime_alg_ESDH: &'static [u8; 18usize] = b"id-smime-alg-ESDH\0";
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const SN_id_smime_alg_CMS3DESwrap: &'static [u8; 25usize] = b"id-smime-alg-CMS3DESwrap\0";
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const SN_id_smime_alg_CMSRC2wrap: &'static [u8; 24usize] = b"id-smime-alg-CMSRC2wrap\0";
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const SN_id_alg_PWRI_KEK: &'static [u8; 16usize] = b"id-alg-PWRI-KEK\0";
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const SN_id_smime_cd_ldap: &'static [u8; 17usize] = b"id-smime-cd-ldap\0";
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const SN_id_smime_spq_ets_sqt_uri: &'static [u8; 25usize] = b"id-smime-spq-ets-sqt-uri\0";
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const SN_id_smime_spq_ets_sqt_unotice: &'static [u8; 29usize] =
    b"id-smime-spq-ets-sqt-unotice\0";
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const SN_id_smime_cti_ets_proofOfOrigin: &'static [u8; 31usize] =
    b"id-smime-cti-ets-proofOfOrigin\0";
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const SN_id_smime_cti_ets_proofOfReceipt: &'static [u8; 32usize] =
    b"id-smime-cti-ets-proofOfReceipt\0";
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const SN_id_smime_cti_ets_proofOfDelivery: &'static [u8; 33usize] =
    b"id-smime-cti-ets-proofOfDelivery\0";
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const SN_id_smime_cti_ets_proofOfSender: &'static [u8; 31usize] =
    b"id-smime-cti-ets-proofOfSender\0";
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const SN_id_smime_cti_ets_proofOfApproval: &'static [u8; 33usize] =
    b"id-smime-cti-ets-proofOfApproval\0";
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const SN_id_smime_cti_ets_proofOfCreation: &'static [u8; 33usize] =
    b"id-smime-cti-ets-proofOfCreation\0";
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const LN_friendlyName: &'static [u8; 13usize] = b"friendlyName\0";
pub const NID_friendlyName: u32 = 156;
pub const LN_localKeyID: &'static [u8; 11usize] = b"localKeyID\0";
pub const NID_localKeyID: u32 = 157;
pub const SN_ms_csp_name: &'static [u8; 8usize] = b"CSPName\0";
pub const LN_ms_csp_name: &'static [u8; 19usize] = b"Microsoft CSP Name\0";
pub const NID_ms_csp_name: u32 = 417;
pub const SN_LocalKeySet: &'static [u8; 12usize] = b"LocalKeySet\0";
pub const LN_LocalKeySet: &'static [u8; 24usize] = b"Microsoft Local Key set\0";
pub const NID_LocalKeySet: u32 = 856;
pub const LN_x509Certificate: &'static [u8; 16usize] = b"x509Certificate\0";
pub const NID_x509Certificate: u32 = 158;
pub const LN_sdsiCertificate: &'static [u8; 16usize] = b"sdsiCertificate\0";
pub const NID_sdsiCertificate: u32 = 159;
pub const LN_x509Crl: &'static [u8; 8usize] = b"x509Crl\0";
pub const NID_x509Crl: u32 = 160;
pub const SN_pbe_WithSHA1And128BitRC4: &'static [u8; 17usize] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &'static [u8; 24usize] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &'static [u8; 16usize] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &'static [u8; 23usize] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC: &'static [u8; 14usize] = b"PBE-SHA1-3DES\0";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC: &'static [u8; 33usize] =
    b"pbeWithSHA1And3-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC: &'static [u8; 14usize] = b"PBE-SHA1-2DES\0";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC: &'static [u8; 33usize] =
    b"pbeWithSHA1And2-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const SN_pbe_WithSHA1And128BitRC2_CBC: &'static [u8; 17usize] = b"PBE-SHA1-RC2-128\0";
pub const LN_pbe_WithSHA1And128BitRC2_CBC: &'static [u8; 28usize] =
    b"pbeWithSHA1And128BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const SN_pbe_WithSHA1And40BitRC2_CBC: &'static [u8; 16usize] = b"PBE-SHA1-RC2-40\0";
pub const LN_pbe_WithSHA1And40BitRC2_CBC: &'static [u8; 27usize] = b"pbeWithSHA1And40BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const LN_keyBag: &'static [u8; 7usize] = b"keyBag\0";
pub const NID_keyBag: u32 = 150;
pub const LN_pkcs8ShroudedKeyBag: &'static [u8; 20usize] = b"pkcs8ShroudedKeyBag\0";
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const LN_certBag: &'static [u8; 8usize] = b"certBag\0";
pub const NID_certBag: u32 = 152;
pub const LN_crlBag: &'static [u8; 7usize] = b"crlBag\0";
pub const NID_crlBag: u32 = 153;
pub const LN_secretBag: &'static [u8; 10usize] = b"secretBag\0";
pub const NID_secretBag: u32 = 154;
pub const LN_safeContentsBag: &'static [u8; 16usize] = b"safeContentsBag\0";
pub const NID_safeContentsBag: u32 = 155;
pub const SN_md2: &'static [u8; 4usize] = b"MD2\0";
pub const LN_md2: &'static [u8; 4usize] = b"md2\0";
pub const NID_md2: u32 = 3;
pub const SN_md4: &'static [u8; 4usize] = b"MD4\0";
pub const LN_md4: &'static [u8; 4usize] = b"md4\0";
pub const NID_md4: u32 = 257;
pub const SN_md5: &'static [u8; 4usize] = b"MD5\0";
pub const LN_md5: &'static [u8; 4usize] = b"md5\0";
pub const NID_md5: u32 = 4;
pub const SN_md5_sha1: &'static [u8; 9usize] = b"MD5-SHA1\0";
pub const LN_md5_sha1: &'static [u8; 9usize] = b"md5-sha1\0";
pub const NID_md5_sha1: u32 = 114;
pub const LN_hmacWithMD5: &'static [u8; 12usize] = b"hmacWithMD5\0";
pub const NID_hmacWithMD5: u32 = 797;
pub const LN_hmacWithSHA1: &'static [u8; 13usize] = b"hmacWithSHA1\0";
pub const NID_hmacWithSHA1: u32 = 163;
pub const LN_hmacWithSHA224: &'static [u8; 15usize] = b"hmacWithSHA224\0";
pub const NID_hmacWithSHA224: u32 = 798;
pub const LN_hmacWithSHA256: &'static [u8; 15usize] = b"hmacWithSHA256\0";
pub const NID_hmacWithSHA256: u32 = 799;
pub const LN_hmacWithSHA384: &'static [u8; 15usize] = b"hmacWithSHA384\0";
pub const NID_hmacWithSHA384: u32 = 800;
pub const LN_hmacWithSHA512: &'static [u8; 15usize] = b"hmacWithSHA512\0";
pub const NID_hmacWithSHA512: u32 = 801;
pub const SN_rc2_cbc: &'static [u8; 8usize] = b"RC2-CBC\0";
pub const LN_rc2_cbc: &'static [u8; 8usize] = b"rc2-cbc\0";
pub const NID_rc2_cbc: u32 = 37;
pub const SN_rc2_ecb: &'static [u8; 8usize] = b"RC2-ECB\0";
pub const LN_rc2_ecb: &'static [u8; 8usize] = b"rc2-ecb\0";
pub const NID_rc2_ecb: u32 = 38;
pub const SN_rc2_cfb64: &'static [u8; 8usize] = b"RC2-CFB\0";
pub const LN_rc2_cfb64: &'static [u8; 8usize] = b"rc2-cfb\0";
pub const NID_rc2_cfb64: u32 = 39;
pub const SN_rc2_ofb64: &'static [u8; 8usize] = b"RC2-OFB\0";
pub const LN_rc2_ofb64: &'static [u8; 8usize] = b"rc2-ofb\0";
pub const NID_rc2_ofb64: u32 = 40;
pub const SN_rc2_40_cbc: &'static [u8; 11usize] = b"RC2-40-CBC\0";
pub const LN_rc2_40_cbc: &'static [u8; 11usize] = b"rc2-40-cbc\0";
pub const NID_rc2_40_cbc: u32 = 98;
pub const SN_rc2_64_cbc: &'static [u8; 11usize] = b"RC2-64-CBC\0";
pub const LN_rc2_64_cbc: &'static [u8; 11usize] = b"rc2-64-cbc\0";
pub const NID_rc2_64_cbc: u32 = 166;
pub const SN_rc4: &'static [u8; 4usize] = b"RC4\0";
pub const LN_rc4: &'static [u8; 4usize] = b"rc4\0";
pub const NID_rc4: u32 = 5;
pub const SN_rc4_40: &'static [u8; 7usize] = b"RC4-40\0";
pub const LN_rc4_40: &'static [u8; 7usize] = b"rc4-40\0";
pub const NID_rc4_40: u32 = 97;
pub const SN_des_ede3_cbc: &'static [u8; 13usize] = b"DES-EDE3-CBC\0";
pub const LN_des_ede3_cbc: &'static [u8; 13usize] = b"des-ede3-cbc\0";
pub const NID_des_ede3_cbc: u32 = 44;
pub const SN_rc5_cbc: &'static [u8; 8usize] = b"RC5-CBC\0";
pub const LN_rc5_cbc: &'static [u8; 8usize] = b"rc5-cbc\0";
pub const NID_rc5_cbc: u32 = 120;
pub const SN_rc5_ecb: &'static [u8; 8usize] = b"RC5-ECB\0";
pub const LN_rc5_ecb: &'static [u8; 8usize] = b"rc5-ecb\0";
pub const NID_rc5_ecb: u32 = 121;
pub const SN_rc5_cfb64: &'static [u8; 8usize] = b"RC5-CFB\0";
pub const LN_rc5_cfb64: &'static [u8; 8usize] = b"rc5-cfb\0";
pub const NID_rc5_cfb64: u32 = 122;
pub const SN_rc5_ofb64: &'static [u8; 8usize] = b"RC5-OFB\0";
pub const LN_rc5_ofb64: &'static [u8; 8usize] = b"rc5-ofb\0";
pub const NID_rc5_ofb64: u32 = 123;
pub const SN_ms_ext_req: &'static [u8; 9usize] = b"msExtReq\0";
pub const LN_ms_ext_req: &'static [u8; 28usize] = b"Microsoft Extension Request\0";
pub const NID_ms_ext_req: u32 = 171;
pub const SN_ms_code_ind: &'static [u8; 10usize] = b"msCodeInd\0";
pub const LN_ms_code_ind: &'static [u8; 34usize] = b"Microsoft Individual Code Signing\0";
pub const NID_ms_code_ind: u32 = 134;
pub const SN_ms_code_com: &'static [u8; 10usize] = b"msCodeCom\0";
pub const LN_ms_code_com: &'static [u8; 34usize] = b"Microsoft Commercial Code Signing\0";
pub const NID_ms_code_com: u32 = 135;
pub const SN_ms_ctl_sign: &'static [u8; 10usize] = b"msCTLSign\0";
pub const LN_ms_ctl_sign: &'static [u8; 29usize] = b"Microsoft Trust List Signing\0";
pub const NID_ms_ctl_sign: u32 = 136;
pub const SN_ms_sgc: &'static [u8; 6usize] = b"msSGC\0";
pub const LN_ms_sgc: &'static [u8; 30usize] = b"Microsoft Server Gated Crypto\0";
pub const NID_ms_sgc: u32 = 137;
pub const SN_ms_efs: &'static [u8; 6usize] = b"msEFS\0";
pub const LN_ms_efs: &'static [u8; 32usize] = b"Microsoft Encrypted File System\0";
pub const NID_ms_efs: u32 = 138;
pub const SN_ms_smartcard_login: &'static [u8; 17usize] = b"msSmartcardLogin\0";
pub const LN_ms_smartcard_login: &'static [u8; 25usize] = b"Microsoft Smartcardlogin\0";
pub const NID_ms_smartcard_login: u32 = 648;
pub const SN_ms_upn: &'static [u8; 6usize] = b"msUPN\0";
pub const LN_ms_upn: &'static [u8; 35usize] = b"Microsoft Universal Principal Name\0";
pub const NID_ms_upn: u32 = 649;
pub const SN_idea_cbc: &'static [u8; 9usize] = b"IDEA-CBC\0";
pub const LN_idea_cbc: &'static [u8; 9usize] = b"idea-cbc\0";
pub const NID_idea_cbc: u32 = 34;
pub const SN_idea_ecb: &'static [u8; 9usize] = b"IDEA-ECB\0";
pub const LN_idea_ecb: &'static [u8; 9usize] = b"idea-ecb\0";
pub const NID_idea_ecb: u32 = 36;
pub const SN_idea_cfb64: &'static [u8; 9usize] = b"IDEA-CFB\0";
pub const LN_idea_cfb64: &'static [u8; 9usize] = b"idea-cfb\0";
pub const NID_idea_cfb64: u32 = 35;
pub const SN_idea_ofb64: &'static [u8; 9usize] = b"IDEA-OFB\0";
pub const LN_idea_ofb64: &'static [u8; 9usize] = b"idea-ofb\0";
pub const NID_idea_ofb64: u32 = 46;
pub const SN_bf_cbc: &'static [u8; 7usize] = b"BF-CBC\0";
pub const LN_bf_cbc: &'static [u8; 7usize] = b"bf-cbc\0";
pub const NID_bf_cbc: u32 = 91;
pub const SN_bf_ecb: &'static [u8; 7usize] = b"BF-ECB\0";
pub const LN_bf_ecb: &'static [u8; 7usize] = b"bf-ecb\0";
pub const NID_bf_ecb: u32 = 92;
pub const SN_bf_cfb64: &'static [u8; 7usize] = b"BF-CFB\0";
pub const LN_bf_cfb64: &'static [u8; 7usize] = b"bf-cfb\0";
pub const NID_bf_cfb64: u32 = 93;
pub const SN_bf_ofb64: &'static [u8; 7usize] = b"BF-OFB\0";
pub const LN_bf_ofb64: &'static [u8; 7usize] = b"bf-ofb\0";
pub const NID_bf_ofb64: u32 = 94;
pub const SN_id_pkix: &'static [u8; 5usize] = b"PKIX\0";
pub const NID_id_pkix: u32 = 127;
pub const SN_id_pkix_mod: &'static [u8; 12usize] = b"id-pkix-mod\0";
pub const NID_id_pkix_mod: u32 = 258;
pub const SN_id_pe: &'static [u8; 6usize] = b"id-pe\0";
pub const NID_id_pe: u32 = 175;
pub const SN_id_qt: &'static [u8; 6usize] = b"id-qt\0";
pub const NID_id_qt: u32 = 259;
pub const SN_id_kp: &'static [u8; 6usize] = b"id-kp\0";
pub const NID_id_kp: u32 = 128;
pub const SN_id_it: &'static [u8; 6usize] = b"id-it\0";
pub const NID_id_it: u32 = 260;
pub const SN_id_pkip: &'static [u8; 8usize] = b"id-pkip\0";
pub const NID_id_pkip: u32 = 261;
pub const SN_id_alg: &'static [u8; 7usize] = b"id-alg\0";
pub const NID_id_alg: u32 = 262;
pub const SN_id_cmc: &'static [u8; 7usize] = b"id-cmc\0";
pub const NID_id_cmc: u32 = 263;
pub const SN_id_on: &'static [u8; 6usize] = b"id-on\0";
pub const NID_id_on: u32 = 264;
pub const SN_id_pda: &'static [u8; 7usize] = b"id-pda\0";
pub const NID_id_pda: u32 = 265;
pub const SN_id_aca: &'static [u8; 7usize] = b"id-aca\0";
pub const NID_id_aca: u32 = 266;
pub const SN_id_qcs: &'static [u8; 7usize] = b"id-qcs\0";
pub const NID_id_qcs: u32 = 267;
pub const SN_id_cct: &'static [u8; 7usize] = b"id-cct\0";
pub const NID_id_cct: u32 = 268;
pub const SN_id_ppl: &'static [u8; 7usize] = b"id-ppl\0";
pub const NID_id_ppl: u32 = 662;
pub const SN_id_ad: &'static [u8; 6usize] = b"id-ad\0";
pub const NID_id_ad: u32 = 176;
pub const SN_id_pkix1_explicit_88: &'static [u8; 21usize] = b"id-pkix1-explicit-88\0";
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const SN_id_pkix1_implicit_88: &'static [u8; 21usize] = b"id-pkix1-implicit-88\0";
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const SN_id_pkix1_explicit_93: &'static [u8; 21usize] = b"id-pkix1-explicit-93\0";
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const SN_id_pkix1_implicit_93: &'static [u8; 21usize] = b"id-pkix1-implicit-93\0";
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const SN_id_mod_crmf: &'static [u8; 12usize] = b"id-mod-crmf\0";
pub const NID_id_mod_crmf: u32 = 273;
pub const SN_id_mod_cmc: &'static [u8; 11usize] = b"id-mod-cmc\0";
pub const NID_id_mod_cmc: u32 = 274;
pub const SN_id_mod_kea_profile_88: &'static [u8; 22usize] = b"id-mod-kea-profile-88\0";
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const SN_id_mod_kea_profile_93: &'static [u8; 22usize] = b"id-mod-kea-profile-93\0";
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const SN_id_mod_cmp: &'static [u8; 11usize] = b"id-mod-cmp\0";
pub const NID_id_mod_cmp: u32 = 277;
pub const SN_id_mod_qualified_cert_88: &'static [u8; 25usize] = b"id-mod-qualified-cert-88\0";
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const SN_id_mod_qualified_cert_93: &'static [u8; 25usize] = b"id-mod-qualified-cert-93\0";
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const SN_id_mod_attribute_cert: &'static [u8; 22usize] = b"id-mod-attribute-cert\0";
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const SN_id_mod_timestamp_protocol: &'static [u8; 26usize] = b"id-mod-timestamp-protocol\0";
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const SN_id_mod_ocsp: &'static [u8; 12usize] = b"id-mod-ocsp\0";
pub const NID_id_mod_ocsp: u32 = 282;
pub const SN_id_mod_dvcs: &'static [u8; 12usize] = b"id-mod-dvcs\0";
pub const NID_id_mod_dvcs: u32 = 283;
pub const SN_id_mod_cmp2000: &'static [u8; 15usize] = b"id-mod-cmp2000\0";
pub const NID_id_mod_cmp2000: u32 = 284;
pub const SN_info_access: &'static [u8; 20usize] = b"authorityInfoAccess\0";
pub const LN_info_access: &'static [u8; 29usize] = b"Authority Information Access\0";
pub const NID_info_access: u32 = 177;
pub const SN_biometricInfo: &'static [u8; 14usize] = b"biometricInfo\0";
pub const LN_biometricInfo: &'static [u8; 15usize] = b"Biometric Info\0";
pub const NID_biometricInfo: u32 = 285;
pub const SN_qcStatements: &'static [u8; 13usize] = b"qcStatements\0";
pub const NID_qcStatements: u32 = 286;
pub const SN_ac_auditEntity: &'static [u8; 15usize] = b"ac-auditEntity\0";
pub const NID_ac_auditEntity: u32 = 287;
pub const SN_ac_targeting: &'static [u8; 13usize] = b"ac-targeting\0";
pub const NID_ac_targeting: u32 = 288;
pub const SN_aaControls: &'static [u8; 11usize] = b"aaControls\0";
pub const NID_aaControls: u32 = 289;
pub const SN_sbgp_ipAddrBlock: &'static [u8; 17usize] = b"sbgp-ipAddrBlock\0";
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const SN_sbgp_autonomousSysNum: &'static [u8; 22usize] = b"sbgp-autonomousSysNum\0";
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const SN_sbgp_routerIdentifier: &'static [u8; 22usize] = b"sbgp-routerIdentifier\0";
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const SN_ac_proxying: &'static [u8; 12usize] = b"ac-proxying\0";
pub const NID_ac_proxying: u32 = 397;
pub const SN_sinfo_access: &'static [u8; 18usize] = b"subjectInfoAccess\0";
pub const LN_sinfo_access: &'static [u8; 27usize] = b"Subject Information Access\0";
pub const NID_sinfo_access: u32 = 398;
pub const SN_proxyCertInfo: &'static [u8; 14usize] = b"proxyCertInfo\0";
pub const LN_proxyCertInfo: &'static [u8; 30usize] = b"Proxy Certificate Information\0";
pub const NID_proxyCertInfo: u32 = 663;
pub const SN_id_qt_cps: &'static [u8; 10usize] = b"id-qt-cps\0";
pub const LN_id_qt_cps: &'static [u8; 21usize] = b"Policy Qualifier CPS\0";
pub const NID_id_qt_cps: u32 = 164;
pub const SN_id_qt_unotice: &'static [u8; 14usize] = b"id-qt-unotice\0";
pub const LN_id_qt_unotice: &'static [u8; 29usize] = b"Policy Qualifier User Notice\0";
pub const NID_id_qt_unotice: u32 = 165;
pub const SN_textNotice: &'static [u8; 11usize] = b"textNotice\0";
pub const NID_textNotice: u32 = 293;
pub const SN_server_auth: &'static [u8; 11usize] = b"serverAuth\0";
pub const LN_server_auth: &'static [u8; 30usize] = b"TLS Web Server Authentication\0";
pub const NID_server_auth: u32 = 129;
pub const SN_client_auth: &'static [u8; 11usize] = b"clientAuth\0";
pub const LN_client_auth: &'static [u8; 30usize] = b"TLS Web Client Authentication\0";
pub const NID_client_auth: u32 = 130;
pub const SN_code_sign: &'static [u8; 12usize] = b"codeSigning\0";
pub const LN_code_sign: &'static [u8; 13usize] = b"Code Signing\0";
pub const NID_code_sign: u32 = 131;
pub const SN_email_protect: &'static [u8; 16usize] = b"emailProtection\0";
pub const LN_email_protect: &'static [u8; 18usize] = b"E-mail Protection\0";
pub const NID_email_protect: u32 = 132;
pub const SN_ipsecEndSystem: &'static [u8; 15usize] = b"ipsecEndSystem\0";
pub const LN_ipsecEndSystem: &'static [u8; 17usize] = b"IPSec End System\0";
pub const NID_ipsecEndSystem: u32 = 294;
pub const SN_ipsecTunnel: &'static [u8; 12usize] = b"ipsecTunnel\0";
pub const LN_ipsecTunnel: &'static [u8; 13usize] = b"IPSec Tunnel\0";
pub const NID_ipsecTunnel: u32 = 295;
pub const SN_ipsecUser: &'static [u8; 10usize] = b"ipsecUser\0";
pub const LN_ipsecUser: &'static [u8; 11usize] = b"IPSec User\0";
pub const NID_ipsecUser: u32 = 296;
pub const SN_time_stamp: &'static [u8; 13usize] = b"timeStamping\0";
pub const LN_time_stamp: &'static [u8; 14usize] = b"Time Stamping\0";
pub const NID_time_stamp: u32 = 133;
pub const SN_OCSP_sign: &'static [u8; 12usize] = b"OCSPSigning\0";
pub const LN_OCSP_sign: &'static [u8; 13usize] = b"OCSP Signing\0";
pub const NID_OCSP_sign: u32 = 180;
pub const SN_dvcs: &'static [u8; 5usize] = b"DVCS\0";
pub const LN_dvcs: &'static [u8; 5usize] = b"dvcs\0";
pub const NID_dvcs: u32 = 297;
pub const SN_id_it_caProtEncCert: &'static [u8; 20usize] = b"id-it-caProtEncCert\0";
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const SN_id_it_signKeyPairTypes: &'static [u8; 23usize] = b"id-it-signKeyPairTypes\0";
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const SN_id_it_encKeyPairTypes: &'static [u8; 22usize] = b"id-it-encKeyPairTypes\0";
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const SN_id_it_preferredSymmAlg: &'static [u8; 23usize] = b"id-it-preferredSymmAlg\0";
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const SN_id_it_caKeyUpdateInfo: &'static [u8; 22usize] = b"id-it-caKeyUpdateInfo\0";
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const SN_id_it_currentCRL: &'static [u8; 17usize] = b"id-it-currentCRL\0";
pub const NID_id_it_currentCRL: u32 = 303;
pub const SN_id_it_unsupportedOIDs: &'static [u8; 22usize] = b"id-it-unsupportedOIDs\0";
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const SN_id_it_subscriptionRequest: &'static [u8; 26usize] = b"id-it-subscriptionRequest\0";
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const SN_id_it_subscriptionResponse: &'static [u8; 27usize] = b"id-it-subscriptionResponse\0";
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const SN_id_it_keyPairParamReq: &'static [u8; 22usize] = b"id-it-keyPairParamReq\0";
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const SN_id_it_keyPairParamRep: &'static [u8; 22usize] = b"id-it-keyPairParamRep\0";
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const SN_id_it_revPassphrase: &'static [u8; 20usize] = b"id-it-revPassphrase\0";
pub const NID_id_it_revPassphrase: u32 = 309;
pub const SN_id_it_implicitConfirm: &'static [u8; 22usize] = b"id-it-implicitConfirm\0";
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const SN_id_it_confirmWaitTime: &'static [u8; 22usize] = b"id-it-confirmWaitTime\0";
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const SN_id_it_origPKIMessage: &'static [u8; 21usize] = b"id-it-origPKIMessage\0";
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const SN_id_it_suppLangTags: &'static [u8; 19usize] = b"id-it-suppLangTags\0";
pub const NID_id_it_suppLangTags: u32 = 784;
pub const SN_id_regCtrl: &'static [u8; 11usize] = b"id-regCtrl\0";
pub const NID_id_regCtrl: u32 = 313;
pub const SN_id_regInfo: &'static [u8; 11usize] = b"id-regInfo\0";
pub const NID_id_regInfo: u32 = 314;
pub const SN_id_regCtrl_regToken: &'static [u8; 20usize] = b"id-regCtrl-regToken\0";
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const SN_id_regCtrl_authenticator: &'static [u8; 25usize] = b"id-regCtrl-authenticator\0";
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const SN_id_regCtrl_pkiPublicationInfo: &'static [u8; 30usize] =
    b"id-regCtrl-pkiPublicationInfo\0";
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const SN_id_regCtrl_pkiArchiveOptions: &'static [u8; 29usize] =
    b"id-regCtrl-pkiArchiveOptions\0";
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const SN_id_regCtrl_oldCertID: &'static [u8; 21usize] = b"id-regCtrl-oldCertID\0";
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const SN_id_regCtrl_protocolEncrKey: &'static [u8; 27usize] = b"id-regCtrl-protocolEncrKey\0";
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const SN_id_regInfo_utf8Pairs: &'static [u8; 21usize] = b"id-regInfo-utf8Pairs\0";
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const SN_id_regInfo_certReq: &'static [u8; 19usize] = b"id-regInfo-certReq\0";
pub const NID_id_regInfo_certReq: u32 = 322;
pub const SN_id_alg_des40: &'static [u8; 13usize] = b"id-alg-des40\0";
pub const NID_id_alg_des40: u32 = 323;
pub const SN_id_alg_noSignature: &'static [u8; 19usize] = b"id-alg-noSignature\0";
pub const NID_id_alg_noSignature: u32 = 324;
pub const SN_id_alg_dh_sig_hmac_sha1: &'static [u8; 24usize] = b"id-alg-dh-sig-hmac-sha1\0";
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const SN_id_alg_dh_pop: &'static [u8; 14usize] = b"id-alg-dh-pop\0";
pub const NID_id_alg_dh_pop: u32 = 326;
pub const SN_id_cmc_statusInfo: &'static [u8; 18usize] = b"id-cmc-statusInfo\0";
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const SN_id_cmc_identification: &'static [u8; 22usize] = b"id-cmc-identification\0";
pub const NID_id_cmc_identification: u32 = 328;
pub const SN_id_cmc_identityProof: &'static [u8; 21usize] = b"id-cmc-identityProof\0";
pub const NID_id_cmc_identityProof: u32 = 329;
pub const SN_id_cmc_dataReturn: &'static [u8; 18usize] = b"id-cmc-dataReturn\0";
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const SN_id_cmc_transactionId: &'static [u8; 21usize] = b"id-cmc-transactionId\0";
pub const NID_id_cmc_transactionId: u32 = 331;
pub const SN_id_cmc_senderNonce: &'static [u8; 19usize] = b"id-cmc-senderNonce\0";
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const SN_id_cmc_recipientNonce: &'static [u8; 22usize] = b"id-cmc-recipientNonce\0";
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const SN_id_cmc_addExtensions: &'static [u8; 21usize] = b"id-cmc-addExtensions\0";
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const SN_id_cmc_encryptedPOP: &'static [u8; 20usize] = b"id-cmc-encryptedPOP\0";
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const SN_id_cmc_decryptedPOP: &'static [u8; 20usize] = b"id-cmc-decryptedPOP\0";
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const SN_id_cmc_lraPOPWitness: &'static [u8; 21usize] = b"id-cmc-lraPOPWitness\0";
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const SN_id_cmc_getCert: &'static [u8; 15usize] = b"id-cmc-getCert\0";
pub const NID_id_cmc_getCert: u32 = 338;
pub const SN_id_cmc_getCRL: &'static [u8; 14usize] = b"id-cmc-getCRL\0";
pub const NID_id_cmc_getCRL: u32 = 339;
pub const SN_id_cmc_revokeRequest: &'static [u8; 21usize] = b"id-cmc-revokeRequest\0";
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const SN_id_cmc_regInfo: &'static [u8; 15usize] = b"id-cmc-regInfo\0";
pub const NID_id_cmc_regInfo: u32 = 341;
pub const SN_id_cmc_responseInfo: &'static [u8; 20usize] = b"id-cmc-responseInfo\0";
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const SN_id_cmc_queryPending: &'static [u8; 20usize] = b"id-cmc-queryPending\0";
pub const NID_id_cmc_queryPending: u32 = 343;
pub const SN_id_cmc_popLinkRandom: &'static [u8; 21usize] = b"id-cmc-popLinkRandom\0";
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const SN_id_cmc_popLinkWitness: &'static [u8; 22usize] = b"id-cmc-popLinkWitness\0";
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const SN_id_cmc_confirmCertAcceptance: &'static [u8; 29usize] =
    b"id-cmc-confirmCertAcceptance\0";
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const SN_id_on_personalData: &'static [u8; 19usize] = b"id-on-personalData\0";
pub const NID_id_on_personalData: u32 = 347;
pub const SN_id_on_permanentIdentifier: &'static [u8; 26usize] = b"id-on-permanentIdentifier\0";
pub const LN_id_on_permanentIdentifier: &'static [u8; 21usize] = b"Permanent Identifier\0";
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const SN_id_pda_dateOfBirth: &'static [u8; 19usize] = b"id-pda-dateOfBirth\0";
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const SN_id_pda_placeOfBirth: &'static [u8; 20usize] = b"id-pda-placeOfBirth\0";
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const SN_id_pda_gender: &'static [u8; 14usize] = b"id-pda-gender\0";
pub const NID_id_pda_gender: u32 = 351;
pub const SN_id_pda_countryOfCitizenship: &'static [u8; 28usize] = b"id-pda-countryOfCitizenship\0";
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const SN_id_pda_countryOfResidence: &'static [u8; 26usize] = b"id-pda-countryOfResidence\0";
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const SN_id_aca_authenticationInfo: &'static [u8; 26usize] = b"id-aca-authenticationInfo\0";
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const SN_id_aca_accessIdentity: &'static [u8; 22usize] = b"id-aca-accessIdentity\0";
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const SN_id_aca_chargingIdentity: &'static [u8; 24usize] = b"id-aca-chargingIdentity\0";
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const SN_id_aca_group: &'static [u8; 13usize] = b"id-aca-group\0";
pub const NID_id_aca_group: u32 = 357;
pub const SN_id_aca_role: &'static [u8; 12usize] = b"id-aca-role\0";
pub const NID_id_aca_role: u32 = 358;
pub const SN_id_aca_encAttrs: &'static [u8; 16usize] = b"id-aca-encAttrs\0";
pub const NID_id_aca_encAttrs: u32 = 399;
pub const SN_id_qcs_pkixQCSyntax_v1: &'static [u8; 23usize] = b"id-qcs-pkixQCSyntax-v1\0";
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const SN_id_cct_crs: &'static [u8; 11usize] = b"id-cct-crs\0";
pub const NID_id_cct_crs: u32 = 360;
pub const SN_id_cct_PKIData: &'static [u8; 15usize] = b"id-cct-PKIData\0";
pub const NID_id_cct_PKIData: u32 = 361;
pub const SN_id_cct_PKIResponse: &'static [u8; 19usize] = b"id-cct-PKIResponse\0";
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const SN_id_ppl_anyLanguage: &'static [u8; 19usize] = b"id-ppl-anyLanguage\0";
pub const LN_id_ppl_anyLanguage: &'static [u8; 13usize] = b"Any language\0";
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const SN_id_ppl_inheritAll: &'static [u8; 18usize] = b"id-ppl-inheritAll\0";
pub const LN_id_ppl_inheritAll: &'static [u8; 12usize] = b"Inherit all\0";
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const SN_Independent: &'static [u8; 19usize] = b"id-ppl-independent\0";
pub const LN_Independent: &'static [u8; 12usize] = b"Independent\0";
pub const NID_Independent: u32 = 667;
pub const SN_ad_OCSP: &'static [u8; 5usize] = b"OCSP\0";
pub const LN_ad_OCSP: &'static [u8; 5usize] = b"OCSP\0";
pub const NID_ad_OCSP: u32 = 178;
pub const SN_ad_ca_issuers: &'static [u8; 10usize] = b"caIssuers\0";
pub const LN_ad_ca_issuers: &'static [u8; 11usize] = b"CA Issuers\0";
pub const NID_ad_ca_issuers: u32 = 179;
pub const SN_ad_timeStamping: &'static [u8; 16usize] = b"ad_timestamping\0";
pub const LN_ad_timeStamping: &'static [u8; 17usize] = b"AD Time Stamping\0";
pub const NID_ad_timeStamping: u32 = 363;
pub const SN_ad_dvcs: &'static [u8; 8usize] = b"AD_DVCS\0";
pub const LN_ad_dvcs: &'static [u8; 8usize] = b"ad dvcs\0";
pub const NID_ad_dvcs: u32 = 364;
pub const SN_caRepository: &'static [u8; 13usize] = b"caRepository\0";
pub const LN_caRepository: &'static [u8; 14usize] = b"CA Repository\0";
pub const NID_caRepository: u32 = 785;
pub const SN_id_pkix_OCSP_basic: &'static [u8; 18usize] = b"basicOCSPResponse\0";
pub const LN_id_pkix_OCSP_basic: &'static [u8; 20usize] = b"Basic OCSP Response\0";
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const SN_id_pkix_OCSP_Nonce: &'static [u8; 6usize] = b"Nonce\0";
pub const LN_id_pkix_OCSP_Nonce: &'static [u8; 11usize] = b"OCSP Nonce\0";
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const SN_id_pkix_OCSP_CrlID: &'static [u8; 6usize] = b"CrlID\0";
pub const LN_id_pkix_OCSP_CrlID: &'static [u8; 12usize] = b"OCSP CRL ID\0";
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const SN_id_pkix_OCSP_acceptableResponses: &'static [u8; 20usize] = b"acceptableResponses\0";
pub const LN_id_pkix_OCSP_acceptableResponses: &'static [u8; 26usize] =
    b"Acceptable OCSP Responses\0";
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const SN_id_pkix_OCSP_noCheck: &'static [u8; 8usize] = b"noCheck\0";
pub const LN_id_pkix_OCSP_noCheck: &'static [u8; 14usize] = b"OCSP No Check\0";
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const SN_id_pkix_OCSP_archiveCutoff: &'static [u8; 14usize] = b"archiveCutoff\0";
pub const LN_id_pkix_OCSP_archiveCutoff: &'static [u8; 20usize] = b"OCSP Archive Cutoff\0";
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const SN_id_pkix_OCSP_serviceLocator: &'static [u8; 15usize] = b"serviceLocator\0";
pub const LN_id_pkix_OCSP_serviceLocator: &'static [u8; 21usize] = b"OCSP Service Locator\0";
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const SN_id_pkix_OCSP_extendedStatus: &'static [u8; 15usize] = b"extendedStatus\0";
pub const LN_id_pkix_OCSP_extendedStatus: &'static [u8; 21usize] = b"Extended OCSP Status\0";
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const SN_id_pkix_OCSP_valid: &'static [u8; 6usize] = b"valid\0";
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const SN_id_pkix_OCSP_path: &'static [u8; 5usize] = b"path\0";
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const SN_id_pkix_OCSP_trustRoot: &'static [u8; 10usize] = b"trustRoot\0";
pub const LN_id_pkix_OCSP_trustRoot: &'static [u8; 11usize] = b"Trust Root\0";
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const SN_algorithm: &'static [u8; 10usize] = b"algorithm\0";
pub const LN_algorithm: &'static [u8; 10usize] = b"algorithm\0";
pub const NID_algorithm: u32 = 376;
pub const SN_md5WithRSA: &'static [u8; 11usize] = b"RSA-NP-MD5\0";
pub const LN_md5WithRSA: &'static [u8; 11usize] = b"md5WithRSA\0";
pub const NID_md5WithRSA: u32 = 104;
pub const SN_des_ecb: &'static [u8; 8usize] = b"DES-ECB\0";
pub const LN_des_ecb: &'static [u8; 8usize] = b"des-ecb\0";
pub const NID_des_ecb: u32 = 29;
pub const SN_des_cbc: &'static [u8; 8usize] = b"DES-CBC\0";
pub const LN_des_cbc: &'static [u8; 8usize] = b"des-cbc\0";
pub const NID_des_cbc: u32 = 31;
pub const SN_des_ofb64: &'static [u8; 8usize] = b"DES-OFB\0";
pub const LN_des_ofb64: &'static [u8; 8usize] = b"des-ofb\0";
pub const NID_des_ofb64: u32 = 45;
pub const SN_des_cfb64: &'static [u8; 8usize] = b"DES-CFB\0";
pub const LN_des_cfb64: &'static [u8; 8usize] = b"des-cfb\0";
pub const NID_des_cfb64: u32 = 30;
pub const SN_rsaSignature: &'static [u8; 13usize] = b"rsaSignature\0";
pub const NID_rsaSignature: u32 = 377;
pub const SN_dsa_2: &'static [u8; 8usize] = b"DSA-old\0";
pub const LN_dsa_2: &'static [u8; 18usize] = b"dsaEncryption-old\0";
pub const NID_dsa_2: u32 = 67;
pub const SN_dsaWithSHA: &'static [u8; 8usize] = b"DSA-SHA\0";
pub const LN_dsaWithSHA: &'static [u8; 11usize] = b"dsaWithSHA\0";
pub const NID_dsaWithSHA: u32 = 66;
pub const SN_shaWithRSAEncryption: &'static [u8; 8usize] = b"RSA-SHA\0";
pub const LN_shaWithRSAEncryption: &'static [u8; 21usize] = b"shaWithRSAEncryption\0";
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const SN_des_ede_ecb: &'static [u8; 8usize] = b"DES-EDE\0";
pub const LN_des_ede_ecb: &'static [u8; 8usize] = b"des-ede\0";
pub const NID_des_ede_ecb: u32 = 32;
pub const SN_des_ede3_ecb: &'static [u8; 9usize] = b"DES-EDE3\0";
pub const LN_des_ede3_ecb: &'static [u8; 9usize] = b"des-ede3\0";
pub const NID_des_ede3_ecb: u32 = 33;
pub const SN_des_ede_cbc: &'static [u8; 12usize] = b"DES-EDE-CBC\0";
pub const LN_des_ede_cbc: &'static [u8; 12usize] = b"des-ede-cbc\0";
pub const NID_des_ede_cbc: u32 = 43;
pub const SN_des_ede_cfb64: &'static [u8; 12usize] = b"DES-EDE-CFB\0";
pub const LN_des_ede_cfb64: &'static [u8; 12usize] = b"des-ede-cfb\0";
pub const NID_des_ede_cfb64: u32 = 60;
pub const SN_des_ede3_cfb64: &'static [u8; 13usize] = b"DES-EDE3-CFB\0";
pub const LN_des_ede3_cfb64: &'static [u8; 13usize] = b"des-ede3-cfb\0";
pub const NID_des_ede3_cfb64: u32 = 61;
pub const SN_des_ede_ofb64: &'static [u8; 12usize] = b"DES-EDE-OFB\0";
pub const LN_des_ede_ofb64: &'static [u8; 12usize] = b"des-ede-ofb\0";
pub const NID_des_ede_ofb64: u32 = 62;
pub const SN_des_ede3_ofb64: &'static [u8; 13usize] = b"DES-EDE3-OFB\0";
pub const LN_des_ede3_ofb64: &'static [u8; 13usize] = b"des-ede3-ofb\0";
pub const NID_des_ede3_ofb64: u32 = 63;
pub const SN_desx_cbc: &'static [u8; 9usize] = b"DESX-CBC\0";
pub const LN_desx_cbc: &'static [u8; 9usize] = b"desx-cbc\0";
pub const NID_desx_cbc: u32 = 80;
pub const SN_sha: &'static [u8; 4usize] = b"SHA\0";
pub const LN_sha: &'static [u8; 4usize] = b"sha\0";
pub const NID_sha: u32 = 41;
pub const SN_sha1: &'static [u8; 5usize] = b"SHA1\0";
pub const LN_sha1: &'static [u8; 5usize] = b"sha1\0";
pub const NID_sha1: u32 = 64;
pub const SN_dsaWithSHA1_2: &'static [u8; 13usize] = b"DSA-SHA1-old\0";
pub const LN_dsaWithSHA1_2: &'static [u8; 16usize] = b"dsaWithSHA1-old\0";
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const SN_sha1WithRSA: &'static [u8; 11usize] = b"RSA-SHA1-2\0";
pub const LN_sha1WithRSA: &'static [u8; 12usize] = b"sha1WithRSA\0";
pub const NID_sha1WithRSA: u32 = 115;
pub const SN_ripemd160: &'static [u8; 10usize] = b"RIPEMD160\0";
pub const LN_ripemd160: &'static [u8; 10usize] = b"ripemd160\0";
pub const NID_ripemd160: u32 = 117;
pub const SN_ripemd160WithRSA: &'static [u8; 14usize] = b"RSA-RIPEMD160\0";
pub const LN_ripemd160WithRSA: &'static [u8; 17usize] = b"ripemd160WithRSA\0";
pub const NID_ripemd160WithRSA: u32 = 119;
pub const SN_sxnet: &'static [u8; 8usize] = b"SXNetID\0";
pub const LN_sxnet: &'static [u8; 19usize] = b"Strong Extranet ID\0";
pub const NID_sxnet: u32 = 143;
pub const SN_X500: &'static [u8; 5usize] = b"X500\0";
pub const LN_X500: &'static [u8; 27usize] = b"directory services (X.500)\0";
pub const NID_X500: u32 = 11;
pub const SN_X509: &'static [u8; 5usize] = b"X509\0";
pub const NID_X509: u32 = 12;
pub const SN_commonName: &'static [u8; 3usize] = b"CN\0";
pub const LN_commonName: &'static [u8; 11usize] = b"commonName\0";
pub const NID_commonName: u32 = 13;
pub const SN_surname: &'static [u8; 3usize] = b"SN\0";
pub const LN_surname: &'static [u8; 8usize] = b"surname\0";
pub const NID_surname: u32 = 100;
pub const LN_serialNumber: &'static [u8; 13usize] = b"serialNumber\0";
pub const NID_serialNumber: u32 = 105;
pub const SN_countryName: &'static [u8; 2usize] = b"C\0";
pub const LN_countryName: &'static [u8; 12usize] = b"countryName\0";
pub const NID_countryName: u32 = 14;
pub const SN_localityName: &'static [u8; 2usize] = b"L\0";
pub const LN_localityName: &'static [u8; 13usize] = b"localityName\0";
pub const NID_localityName: u32 = 15;
pub const SN_stateOrProvinceName: &'static [u8; 3usize] = b"ST\0";
pub const LN_stateOrProvinceName: &'static [u8; 20usize] = b"stateOrProvinceName\0";
pub const NID_stateOrProvinceName: u32 = 16;
pub const SN_streetAddress: &'static [u8; 7usize] = b"street\0";
pub const LN_streetAddress: &'static [u8; 14usize] = b"streetAddress\0";
pub const NID_streetAddress: u32 = 660;
pub const SN_organizationName: &'static [u8; 2usize] = b"O\0";
pub const LN_organizationName: &'static [u8; 17usize] = b"organizationName\0";
pub const NID_organizationName: u32 = 17;
pub const SN_organizationalUnitName: &'static [u8; 3usize] = b"OU\0";
pub const LN_organizationalUnitName: &'static [u8; 23usize] = b"organizationalUnitName\0";
pub const NID_organizationalUnitName: u32 = 18;
pub const SN_title: &'static [u8; 6usize] = b"title\0";
pub const LN_title: &'static [u8; 6usize] = b"title\0";
pub const NID_title: u32 = 106;
pub const LN_description: &'static [u8; 12usize] = b"description\0";
pub const NID_description: u32 = 107;
pub const LN_searchGuide: &'static [u8; 12usize] = b"searchGuide\0";
pub const NID_searchGuide: u32 = 859;
pub const LN_businessCategory: &'static [u8; 17usize] = b"businessCategory\0";
pub const NID_businessCategory: u32 = 860;
pub const LN_postalAddress: &'static [u8; 14usize] = b"postalAddress\0";
pub const NID_postalAddress: u32 = 861;
pub const LN_postalCode: &'static [u8; 11usize] = b"postalCode\0";
pub const NID_postalCode: u32 = 661;
pub const LN_postOfficeBox: &'static [u8; 14usize] = b"postOfficeBox\0";
pub const NID_postOfficeBox: u32 = 862;
pub const LN_physicalDeliveryOfficeName: &'static [u8; 27usize] = b"physicalDeliveryOfficeName\0";
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const LN_telephoneNumber: &'static [u8; 16usize] = b"telephoneNumber\0";
pub const NID_telephoneNumber: u32 = 864;
pub const LN_telexNumber: &'static [u8; 12usize] = b"telexNumber\0";
pub const NID_telexNumber: u32 = 865;
pub const LN_teletexTerminalIdentifier: &'static [u8; 26usize] = b"teletexTerminalIdentifier\0";
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const LN_facsimileTelephoneNumber: &'static [u8; 25usize] = b"facsimileTelephoneNumber\0";
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const LN_x121Address: &'static [u8; 12usize] = b"x121Address\0";
pub const NID_x121Address: u32 = 868;
pub const LN_internationaliSDNNumber: &'static [u8; 24usize] = b"internationaliSDNNumber\0";
pub const NID_internationaliSDNNumber: u32 = 869;
pub const LN_registeredAddress: &'static [u8; 18usize] = b"registeredAddress\0";
pub const NID_registeredAddress: u32 = 870;
pub const LN_destinationIndicator: &'static [u8; 21usize] = b"destinationIndicator\0";
pub const NID_destinationIndicator: u32 = 871;
pub const LN_preferredDeliveryMethod: &'static [u8; 24usize] = b"preferredDeliveryMethod\0";
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const LN_presentationAddress: &'static [u8; 20usize] = b"presentationAddress\0";
pub const NID_presentationAddress: u32 = 873;
pub const LN_supportedApplicationContext: &'static [u8; 28usize] = b"supportedApplicationContext\0";
pub const NID_supportedApplicationContext: u32 = 874;
pub const SN_member: &'static [u8; 7usize] = b"member\0";
pub const NID_member: u32 = 875;
pub const SN_owner: &'static [u8; 6usize] = b"owner\0";
pub const NID_owner: u32 = 876;
pub const LN_roleOccupant: &'static [u8; 13usize] = b"roleOccupant\0";
pub const NID_roleOccupant: u32 = 877;
pub const SN_seeAlso: &'static [u8; 8usize] = b"seeAlso\0";
pub const NID_seeAlso: u32 = 878;
pub const LN_userPassword: &'static [u8; 13usize] = b"userPassword\0";
pub const NID_userPassword: u32 = 879;
pub const LN_userCertificate: &'static [u8; 16usize] = b"userCertificate\0";
pub const NID_userCertificate: u32 = 880;
pub const LN_cACertificate: &'static [u8; 14usize] = b"cACertificate\0";
pub const NID_cACertificate: u32 = 881;
pub const LN_authorityRevocationList: &'static [u8; 24usize] = b"authorityRevocationList\0";
pub const NID_authorityRevocationList: u32 = 882;
pub const LN_certificateRevocationList: &'static [u8; 26usize] = b"certificateRevocationList\0";
pub const NID_certificateRevocationList: u32 = 883;
pub const LN_crossCertificatePair: &'static [u8; 21usize] = b"crossCertificatePair\0";
pub const NID_crossCertificatePair: u32 = 884;
pub const SN_name: &'static [u8; 5usize] = b"name\0";
pub const LN_name: &'static [u8; 5usize] = b"name\0";
pub const NID_name: u32 = 173;
pub const SN_givenName: &'static [u8; 3usize] = b"GN\0";
pub const LN_givenName: &'static [u8; 10usize] = b"givenName\0";
pub const NID_givenName: u32 = 99;
pub const SN_initials: &'static [u8; 9usize] = b"initials\0";
pub const LN_initials: &'static [u8; 9usize] = b"initials\0";
pub const NID_initials: u32 = 101;
pub const LN_generationQualifier: &'static [u8; 20usize] = b"generationQualifier\0";
pub const NID_generationQualifier: u32 = 509;
pub const LN_x500UniqueIdentifier: &'static [u8; 21usize] = b"x500UniqueIdentifier\0";
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const SN_dnQualifier: &'static [u8; 12usize] = b"dnQualifier\0";
pub const LN_dnQualifier: &'static [u8; 12usize] = b"dnQualifier\0";
pub const NID_dnQualifier: u32 = 174;
pub const LN_enhancedSearchGuide: &'static [u8; 20usize] = b"enhancedSearchGuide\0";
pub const NID_enhancedSearchGuide: u32 = 885;
pub const LN_protocolInformation: &'static [u8; 20usize] = b"protocolInformation\0";
pub const NID_protocolInformation: u32 = 886;
pub const LN_distinguishedName: &'static [u8; 18usize] = b"distinguishedName\0";
pub const NID_distinguishedName: u32 = 887;
pub const LN_uniqueMember: &'static [u8; 13usize] = b"uniqueMember\0";
pub const NID_uniqueMember: u32 = 888;
pub const LN_houseIdentifier: &'static [u8; 16usize] = b"houseIdentifier\0";
pub const NID_houseIdentifier: u32 = 889;
pub const LN_supportedAlgorithms: &'static [u8; 20usize] = b"supportedAlgorithms\0";
pub const NID_supportedAlgorithms: u32 = 890;
pub const LN_deltaRevocationList: &'static [u8; 20usize] = b"deltaRevocationList\0";
pub const NID_deltaRevocationList: u32 = 891;
pub const SN_dmdName: &'static [u8; 8usize] = b"dmdName\0";
pub const NID_dmdName: u32 = 892;
pub const LN_pseudonym: &'static [u8; 10usize] = b"pseudonym\0";
pub const NID_pseudonym: u32 = 510;
pub const SN_role: &'static [u8; 5usize] = b"role\0";
pub const LN_role: &'static [u8; 5usize] = b"role\0";
pub const NID_role: u32 = 400;
pub const SN_X500algorithms: &'static [u8; 15usize] = b"X500algorithms\0";
pub const LN_X500algorithms: &'static [u8; 32usize] = b"directory services - algorithms\0";
pub const NID_X500algorithms: u32 = 378;
pub const SN_rsa: &'static [u8; 4usize] = b"RSA\0";
pub const LN_rsa: &'static [u8; 4usize] = b"rsa\0";
pub const NID_rsa: u32 = 19;
pub const SN_mdc2WithRSA: &'static [u8; 9usize] = b"RSA-MDC2\0";
pub const LN_mdc2WithRSA: &'static [u8; 12usize] = b"mdc2WithRSA\0";
pub const NID_mdc2WithRSA: u32 = 96;
pub const SN_mdc2: &'static [u8; 5usize] = b"MDC2\0";
pub const LN_mdc2: &'static [u8; 5usize] = b"mdc2\0";
pub const NID_mdc2: u32 = 95;
pub const SN_id_ce: &'static [u8; 6usize] = b"id-ce\0";
pub const NID_id_ce: u32 = 81;
pub const SN_subject_directory_attributes: &'static [u8; 27usize] = b"subjectDirectoryAttributes\0";
pub const LN_subject_directory_attributes: &'static [u8; 36usize] =
    b"X509v3 Subject Directory Attributes\0";
pub const NID_subject_directory_attributes: u32 = 769;
pub const SN_subject_key_identifier: &'static [u8; 21usize] = b"subjectKeyIdentifier\0";
pub const LN_subject_key_identifier: &'static [u8; 30usize] = b"X509v3 Subject Key Identifier\0";
pub const NID_subject_key_identifier: u32 = 82;
pub const SN_key_usage: &'static [u8; 9usize] = b"keyUsage\0";
pub const LN_key_usage: &'static [u8; 17usize] = b"X509v3 Key Usage\0";
pub const NID_key_usage: u32 = 83;
pub const SN_private_key_usage_period: &'static [u8; 22usize] = b"privateKeyUsagePeriod\0";
pub const LN_private_key_usage_period: &'static [u8; 32usize] =
    b"X509v3 Private Key Usage Period\0";
pub const NID_private_key_usage_period: u32 = 84;
pub const SN_subject_alt_name: &'static [u8; 15usize] = b"subjectAltName\0";
pub const LN_subject_alt_name: &'static [u8; 32usize] = b"X509v3 Subject Alternative Name\0";
pub const NID_subject_alt_name: u32 = 85;
pub const SN_issuer_alt_name: &'static [u8; 14usize] = b"issuerAltName\0";
pub const LN_issuer_alt_name: &'static [u8; 31usize] = b"X509v3 Issuer Alternative Name\0";
pub const NID_issuer_alt_name: u32 = 86;
pub const SN_basic_constraints: &'static [u8; 17usize] = b"basicConstraints\0";
pub const LN_basic_constraints: &'static [u8; 25usize] = b"X509v3 Basic Constraints\0";
pub const NID_basic_constraints: u32 = 87;
pub const SN_crl_number: &'static [u8; 10usize] = b"crlNumber\0";
pub const LN_crl_number: &'static [u8; 18usize] = b"X509v3 CRL Number\0";
pub const NID_crl_number: u32 = 88;
pub const SN_crl_reason: &'static [u8; 10usize] = b"CRLReason\0";
pub const LN_crl_reason: &'static [u8; 23usize] = b"X509v3 CRL Reason Code\0";
pub const NID_crl_reason: u32 = 141;
pub const SN_invalidity_date: &'static [u8; 15usize] = b"invalidityDate\0";
pub const LN_invalidity_date: &'static [u8; 16usize] = b"Invalidity Date\0";
pub const NID_invalidity_date: u32 = 142;
pub const SN_delta_crl: &'static [u8; 9usize] = b"deltaCRL\0";
pub const LN_delta_crl: &'static [u8; 27usize] = b"X509v3 Delta CRL Indicator\0";
pub const NID_delta_crl: u32 = 140;
pub const SN_issuing_distribution_point: &'static [u8; 25usize] = b"issuingDistributionPoint\0";
pub const LN_issuing_distribution_point: &'static [u8; 34usize] =
    b"X509v3 Issuing Distrubution Point\0";
pub const NID_issuing_distribution_point: u32 = 770;
pub const SN_certificate_issuer: &'static [u8; 18usize] = b"certificateIssuer\0";
pub const LN_certificate_issuer: &'static [u8; 26usize] = b"X509v3 Certificate Issuer\0";
pub const NID_certificate_issuer: u32 = 771;
pub const SN_name_constraints: &'static [u8; 16usize] = b"nameConstraints\0";
pub const LN_name_constraints: &'static [u8; 24usize] = b"X509v3 Name Constraints\0";
pub const NID_name_constraints: u32 = 666;
pub const SN_crl_distribution_points: &'static [u8; 22usize] = b"crlDistributionPoints\0";
pub const LN_crl_distribution_points: &'static [u8; 31usize] = b"X509v3 CRL Distribution Points\0";
pub const NID_crl_distribution_points: u32 = 103;
pub const SN_certificate_policies: &'static [u8; 20usize] = b"certificatePolicies\0";
pub const LN_certificate_policies: &'static [u8; 28usize] = b"X509v3 Certificate Policies\0";
pub const NID_certificate_policies: u32 = 89;
pub const SN_any_policy: &'static [u8; 10usize] = b"anyPolicy\0";
pub const LN_any_policy: &'static [u8; 18usize] = b"X509v3 Any Policy\0";
pub const NID_any_policy: u32 = 746;
pub const SN_policy_mappings: &'static [u8; 15usize] = b"policyMappings\0";
pub const LN_policy_mappings: &'static [u8; 23usize] = b"X509v3 Policy Mappings\0";
pub const NID_policy_mappings: u32 = 747;
pub const SN_authority_key_identifier: &'static [u8; 23usize] = b"authorityKeyIdentifier\0";
pub const LN_authority_key_identifier: &'static [u8; 32usize] =
    b"X509v3 Authority Key Identifier\0";
pub const NID_authority_key_identifier: u32 = 90;
pub const SN_policy_constraints: &'static [u8; 18usize] = b"policyConstraints\0";
pub const LN_policy_constraints: &'static [u8; 26usize] = b"X509v3 Policy Constraints\0";
pub const NID_policy_constraints: u32 = 401;
pub const SN_ext_key_usage: &'static [u8; 17usize] = b"extendedKeyUsage\0";
pub const LN_ext_key_usage: &'static [u8; 26usize] = b"X509v3 Extended Key Usage\0";
pub const NID_ext_key_usage: u32 = 126;
pub const SN_freshest_crl: &'static [u8; 12usize] = b"freshestCRL\0";
pub const LN_freshest_crl: &'static [u8; 20usize] = b"X509v3 Freshest CRL\0";
pub const NID_freshest_crl: u32 = 857;
pub const SN_inhibit_any_policy: &'static [u8; 17usize] = b"inhibitAnyPolicy\0";
pub const LN_inhibit_any_policy: &'static [u8; 26usize] = b"X509v3 Inhibit Any Policy\0";
pub const NID_inhibit_any_policy: u32 = 748;
pub const SN_target_information: &'static [u8; 18usize] = b"targetInformation\0";
pub const LN_target_information: &'static [u8; 20usize] = b"X509v3 AC Targeting\0";
pub const NID_target_information: u32 = 402;
pub const SN_no_rev_avail: &'static [u8; 11usize] = b"noRevAvail\0";
pub const LN_no_rev_avail: &'static [u8; 31usize] = b"X509v3 No Revocation Available\0";
pub const NID_no_rev_avail: u32 = 403;
pub const SN_anyExtendedKeyUsage: &'static [u8; 20usize] = b"anyExtendedKeyUsage\0";
pub const LN_anyExtendedKeyUsage: &'static [u8; 23usize] = b"Any Extended Key Usage\0";
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const SN_netscape: &'static [u8; 9usize] = b"Netscape\0";
pub const LN_netscape: &'static [u8; 30usize] = b"Netscape Communications Corp.\0";
pub const NID_netscape: u32 = 57;
pub const SN_netscape_cert_extension: &'static [u8; 10usize] = b"nsCertExt\0";
pub const LN_netscape_cert_extension: &'static [u8; 31usize] = b"Netscape Certificate Extension\0";
pub const NID_netscape_cert_extension: u32 = 58;
pub const SN_netscape_data_type: &'static [u8; 11usize] = b"nsDataType\0";
pub const LN_netscape_data_type: &'static [u8; 19usize] = b"Netscape Data Type\0";
pub const NID_netscape_data_type: u32 = 59;
pub const SN_netscape_cert_type: &'static [u8; 11usize] = b"nsCertType\0";
pub const LN_netscape_cert_type: &'static [u8; 19usize] = b"Netscape Cert Type\0";
pub const NID_netscape_cert_type: u32 = 71;
pub const SN_netscape_base_url: &'static [u8; 10usize] = b"nsBaseUrl\0";
pub const LN_netscape_base_url: &'static [u8; 18usize] = b"Netscape Base Url\0";
pub const NID_netscape_base_url: u32 = 72;
pub const SN_netscape_revocation_url: &'static [u8; 16usize] = b"nsRevocationUrl\0";
pub const LN_netscape_revocation_url: &'static [u8; 24usize] = b"Netscape Revocation Url\0";
pub const NID_netscape_revocation_url: u32 = 73;
pub const SN_netscape_ca_revocation_url: &'static [u8; 18usize] = b"nsCaRevocationUrl\0";
pub const LN_netscape_ca_revocation_url: &'static [u8; 27usize] = b"Netscape CA Revocation Url\0";
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const SN_netscape_renewal_url: &'static [u8; 13usize] = b"nsRenewalUrl\0";
pub const LN_netscape_renewal_url: &'static [u8; 21usize] = b"Netscape Renewal Url\0";
pub const NID_netscape_renewal_url: u32 = 75;
pub const SN_netscape_ca_policy_url: &'static [u8; 14usize] = b"nsCaPolicyUrl\0";
pub const LN_netscape_ca_policy_url: &'static [u8; 23usize] = b"Netscape CA Policy Url\0";
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const SN_netscape_ssl_server_name: &'static [u8; 16usize] = b"nsSslServerName\0";
pub const LN_netscape_ssl_server_name: &'static [u8; 25usize] = b"Netscape SSL Server Name\0";
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const SN_netscape_comment: &'static [u8; 10usize] = b"nsComment\0";
pub const LN_netscape_comment: &'static [u8; 17usize] = b"Netscape Comment\0";
pub const NID_netscape_comment: u32 = 78;
pub const SN_netscape_cert_sequence: &'static [u8; 15usize] = b"nsCertSequence\0";
pub const LN_netscape_cert_sequence: &'static [u8; 30usize] = b"Netscape Certificate Sequence\0";
pub const NID_netscape_cert_sequence: u32 = 79;
pub const SN_ns_sgc: &'static [u8; 6usize] = b"nsSGC\0";
pub const LN_ns_sgc: &'static [u8; 29usize] = b"Netscape Server Gated Crypto\0";
pub const NID_ns_sgc: u32 = 139;
pub const SN_org: &'static [u8; 4usize] = b"ORG\0";
pub const LN_org: &'static [u8; 4usize] = b"org\0";
pub const NID_org: u32 = 379;
pub const SN_dod: &'static [u8; 4usize] = b"DOD\0";
pub const LN_dod: &'static [u8; 4usize] = b"dod\0";
pub const NID_dod: u32 = 380;
pub const SN_iana: &'static [u8; 5usize] = b"IANA\0";
pub const LN_iana: &'static [u8; 5usize] = b"iana\0";
pub const NID_iana: u32 = 381;
pub const SN_Directory: &'static [u8; 10usize] = b"directory\0";
pub const LN_Directory: &'static [u8; 10usize] = b"Directory\0";
pub const NID_Directory: u32 = 382;
pub const SN_Management: &'static [u8; 5usize] = b"mgmt\0";
pub const LN_Management: &'static [u8; 11usize] = b"Management\0";
pub const NID_Management: u32 = 383;
pub const SN_Experimental: &'static [u8; 13usize] = b"experimental\0";
pub const LN_Experimental: &'static [u8; 13usize] = b"Experimental\0";
pub const NID_Experimental: u32 = 384;
pub const SN_Private: &'static [u8; 8usize] = b"private\0";
pub const LN_Private: &'static [u8; 8usize] = b"Private\0";
pub const NID_Private: u32 = 385;
pub const SN_Security: &'static [u8; 9usize] = b"security\0";
pub const LN_Security: &'static [u8; 9usize] = b"Security\0";
pub const NID_Security: u32 = 386;
pub const SN_SNMPv2: &'static [u8; 7usize] = b"snmpv2\0";
pub const LN_SNMPv2: &'static [u8; 7usize] = b"SNMPv2\0";
pub const NID_SNMPv2: u32 = 387;
pub const LN_Mail: &'static [u8; 5usize] = b"Mail\0";
pub const NID_Mail: u32 = 388;
pub const SN_Enterprises: &'static [u8; 12usize] = b"enterprises\0";
pub const LN_Enterprises: &'static [u8; 12usize] = b"Enterprises\0";
pub const NID_Enterprises: u32 = 389;
pub const SN_dcObject: &'static [u8; 9usize] = b"dcobject\0";
pub const LN_dcObject: &'static [u8; 9usize] = b"dcObject\0";
pub const NID_dcObject: u32 = 390;
pub const SN_mime_mhs: &'static [u8; 9usize] = b"mime-mhs\0";
pub const LN_mime_mhs: &'static [u8; 9usize] = b"MIME MHS\0";
pub const NID_mime_mhs: u32 = 504;
pub const SN_mime_mhs_headings: &'static [u8; 18usize] = b"mime-mhs-headings\0";
pub const LN_mime_mhs_headings: &'static [u8; 18usize] = b"mime-mhs-headings\0";
pub const NID_mime_mhs_headings: u32 = 505;
pub const SN_mime_mhs_bodies: &'static [u8; 16usize] = b"mime-mhs-bodies\0";
pub const LN_mime_mhs_bodies: &'static [u8; 16usize] = b"mime-mhs-bodies\0";
pub const NID_mime_mhs_bodies: u32 = 506;
pub const SN_id_hex_partial_message: &'static [u8; 23usize] = b"id-hex-partial-message\0";
pub const LN_id_hex_partial_message: &'static [u8; 23usize] = b"id-hex-partial-message\0";
pub const NID_id_hex_partial_message: u32 = 507;
pub const SN_id_hex_multipart_message: &'static [u8; 25usize] = b"id-hex-multipart-message\0";
pub const LN_id_hex_multipart_message: &'static [u8; 25usize] = b"id-hex-multipart-message\0";
pub const NID_id_hex_multipart_message: u32 = 508;
pub const SN_rle_compression: &'static [u8; 4usize] = b"RLE\0";
pub const LN_rle_compression: &'static [u8; 23usize] = b"run length compression\0";
pub const NID_rle_compression: u32 = 124;
pub const SN_zlib_compression: &'static [u8; 5usize] = b"ZLIB\0";
pub const LN_zlib_compression: &'static [u8; 17usize] = b"zlib compression\0";
pub const NID_zlib_compression: u32 = 125;
pub const SN_aes_128_ecb: &'static [u8; 12usize] = b"AES-128-ECB\0";
pub const LN_aes_128_ecb: &'static [u8; 12usize] = b"aes-128-ecb\0";
pub const NID_aes_128_ecb: u32 = 418;
pub const SN_aes_128_cbc: &'static [u8; 12usize] = b"AES-128-CBC\0";
pub const LN_aes_128_cbc: &'static [u8; 12usize] = b"aes-128-cbc\0";
pub const NID_aes_128_cbc: u32 = 419;
pub const SN_aes_128_ofb128: &'static [u8; 12usize] = b"AES-128-OFB\0";
pub const LN_aes_128_ofb128: &'static [u8; 12usize] = b"aes-128-ofb\0";
pub const NID_aes_128_ofb128: u32 = 420;
pub const SN_aes_128_cfb128: &'static [u8; 12usize] = b"AES-128-CFB\0";
pub const LN_aes_128_cfb128: &'static [u8; 12usize] = b"aes-128-cfb\0";
pub const NID_aes_128_cfb128: u32 = 421;
pub const SN_id_aes128_wrap: &'static [u8; 15usize] = b"id-aes128-wrap\0";
pub const NID_id_aes128_wrap: u32 = 788;
pub const SN_aes_128_gcm: &'static [u8; 14usize] = b"id-aes128-GCM\0";
pub const LN_aes_128_gcm: &'static [u8; 12usize] = b"aes-128-gcm\0";
pub const NID_aes_128_gcm: u32 = 895;
pub const SN_aes_128_ccm: &'static [u8; 14usize] = b"id-aes128-CCM\0";
pub const LN_aes_128_ccm: &'static [u8; 12usize] = b"aes-128-ccm\0";
pub const NID_aes_128_ccm: u32 = 896;
pub const SN_id_aes128_wrap_pad: &'static [u8; 19usize] = b"id-aes128-wrap-pad\0";
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const SN_aes_192_ecb: &'static [u8; 12usize] = b"AES-192-ECB\0";
pub const LN_aes_192_ecb: &'static [u8; 12usize] = b"aes-192-ecb\0";
pub const NID_aes_192_ecb: u32 = 422;
pub const SN_aes_192_cbc: &'static [u8; 12usize] = b"AES-192-CBC\0";
pub const LN_aes_192_cbc: &'static [u8; 12usize] = b"aes-192-cbc\0";
pub const NID_aes_192_cbc: u32 = 423;
pub const SN_aes_192_ofb128: &'static [u8; 12usize] = b"AES-192-OFB\0";
pub const LN_aes_192_ofb128: &'static [u8; 12usize] = b"aes-192-ofb\0";
pub const NID_aes_192_ofb128: u32 = 424;
pub const SN_aes_192_cfb128: &'static [u8; 12usize] = b"AES-192-CFB\0";
pub const LN_aes_192_cfb128: &'static [u8; 12usize] = b"aes-192-cfb\0";
pub const NID_aes_192_cfb128: u32 = 425;
pub const SN_id_aes192_wrap: &'static [u8; 15usize] = b"id-aes192-wrap\0";
pub const NID_id_aes192_wrap: u32 = 789;
pub const SN_aes_192_gcm: &'static [u8; 14usize] = b"id-aes192-GCM\0";
pub const LN_aes_192_gcm: &'static [u8; 12usize] = b"aes-192-gcm\0";
pub const NID_aes_192_gcm: u32 = 898;
pub const SN_aes_192_ccm: &'static [u8; 14usize] = b"id-aes192-CCM\0";
pub const LN_aes_192_ccm: &'static [u8; 12usize] = b"aes-192-ccm\0";
pub const NID_aes_192_ccm: u32 = 899;
pub const SN_id_aes192_wrap_pad: &'static [u8; 19usize] = b"id-aes192-wrap-pad\0";
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const SN_aes_256_ecb: &'static [u8; 12usize] = b"AES-256-ECB\0";
pub const LN_aes_256_ecb: &'static [u8; 12usize] = b"aes-256-ecb\0";
pub const NID_aes_256_ecb: u32 = 426;
pub const SN_aes_256_cbc: &'static [u8; 12usize] = b"AES-256-CBC\0";
pub const LN_aes_256_cbc: &'static [u8; 12usize] = b"aes-256-cbc\0";
pub const NID_aes_256_cbc: u32 = 427;
pub const SN_aes_256_ofb128: &'static [u8; 12usize] = b"AES-256-OFB\0";
pub const LN_aes_256_ofb128: &'static [u8; 12usize] = b"aes-256-ofb\0";
pub const NID_aes_256_ofb128: u32 = 428;
pub const SN_aes_256_cfb128: &'static [u8; 12usize] = b"AES-256-CFB\0";
pub const LN_aes_256_cfb128: &'static [u8; 12usize] = b"aes-256-cfb\0";
pub const NID_aes_256_cfb128: u32 = 429;
pub const SN_id_aes256_wrap: &'static [u8; 15usize] = b"id-aes256-wrap\0";
pub const NID_id_aes256_wrap: u32 = 790;
pub const SN_aes_256_gcm: &'static [u8; 14usize] = b"id-aes256-GCM\0";
pub const LN_aes_256_gcm: &'static [u8; 12usize] = b"aes-256-gcm\0";
pub const NID_aes_256_gcm: u32 = 901;
pub const SN_aes_256_ccm: &'static [u8; 14usize] = b"id-aes256-CCM\0";
pub const LN_aes_256_ccm: &'static [u8; 12usize] = b"aes-256-ccm\0";
pub const NID_aes_256_ccm: u32 = 902;
pub const SN_id_aes256_wrap_pad: &'static [u8; 19usize] = b"id-aes256-wrap-pad\0";
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const SN_aes_128_cfb1: &'static [u8; 13usize] = b"AES-128-CFB1\0";
pub const LN_aes_128_cfb1: &'static [u8; 13usize] = b"aes-128-cfb1\0";
pub const NID_aes_128_cfb1: u32 = 650;
pub const SN_aes_192_cfb1: &'static [u8; 13usize] = b"AES-192-CFB1\0";
pub const LN_aes_192_cfb1: &'static [u8; 13usize] = b"aes-192-cfb1\0";
pub const NID_aes_192_cfb1: u32 = 651;
pub const SN_aes_256_cfb1: &'static [u8; 13usize] = b"AES-256-CFB1\0";
pub const LN_aes_256_cfb1: &'static [u8; 13usize] = b"aes-256-cfb1\0";
pub const NID_aes_256_cfb1: u32 = 652;
pub const SN_aes_128_cfb8: &'static [u8; 13usize] = b"AES-128-CFB8\0";
pub const LN_aes_128_cfb8: &'static [u8; 13usize] = b"aes-128-cfb8\0";
pub const NID_aes_128_cfb8: u32 = 653;
pub const SN_aes_192_cfb8: &'static [u8; 13usize] = b"AES-192-CFB8\0";
pub const LN_aes_192_cfb8: &'static [u8; 13usize] = b"aes-192-cfb8\0";
pub const NID_aes_192_cfb8: u32 = 654;
pub const SN_aes_256_cfb8: &'static [u8; 13usize] = b"AES-256-CFB8\0";
pub const LN_aes_256_cfb8: &'static [u8; 13usize] = b"aes-256-cfb8\0";
pub const NID_aes_256_cfb8: u32 = 655;
pub const SN_aes_128_ctr: &'static [u8; 12usize] = b"AES-128-CTR\0";
pub const LN_aes_128_ctr: &'static [u8; 12usize] = b"aes-128-ctr\0";
pub const NID_aes_128_ctr: u32 = 904;
pub const SN_aes_192_ctr: &'static [u8; 12usize] = b"AES-192-CTR\0";
pub const LN_aes_192_ctr: &'static [u8; 12usize] = b"aes-192-ctr\0";
pub const NID_aes_192_ctr: u32 = 905;
pub const SN_aes_256_ctr: &'static [u8; 12usize] = b"AES-256-CTR\0";
pub const LN_aes_256_ctr: &'static [u8; 12usize] = b"aes-256-ctr\0";
pub const NID_aes_256_ctr: u32 = 906;
pub const SN_aes_128_xts: &'static [u8; 12usize] = b"AES-128-XTS\0";
pub const LN_aes_128_xts: &'static [u8; 12usize] = b"aes-128-xts\0";
pub const NID_aes_128_xts: u32 = 913;
pub const SN_aes_256_xts: &'static [u8; 12usize] = b"AES-256-XTS\0";
pub const LN_aes_256_xts: &'static [u8; 12usize] = b"aes-256-xts\0";
pub const NID_aes_256_xts: u32 = 914;
pub const SN_des_cfb1: &'static [u8; 9usize] = b"DES-CFB1\0";
pub const LN_des_cfb1: &'static [u8; 9usize] = b"des-cfb1\0";
pub const NID_des_cfb1: u32 = 656;
pub const SN_des_cfb8: &'static [u8; 9usize] = b"DES-CFB8\0";
pub const LN_des_cfb8: &'static [u8; 9usize] = b"des-cfb8\0";
pub const NID_des_cfb8: u32 = 657;
pub const SN_des_ede3_cfb1: &'static [u8; 14usize] = b"DES-EDE3-CFB1\0";
pub const LN_des_ede3_cfb1: &'static [u8; 14usize] = b"des-ede3-cfb1\0";
pub const NID_des_ede3_cfb1: u32 = 658;
pub const SN_des_ede3_cfb8: &'static [u8; 14usize] = b"DES-EDE3-CFB8\0";
pub const LN_des_ede3_cfb8: &'static [u8; 14usize] = b"des-ede3-cfb8\0";
pub const NID_des_ede3_cfb8: u32 = 659;
pub const SN_sha256: &'static [u8; 7usize] = b"SHA256\0";
pub const LN_sha256: &'static [u8; 7usize] = b"sha256\0";
pub const NID_sha256: u32 = 672;
pub const SN_sha384: &'static [u8; 7usize] = b"SHA384\0";
pub const LN_sha384: &'static [u8; 7usize] = b"sha384\0";
pub const NID_sha384: u32 = 673;
pub const SN_sha512: &'static [u8; 7usize] = b"SHA512\0";
pub const LN_sha512: &'static [u8; 7usize] = b"sha512\0";
pub const NID_sha512: u32 = 674;
pub const SN_sha224: &'static [u8; 7usize] = b"SHA224\0";
pub const LN_sha224: &'static [u8; 7usize] = b"sha224\0";
pub const NID_sha224: u32 = 675;
pub const SN_dsa_with_SHA224: &'static [u8; 16usize] = b"dsa_with_SHA224\0";
pub const NID_dsa_with_SHA224: u32 = 802;
pub const SN_dsa_with_SHA256: &'static [u8; 16usize] = b"dsa_with_SHA256\0";
pub const NID_dsa_with_SHA256: u32 = 803;
pub const SN_hold_instruction_code: &'static [u8; 20usize] = b"holdInstructionCode\0";
pub const LN_hold_instruction_code: &'static [u8; 22usize] = b"Hold Instruction Code\0";
pub const NID_hold_instruction_code: u32 = 430;
pub const SN_hold_instruction_none: &'static [u8; 20usize] = b"holdInstructionNone\0";
pub const LN_hold_instruction_none: &'static [u8; 22usize] = b"Hold Instruction None\0";
pub const NID_hold_instruction_none: u32 = 431;
pub const SN_hold_instruction_call_issuer: &'static [u8; 26usize] = b"holdInstructionCallIssuer\0";
pub const LN_hold_instruction_call_issuer: &'static [u8; 29usize] =
    b"Hold Instruction Call Issuer\0";
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const SN_hold_instruction_reject: &'static [u8; 22usize] = b"holdInstructionReject\0";
pub const LN_hold_instruction_reject: &'static [u8; 24usize] = b"Hold Instruction Reject\0";
pub const NID_hold_instruction_reject: u32 = 433;
pub const SN_data: &'static [u8; 5usize] = b"data\0";
pub const NID_data: u32 = 434;
pub const SN_pss: &'static [u8; 4usize] = b"pss\0";
pub const NID_pss: u32 = 435;
pub const SN_ucl: &'static [u8; 4usize] = b"ucl\0";
pub const NID_ucl: u32 = 436;
pub const SN_pilot: &'static [u8; 6usize] = b"pilot\0";
pub const NID_pilot: u32 = 437;
pub const LN_pilotAttributeType: &'static [u8; 19usize] = b"pilotAttributeType\0";
pub const NID_pilotAttributeType: u32 = 438;
pub const LN_pilotAttributeSyntax: &'static [u8; 21usize] = b"pilotAttributeSyntax\0";
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const LN_pilotObjectClass: &'static [u8; 17usize] = b"pilotObjectClass\0";
pub const NID_pilotObjectClass: u32 = 440;
pub const LN_pilotGroups: &'static [u8; 12usize] = b"pilotGroups\0";
pub const NID_pilotGroups: u32 = 441;
pub const LN_iA5StringSyntax: &'static [u8; 16usize] = b"iA5StringSyntax\0";
pub const NID_iA5StringSyntax: u32 = 442;
pub const LN_caseIgnoreIA5StringSyntax: &'static [u8; 26usize] = b"caseIgnoreIA5StringSyntax\0";
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const LN_pilotObject: &'static [u8; 12usize] = b"pilotObject\0";
pub const NID_pilotObject: u32 = 444;
pub const LN_pilotPerson: &'static [u8; 12usize] = b"pilotPerson\0";
pub const NID_pilotPerson: u32 = 445;
pub const SN_account: &'static [u8; 8usize] = b"account\0";
pub const NID_account: u32 = 446;
pub const SN_document: &'static [u8; 9usize] = b"document\0";
pub const NID_document: u32 = 447;
pub const SN_room: &'static [u8; 5usize] = b"room\0";
pub const NID_room: u32 = 448;
pub const LN_documentSeries: &'static [u8; 15usize] = b"documentSeries\0";
pub const NID_documentSeries: u32 = 449;
pub const SN_Domain: &'static [u8; 7usize] = b"domain\0";
pub const LN_Domain: &'static [u8; 7usize] = b"Domain\0";
pub const NID_Domain: u32 = 392;
pub const LN_rFC822localPart: &'static [u8; 16usize] = b"rFC822localPart\0";
pub const NID_rFC822localPart: u32 = 450;
pub const LN_dNSDomain: &'static [u8; 10usize] = b"dNSDomain\0";
pub const NID_dNSDomain: u32 = 451;
pub const LN_domainRelatedObject: &'static [u8; 20usize] = b"domainRelatedObject\0";
pub const NID_domainRelatedObject: u32 = 452;
pub const LN_friendlyCountry: &'static [u8; 16usize] = b"friendlyCountry\0";
pub const NID_friendlyCountry: u32 = 453;
pub const LN_simpleSecurityObject: &'static [u8; 21usize] = b"simpleSecurityObject\0";
pub const NID_simpleSecurityObject: u32 = 454;
pub const LN_pilotOrganization: &'static [u8; 18usize] = b"pilotOrganization\0";
pub const NID_pilotOrganization: u32 = 455;
pub const LN_pilotDSA: &'static [u8; 9usize] = b"pilotDSA\0";
pub const NID_pilotDSA: u32 = 456;
pub const LN_qualityLabelledData: &'static [u8; 20usize] = b"qualityLabelledData\0";
pub const NID_qualityLabelledData: u32 = 457;
pub const SN_userId: &'static [u8; 4usize] = b"UID\0";
pub const LN_userId: &'static [u8; 7usize] = b"userId\0";
pub const NID_userId: u32 = 458;
pub const LN_textEncodedORAddress: &'static [u8; 21usize] = b"textEncodedORAddress\0";
pub const NID_textEncodedORAddress: u32 = 459;
pub const SN_rfc822Mailbox: &'static [u8; 5usize] = b"mail\0";
pub const LN_rfc822Mailbox: &'static [u8; 14usize] = b"rfc822Mailbox\0";
pub const NID_rfc822Mailbox: u32 = 460;
pub const SN_info: &'static [u8; 5usize] = b"info\0";
pub const NID_info: u32 = 461;
pub const LN_favouriteDrink: &'static [u8; 15usize] = b"favouriteDrink\0";
pub const NID_favouriteDrink: u32 = 462;
pub const LN_roomNumber: &'static [u8; 11usize] = b"roomNumber\0";
pub const NID_roomNumber: u32 = 463;
pub const SN_photo: &'static [u8; 6usize] = b"photo\0";
pub const NID_photo: u32 = 464;
pub const LN_userClass: &'static [u8; 10usize] = b"userClass\0";
pub const NID_userClass: u32 = 465;
pub const SN_host: &'static [u8; 5usize] = b"host\0";
pub const NID_host: u32 = 466;
pub const SN_manager: &'static [u8; 8usize] = b"manager\0";
pub const NID_manager: u32 = 467;
pub const LN_documentIdentifier: &'static [u8; 19usize] = b"documentIdentifier\0";
pub const NID_documentIdentifier: u32 = 468;
pub const LN_documentTitle: &'static [u8; 14usize] = b"documentTitle\0";
pub const NID_documentTitle: u32 = 469;
pub const LN_documentVersion: &'static [u8; 16usize] = b"documentVersion\0";
pub const NID_documentVersion: u32 = 470;
pub const LN_documentAuthor: &'static [u8; 15usize] = b"documentAuthor\0";
pub const NID_documentAuthor: u32 = 471;
pub const LN_documentLocation: &'static [u8; 17usize] = b"documentLocation\0";
pub const NID_documentLocation: u32 = 472;
pub const LN_homeTelephoneNumber: &'static [u8; 20usize] = b"homeTelephoneNumber\0";
pub const NID_homeTelephoneNumber: u32 = 473;
pub const SN_secretary: &'static [u8; 10usize] = b"secretary\0";
pub const NID_secretary: u32 = 474;
pub const LN_otherMailbox: &'static [u8; 13usize] = b"otherMailbox\0";
pub const NID_otherMailbox: u32 = 475;
pub const LN_lastModifiedTime: &'static [u8; 17usize] = b"lastModifiedTime\0";
pub const NID_lastModifiedTime: u32 = 476;
pub const LN_lastModifiedBy: &'static [u8; 15usize] = b"lastModifiedBy\0";
pub const NID_lastModifiedBy: u32 = 477;
pub const SN_domainComponent: &'static [u8; 3usize] = b"DC\0";
pub const LN_domainComponent: &'static [u8; 16usize] = b"domainComponent\0";
pub const NID_domainComponent: u32 = 391;
pub const LN_aRecord: &'static [u8; 8usize] = b"aRecord\0";
pub const NID_aRecord: u32 = 478;
pub const LN_pilotAttributeType27: &'static [u8; 21usize] = b"pilotAttributeType27\0";
pub const NID_pilotAttributeType27: u32 = 479;
pub const LN_mXRecord: &'static [u8; 9usize] = b"mXRecord\0";
pub const NID_mXRecord: u32 = 480;
pub const LN_nSRecord: &'static [u8; 9usize] = b"nSRecord\0";
pub const NID_nSRecord: u32 = 481;
pub const LN_sOARecord: &'static [u8; 10usize] = b"sOARecord\0";
pub const NID_sOARecord: u32 = 482;
pub const LN_cNAMERecord: &'static [u8; 12usize] = b"cNAMERecord\0";
pub const NID_cNAMERecord: u32 = 483;
pub const LN_associatedDomain: &'static [u8; 17usize] = b"associatedDomain\0";
pub const NID_associatedDomain: u32 = 484;
pub const LN_associatedName: &'static [u8; 15usize] = b"associatedName\0";
pub const NID_associatedName: u32 = 485;
pub const LN_homePostalAddress: &'static [u8; 18usize] = b"homePostalAddress\0";
pub const NID_homePostalAddress: u32 = 486;
pub const LN_personalTitle: &'static [u8; 14usize] = b"personalTitle\0";
pub const NID_personalTitle: u32 = 487;
pub const LN_mobileTelephoneNumber: &'static [u8; 22usize] = b"mobileTelephoneNumber\0";
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const LN_pagerTelephoneNumber: &'static [u8; 21usize] = b"pagerTelephoneNumber\0";
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const LN_friendlyCountryName: &'static [u8; 20usize] = b"friendlyCountryName\0";
pub const NID_friendlyCountryName: u32 = 490;
pub const LN_organizationalStatus: &'static [u8; 21usize] = b"organizationalStatus\0";
pub const NID_organizationalStatus: u32 = 491;
pub const LN_janetMailbox: &'static [u8; 13usize] = b"janetMailbox\0";
pub const NID_janetMailbox: u32 = 492;
pub const LN_mailPreferenceOption: &'static [u8; 21usize] = b"mailPreferenceOption\0";
pub const NID_mailPreferenceOption: u32 = 493;
pub const LN_buildingName: &'static [u8; 13usize] = b"buildingName\0";
pub const NID_buildingName: u32 = 494;
pub const LN_dSAQuality: &'static [u8; 11usize] = b"dSAQuality\0";
pub const NID_dSAQuality: u32 = 495;
pub const LN_singleLevelQuality: &'static [u8; 19usize] = b"singleLevelQuality\0";
pub const NID_singleLevelQuality: u32 = 496;
pub const LN_subtreeMinimumQuality: &'static [u8; 22usize] = b"subtreeMinimumQuality\0";
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const LN_subtreeMaximumQuality: &'static [u8; 22usize] = b"subtreeMaximumQuality\0";
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const LN_personalSignature: &'static [u8; 18usize] = b"personalSignature\0";
pub const NID_personalSignature: u32 = 499;
pub const LN_dITRedirect: &'static [u8; 12usize] = b"dITRedirect\0";
pub const NID_dITRedirect: u32 = 500;
pub const SN_audio: &'static [u8; 6usize] = b"audio\0";
pub const NID_audio: u32 = 501;
pub const LN_documentPublisher: &'static [u8; 18usize] = b"documentPublisher\0";
pub const NID_documentPublisher: u32 = 502;
pub const SN_id_set: &'static [u8; 7usize] = b"id-set\0";
pub const LN_id_set: &'static [u8; 31usize] = b"Secure Electronic Transactions\0";
pub const NID_id_set: u32 = 512;
pub const SN_set_ctype: &'static [u8; 10usize] = b"set-ctype\0";
pub const LN_set_ctype: &'static [u8; 14usize] = b"content types\0";
pub const NID_set_ctype: u32 = 513;
pub const SN_set_msgExt: &'static [u8; 11usize] = b"set-msgExt\0";
pub const LN_set_msgExt: &'static [u8; 19usize] = b"message extensions\0";
pub const NID_set_msgExt: u32 = 514;
pub const SN_set_attr: &'static [u8; 9usize] = b"set-attr\0";
pub const NID_set_attr: u32 = 515;
pub const SN_set_policy: &'static [u8; 11usize] = b"set-policy\0";
pub const NID_set_policy: u32 = 516;
pub const SN_set_certExt: &'static [u8; 12usize] = b"set-certExt\0";
pub const LN_set_certExt: &'static [u8; 23usize] = b"certificate extensions\0";
pub const NID_set_certExt: u32 = 517;
pub const SN_set_brand: &'static [u8; 10usize] = b"set-brand\0";
pub const NID_set_brand: u32 = 518;
pub const SN_setct_PANData: &'static [u8; 14usize] = b"setct-PANData\0";
pub const NID_setct_PANData: u32 = 519;
pub const SN_setct_PANToken: &'static [u8; 15usize] = b"setct-PANToken\0";
pub const NID_setct_PANToken: u32 = 520;
pub const SN_setct_PANOnly: &'static [u8; 14usize] = b"setct-PANOnly\0";
pub const NID_setct_PANOnly: u32 = 521;
pub const SN_setct_OIData: &'static [u8; 13usize] = b"setct-OIData\0";
pub const NID_setct_OIData: u32 = 522;
pub const SN_setct_PI: &'static [u8; 9usize] = b"setct-PI\0";
pub const NID_setct_PI: u32 = 523;
pub const SN_setct_PIData: &'static [u8; 13usize] = b"setct-PIData\0";
pub const NID_setct_PIData: u32 = 524;
pub const SN_setct_PIDataUnsigned: &'static [u8; 21usize] = b"setct-PIDataUnsigned\0";
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const SN_setct_HODInput: &'static [u8; 15usize] = b"setct-HODInput\0";
pub const NID_setct_HODInput: u32 = 526;
pub const SN_setct_AuthResBaggage: &'static [u8; 21usize] = b"setct-AuthResBaggage\0";
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const SN_setct_AuthRevReqBaggage: &'static [u8; 24usize] = b"setct-AuthRevReqBaggage\0";
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const SN_setct_AuthRevResBaggage: &'static [u8; 24usize] = b"setct-AuthRevResBaggage\0";
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const SN_setct_CapTokenSeq: &'static [u8; 18usize] = b"setct-CapTokenSeq\0";
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const SN_setct_PInitResData: &'static [u8; 19usize] = b"setct-PInitResData\0";
pub const NID_setct_PInitResData: u32 = 531;
pub const SN_setct_PI_TBS: &'static [u8; 13usize] = b"setct-PI-TBS\0";
pub const NID_setct_PI_TBS: u32 = 532;
pub const SN_setct_PResData: &'static [u8; 15usize] = b"setct-PResData\0";
pub const NID_setct_PResData: u32 = 533;
pub const SN_setct_AuthReqTBS: &'static [u8; 17usize] = b"setct-AuthReqTBS\0";
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const SN_setct_AuthResTBS: &'static [u8; 17usize] = b"setct-AuthResTBS\0";
pub const NID_setct_AuthResTBS: u32 = 535;
pub const SN_setct_AuthResTBSX: &'static [u8; 18usize] = b"setct-AuthResTBSX\0";
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const SN_setct_AuthTokenTBS: &'static [u8; 19usize] = b"setct-AuthTokenTBS\0";
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const SN_setct_CapTokenData: &'static [u8; 19usize] = b"setct-CapTokenData\0";
pub const NID_setct_CapTokenData: u32 = 538;
pub const SN_setct_CapTokenTBS: &'static [u8; 18usize] = b"setct-CapTokenTBS\0";
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const SN_setct_AcqCardCodeMsg: &'static [u8; 21usize] = b"setct-AcqCardCodeMsg\0";
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const SN_setct_AuthRevReqTBS: &'static [u8; 20usize] = b"setct-AuthRevReqTBS\0";
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const SN_setct_AuthRevResData: &'static [u8; 21usize] = b"setct-AuthRevResData\0";
pub const NID_setct_AuthRevResData: u32 = 542;
pub const SN_setct_AuthRevResTBS: &'static [u8; 20usize] = b"setct-AuthRevResTBS\0";
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const SN_setct_CapReqTBS: &'static [u8; 16usize] = b"setct-CapReqTBS\0";
pub const NID_setct_CapReqTBS: u32 = 544;
pub const SN_setct_CapReqTBSX: &'static [u8; 17usize] = b"setct-CapReqTBSX\0";
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const SN_setct_CapResData: &'static [u8; 17usize] = b"setct-CapResData\0";
pub const NID_setct_CapResData: u32 = 546;
pub const SN_setct_CapRevReqTBS: &'static [u8; 19usize] = b"setct-CapRevReqTBS\0";
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const SN_setct_CapRevReqTBSX: &'static [u8; 20usize] = b"setct-CapRevReqTBSX\0";
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const SN_setct_CapRevResData: &'static [u8; 20usize] = b"setct-CapRevResData\0";
pub const NID_setct_CapRevResData: u32 = 549;
pub const SN_setct_CredReqTBS: &'static [u8; 17usize] = b"setct-CredReqTBS\0";
pub const NID_setct_CredReqTBS: u32 = 550;
pub const SN_setct_CredReqTBSX: &'static [u8; 18usize] = b"setct-CredReqTBSX\0";
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const SN_setct_CredResData: &'static [u8; 18usize] = b"setct-CredResData\0";
pub const NID_setct_CredResData: u32 = 552;
pub const SN_setct_CredRevReqTBS: &'static [u8; 20usize] = b"setct-CredRevReqTBS\0";
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const SN_setct_CredRevReqTBSX: &'static [u8; 21usize] = b"setct-CredRevReqTBSX\0";
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const SN_setct_CredRevResData: &'static [u8; 21usize] = b"setct-CredRevResData\0";
pub const NID_setct_CredRevResData: u32 = 555;
pub const SN_setct_PCertReqData: &'static [u8; 19usize] = b"setct-PCertReqData\0";
pub const NID_setct_PCertReqData: u32 = 556;
pub const SN_setct_PCertResTBS: &'static [u8; 18usize] = b"setct-PCertResTBS\0";
pub const NID_setct_PCertResTBS: u32 = 557;
pub const SN_setct_BatchAdminReqData: &'static [u8; 24usize] = b"setct-BatchAdminReqData\0";
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const SN_setct_BatchAdminResData: &'static [u8; 24usize] = b"setct-BatchAdminResData\0";
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const SN_setct_CardCInitResTBS: &'static [u8; 22usize] = b"setct-CardCInitResTBS\0";
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const SN_setct_MeAqCInitResTBS: &'static [u8; 22usize] = b"setct-MeAqCInitResTBS\0";
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const SN_setct_RegFormResTBS: &'static [u8; 20usize] = b"setct-RegFormResTBS\0";
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const SN_setct_CertReqData: &'static [u8; 18usize] = b"setct-CertReqData\0";
pub const NID_setct_CertReqData: u32 = 563;
pub const SN_setct_CertReqTBS: &'static [u8; 17usize] = b"setct-CertReqTBS\0";
pub const NID_setct_CertReqTBS: u32 = 564;
pub const SN_setct_CertResData: &'static [u8; 18usize] = b"setct-CertResData\0";
pub const NID_setct_CertResData: u32 = 565;
pub const SN_setct_CertInqReqTBS: &'static [u8; 20usize] = b"setct-CertInqReqTBS\0";
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const SN_setct_ErrorTBS: &'static [u8; 15usize] = b"setct-ErrorTBS\0";
pub const NID_setct_ErrorTBS: u32 = 567;
pub const SN_setct_PIDualSignedTBE: &'static [u8; 22usize] = b"setct-PIDualSignedTBE\0";
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const SN_setct_PIUnsignedTBE: &'static [u8; 20usize] = b"setct-PIUnsignedTBE\0";
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const SN_setct_AuthReqTBE: &'static [u8; 17usize] = b"setct-AuthReqTBE\0";
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const SN_setct_AuthResTBE: &'static [u8; 17usize] = b"setct-AuthResTBE\0";
pub const NID_setct_AuthResTBE: u32 = 571;
pub const SN_setct_AuthResTBEX: &'static [u8; 18usize] = b"setct-AuthResTBEX\0";
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const SN_setct_AuthTokenTBE: &'static [u8; 19usize] = b"setct-AuthTokenTBE\0";
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const SN_setct_CapTokenTBE: &'static [u8; 18usize] = b"setct-CapTokenTBE\0";
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const SN_setct_CapTokenTBEX: &'static [u8; 19usize] = b"setct-CapTokenTBEX\0";
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const SN_setct_AcqCardCodeMsgTBE: &'static [u8; 24usize] = b"setct-AcqCardCodeMsgTBE\0";
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const SN_setct_AuthRevReqTBE: &'static [u8; 20usize] = b"setct-AuthRevReqTBE\0";
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const SN_setct_AuthRevResTBE: &'static [u8; 20usize] = b"setct-AuthRevResTBE\0";
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const SN_setct_AuthRevResTBEB: &'static [u8; 21usize] = b"setct-AuthRevResTBEB\0";
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const SN_setct_CapReqTBE: &'static [u8; 16usize] = b"setct-CapReqTBE\0";
pub const NID_setct_CapReqTBE: u32 = 580;
pub const SN_setct_CapReqTBEX: &'static [u8; 17usize] = b"setct-CapReqTBEX\0";
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const SN_setct_CapResTBE: &'static [u8; 16usize] = b"setct-CapResTBE\0";
pub const NID_setct_CapResTBE: u32 = 582;
pub const SN_setct_CapRevReqTBE: &'static [u8; 19usize] = b"setct-CapRevReqTBE\0";
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const SN_setct_CapRevReqTBEX: &'static [u8; 20usize] = b"setct-CapRevReqTBEX\0";
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const SN_setct_CapRevResTBE: &'static [u8; 19usize] = b"setct-CapRevResTBE\0";
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const SN_setct_CredReqTBE: &'static [u8; 17usize] = b"setct-CredReqTBE\0";
pub const NID_setct_CredReqTBE: u32 = 586;
pub const SN_setct_CredReqTBEX: &'static [u8; 18usize] = b"setct-CredReqTBEX\0";
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const SN_setct_CredResTBE: &'static [u8; 17usize] = b"setct-CredResTBE\0";
pub const NID_setct_CredResTBE: u32 = 588;
pub const SN_setct_CredRevReqTBE: &'static [u8; 20usize] = b"setct-CredRevReqTBE\0";
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const SN_setct_CredRevReqTBEX: &'static [u8; 21usize] = b"setct-CredRevReqTBEX\0";
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const SN_setct_CredRevResTBE: &'static [u8; 20usize] = b"setct-CredRevResTBE\0";
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const SN_setct_BatchAdminReqTBE: &'static [u8; 23usize] = b"setct-BatchAdminReqTBE\0";
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const SN_setct_BatchAdminResTBE: &'static [u8; 23usize] = b"setct-BatchAdminResTBE\0";
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const SN_setct_RegFormReqTBE: &'static [u8; 20usize] = b"setct-RegFormReqTBE\0";
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const SN_setct_CertReqTBE: &'static [u8; 17usize] = b"setct-CertReqTBE\0";
pub const NID_setct_CertReqTBE: u32 = 595;
pub const SN_setct_CertReqTBEX: &'static [u8; 18usize] = b"setct-CertReqTBEX\0";
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const SN_setct_CertResTBE: &'static [u8; 17usize] = b"setct-CertResTBE\0";
pub const NID_setct_CertResTBE: u32 = 597;
pub const SN_setct_CRLNotificationTBS: &'static [u8; 25usize] = b"setct-CRLNotificationTBS\0";
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const SN_setct_CRLNotificationResTBS: &'static [u8; 28usize] = b"setct-CRLNotificationResTBS\0";
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const SN_setct_BCIDistributionTBS: &'static [u8; 25usize] = b"setct-BCIDistributionTBS\0";
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const SN_setext_genCrypt: &'static [u8; 16usize] = b"setext-genCrypt\0";
pub const LN_setext_genCrypt: &'static [u8; 19usize] = b"generic cryptogram\0";
pub const NID_setext_genCrypt: u32 = 601;
pub const SN_setext_miAuth: &'static [u8; 14usize] = b"setext-miAuth\0";
pub const LN_setext_miAuth: &'static [u8; 24usize] = b"merchant initiated auth\0";
pub const NID_setext_miAuth: u32 = 602;
pub const SN_setext_pinSecure: &'static [u8; 17usize] = b"setext-pinSecure\0";
pub const NID_setext_pinSecure: u32 = 603;
pub const SN_setext_pinAny: &'static [u8; 14usize] = b"setext-pinAny\0";
pub const NID_setext_pinAny: u32 = 604;
pub const SN_setext_track2: &'static [u8; 14usize] = b"setext-track2\0";
pub const NID_setext_track2: u32 = 605;
pub const SN_setext_cv: &'static [u8; 10usize] = b"setext-cv\0";
pub const LN_setext_cv: &'static [u8; 24usize] = b"additional verification\0";
pub const NID_setext_cv: u32 = 606;
pub const SN_set_policy_root: &'static [u8; 16usize] = b"set-policy-root\0";
pub const NID_set_policy_root: u32 = 607;
pub const SN_setCext_hashedRoot: &'static [u8; 19usize] = b"setCext-hashedRoot\0";
pub const NID_setCext_hashedRoot: u32 = 608;
pub const SN_setCext_certType: &'static [u8; 17usize] = b"setCext-certType\0";
pub const NID_setCext_certType: u32 = 609;
pub const SN_setCext_merchData: &'static [u8; 18usize] = b"setCext-merchData\0";
pub const NID_setCext_merchData: u32 = 610;
pub const SN_setCext_cCertRequired: &'static [u8; 22usize] = b"setCext-cCertRequired\0";
pub const NID_setCext_cCertRequired: u32 = 611;
pub const SN_setCext_tunneling: &'static [u8; 18usize] = b"setCext-tunneling\0";
pub const NID_setCext_tunneling: u32 = 612;
pub const SN_setCext_setExt: &'static [u8; 15usize] = b"setCext-setExt\0";
pub const NID_setCext_setExt: u32 = 613;
pub const SN_setCext_setQualf: &'static [u8; 17usize] = b"setCext-setQualf\0";
pub const NID_setCext_setQualf: u32 = 614;
pub const SN_setCext_PGWYcapabilities: &'static [u8; 25usize] = b"setCext-PGWYcapabilities\0";
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const SN_setCext_TokenIdentifier: &'static [u8; 24usize] = b"setCext-TokenIdentifier\0";
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const SN_setCext_Track2Data: &'static [u8; 19usize] = b"setCext-Track2Data\0";
pub const NID_setCext_Track2Data: u32 = 617;
pub const SN_setCext_TokenType: &'static [u8; 18usize] = b"setCext-TokenType\0";
pub const NID_setCext_TokenType: u32 = 618;
pub const SN_setCext_IssuerCapabilities: &'static [u8; 27usize] = b"setCext-IssuerCapabilities\0";
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const SN_setAttr_Cert: &'static [u8; 13usize] = b"setAttr-Cert\0";
pub const NID_setAttr_Cert: u32 = 620;
pub const SN_setAttr_PGWYcap: &'static [u8; 16usize] = b"setAttr-PGWYcap\0";
pub const LN_setAttr_PGWYcap: &'static [u8; 29usize] = b"payment gateway capabilities\0";
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const SN_setAttr_TokenType: &'static [u8; 18usize] = b"setAttr-TokenType\0";
pub const NID_setAttr_TokenType: u32 = 622;
pub const SN_setAttr_IssCap: &'static [u8; 15usize] = b"setAttr-IssCap\0";
pub const LN_setAttr_IssCap: &'static [u8; 20usize] = b"issuer capabilities\0";
pub const NID_setAttr_IssCap: u32 = 623;
pub const SN_set_rootKeyThumb: &'static [u8; 17usize] = b"set-rootKeyThumb\0";
pub const NID_set_rootKeyThumb: u32 = 624;
pub const SN_set_addPolicy: &'static [u8; 14usize] = b"set-addPolicy\0";
pub const NID_set_addPolicy: u32 = 625;
pub const SN_setAttr_Token_EMV: &'static [u8; 18usize] = b"setAttr-Token-EMV\0";
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const SN_setAttr_Token_B0Prime: &'static [u8; 22usize] = b"setAttr-Token-B0Prime\0";
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const SN_setAttr_IssCap_CVM: &'static [u8; 19usize] = b"setAttr-IssCap-CVM\0";
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const SN_setAttr_IssCap_T2: &'static [u8; 18usize] = b"setAttr-IssCap-T2\0";
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const SN_setAttr_IssCap_Sig: &'static [u8; 19usize] = b"setAttr-IssCap-Sig\0";
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const SN_setAttr_GenCryptgrm: &'static [u8; 20usize] = b"setAttr-GenCryptgrm\0";
pub const LN_setAttr_GenCryptgrm: &'static [u8; 20usize] = b"generate cryptogram\0";
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const SN_setAttr_T2Enc: &'static [u8; 14usize] = b"setAttr-T2Enc\0";
pub const LN_setAttr_T2Enc: &'static [u8; 18usize] = b"encrypted track 2\0";
pub const NID_setAttr_T2Enc: u32 = 632;
pub const SN_setAttr_T2cleartxt: &'static [u8; 19usize] = b"setAttr-T2cleartxt\0";
pub const LN_setAttr_T2cleartxt: &'static [u8; 18usize] = b"cleartext track 2\0";
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const SN_setAttr_TokICCsig: &'static [u8; 18usize] = b"setAttr-TokICCsig\0";
pub const LN_setAttr_TokICCsig: &'static [u8; 23usize] = b"ICC or token signature\0";
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const SN_setAttr_SecDevSig: &'static [u8; 18usize] = b"setAttr-SecDevSig\0";
pub const LN_setAttr_SecDevSig: &'static [u8; 24usize] = b"secure device signature\0";
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const SN_set_brand_IATA_ATA: &'static [u8; 19usize] = b"set-brand-IATA-ATA\0";
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const SN_set_brand_Diners: &'static [u8; 17usize] = b"set-brand-Diners\0";
pub const NID_set_brand_Diners: u32 = 637;
pub const SN_set_brand_AmericanExpress: &'static [u8; 26usize] = b"set-brand-AmericanExpress\0";
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const SN_set_brand_JCB: &'static [u8; 14usize] = b"set-brand-JCB\0";
pub const NID_set_brand_JCB: u32 = 639;
pub const SN_set_brand_Visa: &'static [u8; 15usize] = b"set-brand-Visa\0";
pub const NID_set_brand_Visa: u32 = 640;
pub const SN_set_brand_MasterCard: &'static [u8; 21usize] = b"set-brand-MasterCard\0";
pub const NID_set_brand_MasterCard: u32 = 641;
pub const SN_set_brand_Novus: &'static [u8; 16usize] = b"set-brand-Novus\0";
pub const NID_set_brand_Novus: u32 = 642;
pub const SN_des_cdmf: &'static [u8; 9usize] = b"DES-CDMF\0";
pub const LN_des_cdmf: &'static [u8; 9usize] = b"des-cdmf\0";
pub const NID_des_cdmf: u32 = 643;
pub const SN_rsaOAEPEncryptionSET: &'static [u8; 21usize] = b"rsaOAEPEncryptionSET\0";
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const SN_ipsec3: &'static [u8; 14usize] = b"Oakley-EC2N-3\0";
pub const LN_ipsec3: &'static [u8; 7usize] = b"ipsec3\0";
pub const NID_ipsec3: u32 = 749;
pub const SN_ipsec4: &'static [u8; 14usize] = b"Oakley-EC2N-4\0";
pub const LN_ipsec4: &'static [u8; 7usize] = b"ipsec4\0";
pub const NID_ipsec4: u32 = 750;
pub const SN_whirlpool: &'static [u8; 10usize] = b"whirlpool\0";
pub const NID_whirlpool: u32 = 804;
pub const SN_cryptopro: &'static [u8; 10usize] = b"cryptopro\0";
pub const NID_cryptopro: u32 = 805;
pub const SN_cryptocom: &'static [u8; 10usize] = b"cryptocom\0";
pub const NID_cryptocom: u32 = 806;
pub const SN_id_GostR3411_94_with_GostR3410_2001: &'static [u8; 36usize] =
    b"id-GostR3411-94-with-GostR3410-2001\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001: &'static [u8; 39usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const SN_id_GostR3411_94_with_GostR3410_94: &'static [u8; 34usize] =
    b"id-GostR3411-94-with-GostR3410-94\0";
pub const LN_id_GostR3411_94_with_GostR3410_94: &'static [u8; 37usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94\0";
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const SN_id_GostR3411_94: &'static [u8; 10usize] = b"md_gost94\0";
pub const LN_id_GostR3411_94: &'static [u8; 16usize] = b"GOST R 34.11-94\0";
pub const NID_id_GostR3411_94: u32 = 809;
pub const SN_id_HMACGostR3411_94: &'static [u8; 20usize] = b"id-HMACGostR3411-94\0";
pub const LN_id_HMACGostR3411_94: &'static [u8; 19usize] = b"HMAC GOST 34.11-94\0";
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const SN_id_GostR3410_2001: &'static [u8; 9usize] = b"gost2001\0";
pub const LN_id_GostR3410_2001: &'static [u8; 18usize] = b"GOST R 34.10-2001\0";
pub const NID_id_GostR3410_2001: u32 = 811;
pub const SN_id_GostR3410_94: &'static [u8; 7usize] = b"gost94\0";
pub const LN_id_GostR3410_94: &'static [u8; 16usize] = b"GOST R 34.10-94\0";
pub const NID_id_GostR3410_94: u32 = 812;
pub const SN_id_Gost28147_89: &'static [u8; 7usize] = b"gost89\0";
pub const LN_id_Gost28147_89: &'static [u8; 14usize] = b"GOST 28147-89\0";
pub const NID_id_Gost28147_89: u32 = 813;
pub const SN_gost89_cnt: &'static [u8; 11usize] = b"gost89-cnt\0";
pub const NID_gost89_cnt: u32 = 814;
pub const SN_id_Gost28147_89_MAC: &'static [u8; 9usize] = b"gost-mac\0";
pub const LN_id_Gost28147_89_MAC: &'static [u8; 18usize] = b"GOST 28147-89 MAC\0";
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const SN_id_GostR3411_94_prf: &'static [u8; 17usize] = b"prf-gostr3411-94\0";
pub const LN_id_GostR3411_94_prf: &'static [u8; 20usize] = b"GOST R 34.11-94 PRF\0";
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const SN_id_GostR3410_2001DH: &'static [u8; 20usize] = b"id-GostR3410-2001DH\0";
pub const LN_id_GostR3410_2001DH: &'static [u8; 21usize] = b"GOST R 34.10-2001 DH\0";
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const SN_id_GostR3410_94DH: &'static [u8; 18usize] = b"id-GostR3410-94DH\0";
pub const LN_id_GostR3410_94DH: &'static [u8; 19usize] = b"GOST R 34.10-94 DH\0";
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing: &'static [u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-KeyMeshing\0";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const SN_id_Gost28147_89_None_KeyMeshing: &'static [u8; 32usize] =
    b"id-Gost28147-89-None-KeyMeshing\0";
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const SN_id_GostR3411_94_TestParamSet: &'static [u8; 29usize] =
    b"id-GostR3411-94-TestParamSet\0";
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const SN_id_GostR3411_94_CryptoProParamSet: &'static [u8; 34usize] =
    b"id-GostR3411-94-CryptoProParamSet\0";
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const SN_id_Gost28147_89_TestParamSet: &'static [u8; 29usize] =
    b"id-Gost28147-89-TestParamSet\0";
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet: &'static [u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-A-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet: &'static [u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-B-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet: &'static [u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-C-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet: &'static [u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-D-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: &'static [u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: &'static [u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: &'static [u8; 41usize] =
    b"id-Gost28147-89-CryptoPro-RIC-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const SN_id_GostR3410_94_TestParamSet: &'static [u8; 29usize] =
    b"id-GostR3410-94-TestParamSet\0";
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet: &'static [u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet: &'static [u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet: &'static [u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet: &'static [u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-D-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet: &'static [u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet: &'static [u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet: &'static [u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchC-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const SN_id_GostR3410_2001_TestParamSet: &'static [u8; 31usize] =
    b"id-GostR3410-2001-TestParamSet\0";
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet: &'static [u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet: &'static [u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet: &'static [u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet: &'static [u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet: &'static [u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const SN_id_GostR3410_94_a: &'static [u8; 18usize] = b"id-GostR3410-94-a\0";
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const SN_id_GostR3410_94_aBis: &'static [u8; 21usize] = b"id-GostR3410-94-aBis\0";
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const SN_id_GostR3410_94_b: &'static [u8; 18usize] = b"id-GostR3410-94-b\0";
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const SN_id_GostR3410_94_bBis: &'static [u8; 21usize] = b"id-GostR3410-94-bBis\0";
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const SN_id_Gost28147_89_cc: &'static [u8; 19usize] = b"id-Gost28147-89-cc\0";
pub const LN_id_Gost28147_89_cc: &'static [u8; 33usize] = b"GOST 28147-89 Cryptocom ParamSet\0";
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const SN_id_GostR3410_94_cc: &'static [u8; 9usize] = b"gost94cc\0";
pub const LN_id_GostR3410_94_cc: &'static [u8; 24usize] = b"GOST 34.10-94 Cryptocom\0";
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const SN_id_GostR3410_2001_cc: &'static [u8; 11usize] = b"gost2001cc\0";
pub const LN_id_GostR3410_2001_cc: &'static [u8; 26usize] = b"GOST 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const SN_id_GostR3411_94_with_GostR3410_94_cc: &'static [u8; 37usize] =
    b"id-GostR3411-94-with-GostR3410-94-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc: &'static [u8; 47usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc: &'static [u8; 39usize] =
    b"id-GostR3411-94-with-GostR3410-2001-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc: &'static [u8; 49usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const SN_id_GostR3410_2001_ParamSet_cc: &'static [u8; 30usize] =
    b"id-GostR3410-2001-ParamSet-cc\0";
pub const LN_id_GostR3410_2001_ParamSet_cc: &'static [u8; 41usize] =
    b"GOST R 3410-2001 Parameter Set Cryptocom\0";
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const SN_camellia_128_cbc: &'static [u8; 17usize] = b"CAMELLIA-128-CBC\0";
pub const LN_camellia_128_cbc: &'static [u8; 17usize] = b"camellia-128-cbc\0";
pub const NID_camellia_128_cbc: u32 = 751;
pub const SN_camellia_192_cbc: &'static [u8; 17usize] = b"CAMELLIA-192-CBC\0";
pub const LN_camellia_192_cbc: &'static [u8; 17usize] = b"camellia-192-cbc\0";
pub const NID_camellia_192_cbc: u32 = 752;
pub const SN_camellia_256_cbc: &'static [u8; 17usize] = b"CAMELLIA-256-CBC\0";
pub const LN_camellia_256_cbc: &'static [u8; 17usize] = b"camellia-256-cbc\0";
pub const NID_camellia_256_cbc: u32 = 753;
pub const SN_id_camellia128_wrap: &'static [u8; 20usize] = b"id-camellia128-wrap\0";
pub const NID_id_camellia128_wrap: u32 = 907;
pub const SN_id_camellia192_wrap: &'static [u8; 20usize] = b"id-camellia192-wrap\0";
pub const NID_id_camellia192_wrap: u32 = 908;
pub const SN_id_camellia256_wrap: &'static [u8; 20usize] = b"id-camellia256-wrap\0";
pub const NID_id_camellia256_wrap: u32 = 909;
pub const SN_camellia_128_ecb: &'static [u8; 17usize] = b"CAMELLIA-128-ECB\0";
pub const LN_camellia_128_ecb: &'static [u8; 17usize] = b"camellia-128-ecb\0";
pub const NID_camellia_128_ecb: u32 = 754;
pub const SN_camellia_128_ofb128: &'static [u8; 17usize] = b"CAMELLIA-128-OFB\0";
pub const LN_camellia_128_ofb128: &'static [u8; 17usize] = b"camellia-128-ofb\0";
pub const NID_camellia_128_ofb128: u32 = 766;
pub const SN_camellia_128_cfb128: &'static [u8; 17usize] = b"CAMELLIA-128-CFB\0";
pub const LN_camellia_128_cfb128: &'static [u8; 17usize] = b"camellia-128-cfb\0";
pub const NID_camellia_128_cfb128: u32 = 757;
pub const SN_camellia_192_ecb: &'static [u8; 17usize] = b"CAMELLIA-192-ECB\0";
pub const LN_camellia_192_ecb: &'static [u8; 17usize] = b"camellia-192-ecb\0";
pub const NID_camellia_192_ecb: u32 = 755;
pub const SN_camellia_192_ofb128: &'static [u8; 17usize] = b"CAMELLIA-192-OFB\0";
pub const LN_camellia_192_ofb128: &'static [u8; 17usize] = b"camellia-192-ofb\0";
pub const NID_camellia_192_ofb128: u32 = 767;
pub const SN_camellia_192_cfb128: &'static [u8; 17usize] = b"CAMELLIA-192-CFB\0";
pub const LN_camellia_192_cfb128: &'static [u8; 17usize] = b"camellia-192-cfb\0";
pub const NID_camellia_192_cfb128: u32 = 758;
pub const SN_camellia_256_ecb: &'static [u8; 17usize] = b"CAMELLIA-256-ECB\0";
pub const LN_camellia_256_ecb: &'static [u8; 17usize] = b"camellia-256-ecb\0";
pub const NID_camellia_256_ecb: u32 = 756;
pub const SN_camellia_256_ofb128: &'static [u8; 17usize] = b"CAMELLIA-256-OFB\0";
pub const LN_camellia_256_ofb128: &'static [u8; 17usize] = b"camellia-256-ofb\0";
pub const NID_camellia_256_ofb128: u32 = 768;
pub const SN_camellia_256_cfb128: &'static [u8; 17usize] = b"CAMELLIA-256-CFB\0";
pub const LN_camellia_256_cfb128: &'static [u8; 17usize] = b"camellia-256-cfb\0";
pub const NID_camellia_256_cfb128: u32 = 759;
pub const SN_camellia_128_cfb1: &'static [u8; 18usize] = b"CAMELLIA-128-CFB1\0";
pub const LN_camellia_128_cfb1: &'static [u8; 18usize] = b"camellia-128-cfb1\0";
pub const NID_camellia_128_cfb1: u32 = 760;
pub const SN_camellia_192_cfb1: &'static [u8; 18usize] = b"CAMELLIA-192-CFB1\0";
pub const LN_camellia_192_cfb1: &'static [u8; 18usize] = b"camellia-192-cfb1\0";
pub const NID_camellia_192_cfb1: u32 = 761;
pub const SN_camellia_256_cfb1: &'static [u8; 18usize] = b"CAMELLIA-256-CFB1\0";
pub const LN_camellia_256_cfb1: &'static [u8; 18usize] = b"camellia-256-cfb1\0";
pub const NID_camellia_256_cfb1: u32 = 762;
pub const SN_camellia_128_cfb8: &'static [u8; 18usize] = b"CAMELLIA-128-CFB8\0";
pub const LN_camellia_128_cfb8: &'static [u8; 18usize] = b"camellia-128-cfb8\0";
pub const NID_camellia_128_cfb8: u32 = 763;
pub const SN_camellia_192_cfb8: &'static [u8; 18usize] = b"CAMELLIA-192-CFB8\0";
pub const LN_camellia_192_cfb8: &'static [u8; 18usize] = b"camellia-192-cfb8\0";
pub const NID_camellia_192_cfb8: u32 = 764;
pub const SN_camellia_256_cfb8: &'static [u8; 18usize] = b"CAMELLIA-256-CFB8\0";
pub const LN_camellia_256_cfb8: &'static [u8; 18usize] = b"camellia-256-cfb8\0";
pub const NID_camellia_256_cfb8: u32 = 765;
pub const SN_kisa: &'static [u8; 5usize] = b"KISA\0";
pub const LN_kisa: &'static [u8; 5usize] = b"kisa\0";
pub const NID_kisa: u32 = 773;
pub const SN_seed_ecb: &'static [u8; 9usize] = b"SEED-ECB\0";
pub const LN_seed_ecb: &'static [u8; 9usize] = b"seed-ecb\0";
pub const NID_seed_ecb: u32 = 776;
pub const SN_seed_cbc: &'static [u8; 9usize] = b"SEED-CBC\0";
pub const LN_seed_cbc: &'static [u8; 9usize] = b"seed-cbc\0";
pub const NID_seed_cbc: u32 = 777;
pub const SN_seed_cfb128: &'static [u8; 9usize] = b"SEED-CFB\0";
pub const LN_seed_cfb128: &'static [u8; 9usize] = b"seed-cfb\0";
pub const NID_seed_cfb128: u32 = 779;
pub const SN_seed_ofb128: &'static [u8; 9usize] = b"SEED-OFB\0";
pub const LN_seed_ofb128: &'static [u8; 9usize] = b"seed-ofb\0";
pub const NID_seed_ofb128: u32 = 778;
pub const SN_hmac: &'static [u8; 5usize] = b"HMAC\0";
pub const LN_hmac: &'static [u8; 5usize] = b"hmac\0";
pub const NID_hmac: u32 = 855;
pub const SN_cmac: &'static [u8; 5usize] = b"CMAC\0";
pub const LN_cmac: &'static [u8; 5usize] = b"cmac\0";
pub const NID_cmac: u32 = 894;
pub const SN_rc4_hmac_md5: &'static [u8; 13usize] = b"RC4-HMAC-MD5\0";
pub const LN_rc4_hmac_md5: &'static [u8; 13usize] = b"rc4-hmac-md5\0";
pub const NID_rc4_hmac_md5: u32 = 915;
pub const SN_aes_128_cbc_hmac_sha1: &'static [u8; 22usize] = b"AES-128-CBC-HMAC-SHA1\0";
pub const LN_aes_128_cbc_hmac_sha1: &'static [u8; 22usize] = b"aes-128-cbc-hmac-sha1\0";
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const SN_aes_192_cbc_hmac_sha1: &'static [u8; 22usize] = b"AES-192-CBC-HMAC-SHA1\0";
pub const LN_aes_192_cbc_hmac_sha1: &'static [u8; 22usize] = b"aes-192-cbc-hmac-sha1\0";
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const SN_aes_256_cbc_hmac_sha1: &'static [u8; 22usize] = b"AES-256-CBC-HMAC-SHA1\0";
pub const LN_aes_256_cbc_hmac_sha1: &'static [u8; 22usize] = b"aes-256-cbc-hmac-sha1\0";
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const SN_aes_128_cbc_hmac_sha256: &'static [u8; 24usize] = b"AES-128-CBC-HMAC-SHA256\0";
pub const LN_aes_128_cbc_hmac_sha256: &'static [u8; 24usize] = b"aes-128-cbc-hmac-sha256\0";
pub const NID_aes_128_cbc_hmac_sha256: u32 = 948;
pub const SN_aes_192_cbc_hmac_sha256: &'static [u8; 24usize] = b"AES-192-CBC-HMAC-SHA256\0";
pub const LN_aes_192_cbc_hmac_sha256: &'static [u8; 24usize] = b"aes-192-cbc-hmac-sha256\0";
pub const NID_aes_192_cbc_hmac_sha256: u32 = 949;
pub const SN_aes_256_cbc_hmac_sha256: &'static [u8; 24usize] = b"AES-256-CBC-HMAC-SHA256\0";
pub const LN_aes_256_cbc_hmac_sha256: &'static [u8; 24usize] = b"aes-256-cbc-hmac-sha256\0";
pub const NID_aes_256_cbc_hmac_sha256: u32 = 950;
pub const SN_dhpublicnumber: &'static [u8; 15usize] = b"dhpublicnumber\0";
pub const LN_dhpublicnumber: &'static [u8; 9usize] = b"X9.42 DH\0";
pub const NID_dhpublicnumber: u32 = 920;
pub const SN_brainpoolP160r1: &'static [u8; 16usize] = b"brainpoolP160r1\0";
pub const NID_brainpoolP160r1: u32 = 921;
pub const SN_brainpoolP160t1: &'static [u8; 16usize] = b"brainpoolP160t1\0";
pub const NID_brainpoolP160t1: u32 = 922;
pub const SN_brainpoolP192r1: &'static [u8; 16usize] = b"brainpoolP192r1\0";
pub const NID_brainpoolP192r1: u32 = 923;
pub const SN_brainpoolP192t1: &'static [u8; 16usize] = b"brainpoolP192t1\0";
pub const NID_brainpoolP192t1: u32 = 924;
pub const SN_brainpoolP224r1: &'static [u8; 16usize] = b"brainpoolP224r1\0";
pub const NID_brainpoolP224r1: u32 = 925;
pub const SN_brainpoolP224t1: &'static [u8; 16usize] = b"brainpoolP224t1\0";
pub const NID_brainpoolP224t1: u32 = 926;
pub const SN_brainpoolP256r1: &'static [u8; 16usize] = b"brainpoolP256r1\0";
pub const NID_brainpoolP256r1: u32 = 927;
pub const SN_brainpoolP256t1: &'static [u8; 16usize] = b"brainpoolP256t1\0";
pub const NID_brainpoolP256t1: u32 = 928;
pub const SN_brainpoolP320r1: &'static [u8; 16usize] = b"brainpoolP320r1\0";
pub const NID_brainpoolP320r1: u32 = 929;
pub const SN_brainpoolP320t1: &'static [u8; 16usize] = b"brainpoolP320t1\0";
pub const NID_brainpoolP320t1: u32 = 930;
pub const SN_brainpoolP384r1: &'static [u8; 16usize] = b"brainpoolP384r1\0";
pub const NID_brainpoolP384r1: u32 = 931;
pub const SN_brainpoolP384t1: &'static [u8; 16usize] = b"brainpoolP384t1\0";
pub const NID_brainpoolP384t1: u32 = 932;
pub const SN_brainpoolP512r1: &'static [u8; 16usize] = b"brainpoolP512r1\0";
pub const NID_brainpoolP512r1: u32 = 933;
pub const SN_brainpoolP512t1: &'static [u8; 16usize] = b"brainpoolP512t1\0";
pub const NID_brainpoolP512t1: u32 = 934;
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme: &'static [u8; 34usize] =
    b"dhSinglePass-stdDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme: &'static [u8; 36usize] =
    b"dhSinglePass-stdDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme: &'static [u8; 36usize] =
    b"dhSinglePass-stdDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme: &'static [u8; 36usize] =
    b"dhSinglePass-stdDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme: &'static [u8; 36usize] =
    b"dhSinglePass-stdDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme: &'static [u8; 39usize] =
    b"dhSinglePass-cofactorDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme: &'static [u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme: &'static [u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme: &'static [u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme: &'static [u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const SN_dh_std_kdf: &'static [u8; 11usize] = b"dh-std-kdf\0";
pub const NID_dh_std_kdf: u32 = 946;
pub const SN_dh_cofactor_kdf: &'static [u8; 16usize] = b"dh-cofactor-kdf\0";
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const SN_ct_precert_scts: &'static [u8; 16usize] = b"ct_precert_scts\0";
pub const LN_ct_precert_scts: &'static [u8; 23usize] = b"CT Precertificate SCTs\0";
pub const NID_ct_precert_scts: u32 = 951;
pub const SN_ct_precert_poison: &'static [u8; 18usize] = b"ct_precert_poison\0";
pub const LN_ct_precert_poison: &'static [u8; 25usize] = b"CT Precertificate Poison\0";
pub const NID_ct_precert_poison: u32 = 952;
pub const SN_ct_precert_signer: &'static [u8; 18usize] = b"ct_precert_signer\0";
pub const LN_ct_precert_signer: &'static [u8; 25usize] = b"CT Precertificate Signer\0";
pub const NID_ct_precert_signer: u32 = 953;
pub const SN_ct_cert_scts: &'static [u8; 13usize] = b"ct_cert_scts\0";
pub const LN_ct_cert_scts: &'static [u8; 20usize] = b"CT Certificate SCTs\0";
pub const NID_ct_cert_scts: u32 = 954;
pub const SN_jurisdictionLocalityName: &'static [u8; 14usize] = b"jurisdictionL\0";
pub const LN_jurisdictionLocalityName: &'static [u8; 25usize] = b"jurisdictionLocalityName\0";
pub const NID_jurisdictionLocalityName: u32 = 955;
pub const SN_jurisdictionStateOrProvinceName: &'static [u8; 15usize] = b"jurisdictionST\0";
pub const LN_jurisdictionStateOrProvinceName: &'static [u8; 32usize] =
    b"jurisdictionStateOrProvinceName\0";
pub const NID_jurisdictionStateOrProvinceName: u32 = 956;
pub const SN_jurisdictionCountryName: &'static [u8; 14usize] = b"jurisdictionC\0";
pub const LN_jurisdictionCountryName: &'static [u8; 24usize] = b"jurisdictionCountryName\0";
pub const NID_jurisdictionCountryName: u32 = 957;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const BN_BITS: u32 = 128;
pub const BN_BYTES: u32 = 8;
pub const BN_BITS2: u32 = 64;
pub const BN_BITS4: u32 = 32;
pub const BN_MASK2: i32 = -1;
pub const BN_MASK2l: u32 = 4294967295;
pub const BN_MASK2h: i64 = -4294967296;
pub const BN_MASK2h1: i32 = -2147483648;
pub const BN_TBIT: i64 = -9223372036854775808;
pub const BN_DEC_CONV: i64 = -8446744073709551616;
pub const BN_DEC_FMT1: &'static [u8; 4usize] = b"%lu\0";
pub const BN_DEC_FMT2: &'static [u8; 7usize] = b"%019lu\0";
pub const BN_DEC_NUM: u32 = 19;
pub const BN_HEX_FMT1: &'static [u8; 4usize] = b"%lX\0";
pub const BN_HEX_FMT2: &'static [u8; 7usize] = b"%016lX\0";
pub const BN_DEFAULT_BITS: u32 = 1280;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_FLG_CONSTTIME: u32 = 4;
pub const BN_FLG_FREE: u32 = 32768;
pub const BN_prime_checks: u32 = 0;
pub const BN_BLINDING_NO_UPDATE: u32 = 1;
pub const BN_BLINDING_NO_RECREATE: u32 = 2;
pub const BN_FLG_FIXED_TOP: u32 = 0;
pub const BN_F_BNRAND: u32 = 127;
pub const BN_F_BN_BLINDING_CONVERT_EX: u32 = 100;
pub const BN_F_BN_BLINDING_CREATE_PARAM: u32 = 128;
pub const BN_F_BN_BLINDING_INVERT_EX: u32 = 101;
pub const BN_F_BN_BLINDING_NEW: u32 = 102;
pub const BN_F_BN_BLINDING_UPDATE: u32 = 103;
pub const BN_F_BN_BN2DEC: u32 = 104;
pub const BN_F_BN_BN2HEX: u32 = 105;
pub const BN_F_BN_CTX_GET: u32 = 116;
pub const BN_F_BN_CTX_NEW: u32 = 106;
pub const BN_F_BN_CTX_START: u32 = 129;
pub const BN_F_BN_DIV: u32 = 107;
pub const BN_F_BN_DIV_NO_BRANCH: u32 = 138;
pub const BN_F_BN_DIV_RECP: u32 = 130;
pub const BN_F_BN_EXP: u32 = 123;
pub const BN_F_BN_EXPAND2: u32 = 108;
pub const BN_F_BN_EXPAND_INTERNAL: u32 = 120;
pub const BN_F_BN_GF2M_MOD: u32 = 131;
pub const BN_F_BN_GF2M_MOD_EXP: u32 = 132;
pub const BN_F_BN_GF2M_MOD_MUL: u32 = 133;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD: u32 = 134;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR: u32 = 135;
pub const BN_F_BN_GF2M_MOD_SQR: u32 = 136;
pub const BN_F_BN_GF2M_MOD_SQRT: u32 = 137;
pub const BN_F_BN_LSHIFT: u32 = 145;
pub const BN_F_BN_MOD_EXP2_MONT: u32 = 118;
pub const BN_F_BN_MOD_EXP_MONT: u32 = 109;
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME: u32 = 124;
pub const BN_F_BN_MOD_EXP_MONT_WORD: u32 = 117;
pub const BN_F_BN_MOD_EXP_RECP: u32 = 125;
pub const BN_F_BN_MOD_EXP_SIMPLE: u32 = 126;
pub const BN_F_BN_MOD_INVERSE: u32 = 110;
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH: u32 = 139;
pub const BN_F_BN_MOD_LSHIFT_QUICK: u32 = 119;
pub const BN_F_BN_MOD_MUL_RECIPROCAL: u32 = 111;
pub const BN_F_BN_MOD_SQRT: u32 = 121;
pub const BN_F_BN_MPI2BN: u32 = 112;
pub const BN_F_BN_NEW: u32 = 113;
pub const BN_F_BN_RAND: u32 = 114;
pub const BN_F_BN_RAND_RANGE: u32 = 122;
pub const BN_F_BN_RSHIFT: u32 = 146;
pub const BN_F_BN_USUB: u32 = 115;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 114;
pub const BN_R_BITS_TOO_SMALL: u32 = 118;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 102;
pub const BN_R_DIV_BY_ZERO: u32 = 103;
pub const BN_R_ENCODING_ERROR: u32 = 104;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 105;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 110;
pub const BN_R_INVALID_LENGTH: u32 = 106;
pub const BN_R_INVALID_RANGE: u32 = 115;
pub const BN_R_INVALID_SHIFT: u32 = 119;
pub const BN_R_NOT_A_SQUARE: u32 = 111;
pub const BN_R_NOT_INITIALIZED: u32 = 107;
pub const BN_R_NO_INVERSE: u32 = 108;
pub const BN_R_NO_SOLUTION: u32 = 116;
pub const BN_R_P_IS_NOT_PRIME: u32 = 112;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 113;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 109;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_PRIMATIVE_TAG: u32 = 31;
pub const V_ASN1_APP_CHOOSE: i32 = -2;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const MBSTRING_FLAG: u32 = 4096;
pub const MBSTRING_UTF8: u32 = 4096;
pub const MBSTRING_ASC: u32 = 4097;
pub const MBSTRING_BMP: u32 = 4098;
pub const MBSTRING_UNIV: u32 = 4100;
pub const SMIME_OLDMIME: u32 = 1024;
pub const SMIME_CRLFEOL: u32 = 2048;
pub const SMIME_STREAM: u32 = 4096;
pub const ASN1_OBJECT_FLAG_DYNAMIC: u32 = 1;
pub const ASN1_OBJECT_FLAG_CRITICAL: u32 = 2;
pub const ASN1_OBJECT_FLAG_DYNAMIC_STRINGS: u32 = 4;
pub const ASN1_OBJECT_FLAG_DYNAMIC_DATA: u32 = 8;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const ASN1_STRING_FLAG_NDEF: u32 = 16;
pub const ASN1_STRING_FLAG_CONT: u32 = 32;
pub const ASN1_STRING_FLAG_MSTRING: u32 = 64;
pub const ASN1_LONG_UNDEF: u32 = 2147483647;
pub const STABLE_FLAGS_MALLOC: u32 = 1;
pub const STABLE_NO_MASK: u32 = 2;
pub const DIRSTRING_TYPE: u32 = 10246;
pub const PKCS9STRING_TYPE: u32 = 10262;
pub const ub_name: u32 = 32768;
pub const ub_common_name: u32 = 64;
pub const ub_locality_name: u32 = 128;
pub const ub_state_name: u32 = 128;
pub const ub_organization_name: u32 = 64;
pub const ub_organization_unit_name: u32 = 64;
pub const ub_title: u32 = 64;
pub const ub_email_address: u32 = 128;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const CHARTYPE_PRINTABLESTRING: u32 = 16;
pub const CHARTYPE_FIRST_ESC_2253: u32 = 32;
pub const CHARTYPE_LAST_ESC_2253: u32 = 64;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_TIME: u32 = 49152;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const IS_SEQUENCE: u32 = 0;
pub const IS_SET: u32 = 1;
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT: u32 = 1;
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE: u32 = 2;
pub const ASN1_PCTX_FLAGS_SHOW_SSOF: u32 = 4;
pub const ASN1_PCTX_FLAGS_SHOW_TYPE: u32 = 8;
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE: u32 = 16;
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE: u32 = 32;
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME: u32 = 64;
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME: u32 = 128;
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME: u32 = 256;
pub const ASN1_F_A2D_ASN1_OBJECT: u32 = 100;
pub const ASN1_F_A2I_ASN1_ENUMERATED: u32 = 101;
pub const ASN1_F_A2I_ASN1_INTEGER: u32 = 102;
pub const ASN1_F_A2I_ASN1_STRING: u32 = 103;
pub const ASN1_F_APPEND_EXP: u32 = 176;
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT: u32 = 183;
pub const ASN1_F_ASN1_CB: u32 = 177;
pub const ASN1_F_ASN1_CHECK_TLEN: u32 = 104;
pub const ASN1_F_ASN1_COLLATE_PRIMITIVE: u32 = 105;
pub const ASN1_F_ASN1_COLLECT: u32 = 106;
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE: u32 = 108;
pub const ASN1_F_ASN1_D2I_FP: u32 = 109;
pub const ASN1_F_ASN1_D2I_READ_BIO: u32 = 107;
pub const ASN1_F_ASN1_DIGEST: u32 = 184;
pub const ASN1_F_ASN1_DO_ADB: u32 = 110;
pub const ASN1_F_ASN1_DUP: u32 = 111;
pub const ASN1_F_ASN1_ENUMERATED_SET: u32 = 112;
pub const ASN1_F_ASN1_ENUMERATED_TO_BN: u32 = 113;
pub const ASN1_F_ASN1_EX_C2I: u32 = 204;
pub const ASN1_F_ASN1_FIND_END: u32 = 190;
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ: u32 = 216;
pub const ASN1_F_ASN1_GENERALIZEDTIME_SET: u32 = 185;
pub const ASN1_F_ASN1_GENERATE_V3: u32 = 178;
pub const ASN1_F_ASN1_GET_OBJECT: u32 = 114;
pub const ASN1_F_ASN1_HEADER_NEW: u32 = 115;
pub const ASN1_F_ASN1_I2D_BIO: u32 = 116;
pub const ASN1_F_ASN1_I2D_FP: u32 = 117;
pub const ASN1_F_ASN1_INTEGER_SET: u32 = 118;
pub const ASN1_F_ASN1_INTEGER_TO_BN: u32 = 119;
pub const ASN1_F_ASN1_ITEM_D2I_FP: u32 = 206;
pub const ASN1_F_ASN1_ITEM_DUP: u32 = 191;
pub const ASN1_F_ASN1_ITEM_EX_COMBINE_NEW: u32 = 121;
pub const ASN1_F_ASN1_ITEM_EX_D2I: u32 = 120;
pub const ASN1_F_ASN1_ITEM_I2D_BIO: u32 = 192;
pub const ASN1_F_ASN1_ITEM_I2D_FP: u32 = 193;
pub const ASN1_F_ASN1_ITEM_PACK: u32 = 198;
pub const ASN1_F_ASN1_ITEM_SIGN: u32 = 195;
pub const ASN1_F_ASN1_ITEM_SIGN_CTX: u32 = 220;
pub const ASN1_F_ASN1_ITEM_UNPACK: u32 = 199;
pub const ASN1_F_ASN1_ITEM_VERIFY: u32 = 197;
pub const ASN1_F_ASN1_MBSTRING_NCOPY: u32 = 122;
pub const ASN1_F_ASN1_OBJECT_NEW: u32 = 123;
pub const ASN1_F_ASN1_OUTPUT_DATA: u32 = 214;
pub const ASN1_F_ASN1_PACK_STRING: u32 = 124;
pub const ASN1_F_ASN1_PCTX_NEW: u32 = 205;
pub const ASN1_F_ASN1_PKCS5_PBE_SET: u32 = 125;
pub const ASN1_F_ASN1_SEQ_PACK: u32 = 126;
pub const ASN1_F_ASN1_SEQ_UNPACK: u32 = 127;
pub const ASN1_F_ASN1_SIGN: u32 = 128;
pub const ASN1_F_ASN1_STR2TYPE: u32 = 179;
pub const ASN1_F_ASN1_STRING_SET: u32 = 186;
pub const ASN1_F_ASN1_STRING_TABLE_ADD: u32 = 129;
pub const ASN1_F_ASN1_STRING_TYPE_NEW: u32 = 130;
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I: u32 = 132;
pub const ASN1_F_ASN1_TEMPLATE_NEW: u32 = 133;
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I: u32 = 131;
pub const ASN1_F_ASN1_TIME_ADJ: u32 = 217;
pub const ASN1_F_ASN1_TIME_SET: u32 = 175;
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING: u32 = 134;
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING: u32 = 135;
pub const ASN1_F_ASN1_UNPACK_STRING: u32 = 136;
pub const ASN1_F_ASN1_UTCTIME_ADJ: u32 = 218;
pub const ASN1_F_ASN1_UTCTIME_SET: u32 = 187;
pub const ASN1_F_ASN1_VERIFY: u32 = 137;
pub const ASN1_F_B64_READ_ASN1: u32 = 209;
pub const ASN1_F_B64_WRITE_ASN1: u32 = 210;
pub const ASN1_F_BIO_NEW_NDEF: u32 = 208;
pub const ASN1_F_BITSTR_CB: u32 = 180;
pub const ASN1_F_BN_TO_ASN1_ENUMERATED: u32 = 138;
pub const ASN1_F_BN_TO_ASN1_INTEGER: u32 = 139;
pub const ASN1_F_C2I_ASN1_BIT_STRING: u32 = 189;
pub const ASN1_F_C2I_ASN1_INTEGER: u32 = 194;
pub const ASN1_F_C2I_ASN1_OBJECT: u32 = 196;
pub const ASN1_F_COLLECT_DATA: u32 = 140;
pub const ASN1_F_D2I_ASN1_BIT_STRING: u32 = 141;
pub const ASN1_F_D2I_ASN1_BOOLEAN: u32 = 142;
pub const ASN1_F_D2I_ASN1_BYTES: u32 = 143;
pub const ASN1_F_D2I_ASN1_GENERALIZEDTIME: u32 = 144;
pub const ASN1_F_D2I_ASN1_HEADER: u32 = 145;
pub const ASN1_F_D2I_ASN1_INTEGER: u32 = 146;
pub const ASN1_F_D2I_ASN1_OBJECT: u32 = 147;
pub const ASN1_F_D2I_ASN1_SET: u32 = 148;
pub const ASN1_F_D2I_ASN1_TYPE_BYTES: u32 = 149;
pub const ASN1_F_D2I_ASN1_UINTEGER: u32 = 150;
pub const ASN1_F_D2I_ASN1_UTCTIME: u32 = 151;
pub const ASN1_F_D2I_AUTOPRIVATEKEY: u32 = 207;
pub const ASN1_F_D2I_NETSCAPE_RSA: u32 = 152;
pub const ASN1_F_D2I_NETSCAPE_RSA_2: u32 = 153;
pub const ASN1_F_D2I_PRIVATEKEY: u32 = 154;
pub const ASN1_F_D2I_PUBLICKEY: u32 = 155;
pub const ASN1_F_D2I_RSA_NET: u32 = 200;
pub const ASN1_F_D2I_RSA_NET_2: u32 = 201;
pub const ASN1_F_D2I_X509: u32 = 156;
pub const ASN1_F_D2I_X509_CINF: u32 = 157;
pub const ASN1_F_D2I_X509_PKEY: u32 = 159;
pub const ASN1_F_DO_BUF: u32 = 221;
pub const ASN1_F_I2D_ASN1_BIO_STREAM: u32 = 211;
pub const ASN1_F_I2D_ASN1_BOOLEAN: u32 = 223;
pub const ASN1_F_I2D_ASN1_OBJECT: u32 = 222;
pub const ASN1_F_I2D_ASN1_SET: u32 = 188;
pub const ASN1_F_I2D_ASN1_TIME: u32 = 160;
pub const ASN1_F_I2D_DSA_PUBKEY: u32 = 161;
pub const ASN1_F_I2D_EC_PUBKEY: u32 = 181;
pub const ASN1_F_I2D_PRIVATEKEY: u32 = 163;
pub const ASN1_F_I2D_PUBLICKEY: u32 = 164;
pub const ASN1_F_I2D_RSA_NET: u32 = 162;
pub const ASN1_F_I2D_RSA_PUBKEY: u32 = 165;
pub const ASN1_F_LONG_C2I: u32 = 166;
pub const ASN1_F_OID_MODULE_INIT: u32 = 174;
pub const ASN1_F_PARSE_TAGGING: u32 = 182;
pub const ASN1_F_PKCS5_PBE2_SET_IV: u32 = 167;
pub const ASN1_F_PKCS5_PBE_SET: u32 = 202;
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR: u32 = 215;
pub const ASN1_F_PKCS5_PBKDF2_SET: u32 = 219;
pub const ASN1_F_SMIME_READ_ASN1: u32 = 212;
pub const ASN1_F_SMIME_TEXT: u32 = 213;
pub const ASN1_F_X509_CINF_NEW: u32 = 168;
pub const ASN1_F_X509_CRL_ADD0_REVOKED: u32 = 169;
pub const ASN1_F_X509_INFO_NEW: u32 = 170;
pub const ASN1_F_X509_NAME_ENCODE: u32 = 203;
pub const ASN1_F_X509_NAME_EX_D2I: u32 = 158;
pub const ASN1_F_X509_NAME_EX_NEW: u32 = 171;
pub const ASN1_F_X509_NEW: u32 = 172;
pub const ASN1_F_X509_PKEY_NEW: u32 = 173;
pub const ASN1_R_ADDING_OBJECT: u32 = 171;
pub const ASN1_R_ASN1_PARSE_ERROR: u32 = 203;
pub const ASN1_R_ASN1_SIG_PARSE_ERROR: u32 = 204;
pub const ASN1_R_AUX_ERROR: u32 = 100;
pub const ASN1_R_BAD_CLASS: u32 = 101;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 102;
pub const ASN1_R_BAD_PASSWORD_READ: u32 = 103;
pub const ASN1_R_BAD_TAG: u32 = 104;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 214;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 108;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 217;
pub const ASN1_R_DATA_IS_WRONG: u32 = 109;
pub const ASN1_R_DECODE_ERROR: u32 = 110;
pub const ASN1_R_DECODING_ERROR: u32 = 111;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 174;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 198;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 173;
pub const ASN1_R_ERROR_LOADING_SECTION: u32 = 172;
pub const ASN1_R_ERROR_PARSING_SET_ELEMENT: u32 = 113;
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPECTING_A_BOOLEAN: u32 = 117;
pub const ASN1_R_EXPECTING_A_TIME: u32 = 118;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 175;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 176;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 124;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 177;
pub const ASN1_R_ILLEGAL_HEX: u32 = 178;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 179;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 180;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 181;
pub const ASN1_R_ILLEGAL_NULL: u32 = 125;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 182;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 183;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 126;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 170;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 127;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 184;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 185;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 128;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 220;
pub const ASN1_R_INVALID_BMPSTRING_LENGTH: u32 = 129;
pub const ASN1_R_INVALID_DIGIT: u32 = 130;
pub const ASN1_R_INVALID_MIME_TYPE: u32 = 205;
pub const ASN1_R_INVALID_MODIFIER: u32 = 186;
pub const ASN1_R_INVALID_NUMBER: u32 = 187;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 216;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 131;
pub const ASN1_R_INVALID_TIME_FORMAT: u32 = 132;
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH: u32 = 133;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 134;
pub const ASN1_R_IV_TOO_LARGE: u32 = 135;
pub const ASN1_R_LENGTH_ERROR: u32 = 136;
pub const ASN1_R_LIST_ERROR: u32 = 188;
pub const ASN1_R_MIME_NO_CONTENT_TYPE: u32 = 206;
pub const ASN1_R_MIME_PARSE_ERROR: u32 = 207;
pub const ASN1_R_MIME_SIG_PARSE_ERROR: u32 = 208;
pub const ASN1_R_MISSING_EOC: u32 = 137;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 138;
pub const ASN1_R_MISSING_VALUE: u32 = 189;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 139;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 140;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 197;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 219;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 141;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 190;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 142;
pub const ASN1_R_NO_CONTENT_TYPE: u32 = 209;
pub const ASN1_R_NO_DEFAULT_DIGEST: u32 = 201;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 143;
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE: u32 = 210;
pub const ASN1_R_NO_MULTIPART_BOUNDARY: u32 = 211;
pub const ASN1_R_NO_SIG_CONTENT_TYPE: u32 = 212;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 144;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 191;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 145;
pub const ASN1_R_PRIVATE_KEY_HEADER_MISSING: u32 = 146;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 147;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 148;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 149;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 192;
pub const ASN1_R_SHORT_LINE: u32 = 150;
pub const ASN1_R_SIG_INVALID_MIME_TYPE: u32 = 213;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 202;
pub const ASN1_R_STRING_TOO_LONG: u32 = 151;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 152;
pub const ASN1_R_TAG_VALUE_TOO_HIGH: u32 = 153;
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 154;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 193;
pub const ASN1_R_TOO_LONG: u32 = 155;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 156;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 218;
pub const ASN1_R_UNABLE_TO_DECODE_RSA_KEY: u32 = 157;
pub const ASN1_R_UNABLE_TO_DECODE_RSA_PRIVATE_KEY: u32 = 158;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 159;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 215;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 160;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 161;
pub const ASN1_R_UNKNOWN_OBJECT_TYPE: u32 = 162;
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 163;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 199;
pub const ASN1_R_UNKNOWN_TAG: u32 = 194;
pub const ASN1_R_UNKOWN_FORMAT: u32 = 195;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 164;
pub const ASN1_R_UNSUPPORTED_CIPHER: u32 = 165;
pub const ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM: u32 = 166;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 167;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 196;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 200;
pub const ASN1_R_WRONG_TAG: u32 = 168;
pub const ASN1_R_WRONG_TYPE: u32 = 169;
pub const OBJ_NAME_TYPE_UNDEF: u32 = 0;
pub const OBJ_NAME_TYPE_MD_METH: u32 = 1;
pub const OBJ_NAME_TYPE_CIPHER_METH: u32 = 2;
pub const OBJ_NAME_TYPE_PKEY_METH: u32 = 3;
pub const OBJ_NAME_TYPE_COMP_METH: u32 = 4;
pub const OBJ_NAME_TYPE_NUM: u32 = 5;
pub const OBJ_NAME_ALIAS: u32 = 32768;
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH: u32 = 1;
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH: u32 = 2;
pub const OBJ_F_OBJ_ADD_OBJECT: u32 = 105;
pub const OBJ_F_OBJ_CREATE: u32 = 100;
pub const OBJ_F_OBJ_DUP: u32 = 101;
pub const OBJ_F_OBJ_NAME_NEW_INDEX: u32 = 106;
pub const OBJ_F_OBJ_NID2LN: u32 = 102;
pub const OBJ_F_OBJ_NID2OBJ: u32 = 103;
pub const OBJ_F_OBJ_NID2SN: u32 = 104;
pub const OBJ_R_MALLOC_FAILURE: u32 = 100;
pub const OBJ_R_UNKNOWN_NID: u32 = 101;
pub const EVP_PK_RSA: u32 = 1;
pub const EVP_PK_DSA: u32 = 2;
pub const EVP_PK_DH: u32 = 4;
pub const EVP_PK_EC: u32 = 8;
pub const EVP_PKT_SIGN: u32 = 16;
pub const EVP_PKT_ENC: u32 = 32;
pub const EVP_PKT_EXCH: u32 = 64;
pub const EVP_PKS_RSA: u32 = 256;
pub const EVP_PKS_DSA: u32 = 512;
pub const EVP_PKS_EC: u32 = 1024;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_DSA1: u32 = 67;
pub const EVP_PKEY_DSA2: u32 = 66;
pub const EVP_PKEY_DSA3: u32 = 113;
pub const EVP_PKEY_DSA4: u32 = 70;
pub const EVP_PKEY_DH: u32 = 28;
pub const EVP_PKEY_DHX: u32 = 920;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_HMAC: u32 = 855;
pub const EVP_PKEY_CMAC: u32 = 894;
pub const EVP_PKEY_MO_SIGN: u32 = 1;
pub const EVP_PKEY_MO_VERIFY: u32 = 2;
pub const EVP_PKEY_MO_ENCRYPT: u32 = 4;
pub const EVP_PKEY_MO_DECRYPT: u32 = 8;
pub const EVP_MD_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_FLAG_PKEY_DIGEST: u32 = 2;
pub const EVP_MD_FLAG_PKEY_METHOD_SIGNATURE: u32 = 4;
pub const EVP_MD_FLAG_DIGALGID_MASK: u32 = 24;
pub const EVP_MD_FLAG_DIGALGID_NULL: u32 = 0;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 8;
pub const EVP_MD_FLAG_DIGALGID_CUSTOM: u32 = 24;
pub const EVP_MD_FLAG_FIPS: u32 = 1024;
pub const EVP_MD_CTRL_DIGALGID: u32 = 1;
pub const EVP_MD_CTRL_MICALG: u32 = 2;
pub const EVP_MD_CTRL_ALG_CTRL: u32 = 4096;
pub const EVP_MD_CTX_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_CTX_FLAG_CLEANED: u32 = 2;
pub const EVP_MD_CTX_FLAG_REUSE: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 8;
pub const EVP_MD_CTX_FLAG_PAD_MASK: u32 = 240;
pub const EVP_MD_CTX_FLAG_PAD_PKCS1: u32 = 0;
pub const EVP_MD_CTX_FLAG_PAD_X931: u32 = 16;
pub const EVP_MD_CTX_FLAG_PAD_PSS: u32 = 32;
pub const EVP_MD_CTX_FLAG_NO_INIT: u32 = 256;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_CCM_MODE: u32 = 7;
pub const EVP_CIPH_XTS_MODE: u32 = 65537;
pub const EVP_CIPH_WRAP_MODE: u32 = 65538;
pub const EVP_CIPH_MODE: u32 = 983047;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 8;
pub const EVP_CIPH_CUSTOM_IV: u32 = 16;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 32;
pub const EVP_CIPH_CTRL_INIT: u32 = 64;
pub const EVP_CIPH_CUSTOM_KEY_LENGTH: u32 = 128;
pub const EVP_CIPH_NO_PADDING: u32 = 256;
pub const EVP_CIPH_RAND_KEY: u32 = 512;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 1024;
pub const EVP_CIPH_FLAG_DEFAULT_ASN1: u32 = 4096;
pub const EVP_CIPH_FLAG_LENGTH_BITS: u32 = 8192;
pub const EVP_CIPH_FLAG_FIPS: u32 = 16384;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 32768;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1048576;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2097152;
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK: u32 = 4194304;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 1;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_CCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_CCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_CCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_CCM_SET_L: u32 = 20;
pub const EVP_CTRL_CCM_SET_MSGLEN: u32 = 21;
pub const EVP_CTRL_AEAD_TLS1_AAD: u32 = 22;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD: u32 = 25;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT: u32 = 26;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT: u32 = 27;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE: u32 = 28;
pub const EVP_AEAD_TLS1_AAD_LEN: u32 = 13;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_PBE_TYPE_OUTER: u32 = 0;
pub const EVP_PBE_TYPE_PRF: u32 = 1;
pub const ASN1_PKEY_ALIAS: u32 = 1;
pub const ASN1_PKEY_DYNAMIC: u32 = 2;
pub const ASN1_PKEY_SIGPARAM_NULL: u32 = 4;
pub const ASN1_PKEY_CTRL_PKCS7_SIGN: u32 = 1;
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 2;
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID: u32 = 3;
pub const ASN1_PKEY_CTRL_CMS_SIGN: u32 = 5;
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE: u32 = 7;
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE: u32 = 8;
pub const EVP_PKEY_OP_UNDEFINED: u32 = 0;
pub const EVP_PKEY_OP_PARAMGEN: u32 = 2;
pub const EVP_PKEY_OP_KEYGEN: u32 = 4;
pub const EVP_PKEY_OP_SIGN: u32 = 8;
pub const EVP_PKEY_OP_VERIFY: u32 = 16;
pub const EVP_PKEY_OP_VERIFYRECOVER: u32 = 32;
pub const EVP_PKEY_OP_SIGNCTX: u32 = 64;
pub const EVP_PKEY_OP_VERIFYCTX: u32 = 128;
pub const EVP_PKEY_OP_ENCRYPT: u32 = 256;
pub const EVP_PKEY_OP_DECRYPT: u32 = 512;
pub const EVP_PKEY_OP_DERIVE: u32 = 1024;
pub const EVP_PKEY_OP_TYPE_SIG: u32 = 248;
pub const EVP_PKEY_OP_TYPE_CRYPT: u32 = 768;
pub const EVP_PKEY_OP_TYPE_GEN: u32 = 6;
pub const EVP_PKEY_CTRL_MD: u32 = 1;
pub const EVP_PKEY_CTRL_PEER_KEY: u32 = 2;
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 3;
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT: u32 = 4;
pub const EVP_PKEY_CTRL_PKCS7_SIGN: u32 = 5;
pub const EVP_PKEY_CTRL_SET_MAC_KEY: u32 = 6;
pub const EVP_PKEY_CTRL_DIGESTINIT: u32 = 7;
pub const EVP_PKEY_CTRL_SET_IV: u32 = 8;
pub const EVP_PKEY_CTRL_CMS_ENCRYPT: u32 = 9;
pub const EVP_PKEY_CTRL_CMS_DECRYPT: u32 = 10;
pub const EVP_PKEY_CTRL_CMS_SIGN: u32 = 11;
pub const EVP_PKEY_CTRL_CIPHER: u32 = 12;
pub const EVP_PKEY_CTRL_GET_MD: u32 = 13;
pub const EVP_PKEY_ALG_CTRL: u32 = 4096;
pub const EVP_PKEY_FLAG_AUTOARGLEN: u32 = 2;
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM: u32 = 4;
pub const EVP_F_AESNI_INIT_KEY: u32 = 165;
pub const EVP_F_AESNI_XTS_CIPHER: u32 = 176;
pub const EVP_F_AES_INIT_KEY: u32 = 133;
pub const EVP_F_AES_T4_INIT_KEY: u32 = 178;
pub const EVP_F_AES_XTS: u32 = 172;
pub const EVP_F_AES_XTS_CIPHER: u32 = 175;
pub const EVP_F_ALG_MODULE_INIT: u32 = 177;
pub const EVP_F_CAMELLIA_INIT_KEY: u32 = 159;
pub const EVP_F_CMAC_INIT: u32 = 173;
pub const EVP_F_CMLL_T4_INIT_KEY: u32 = 179;
pub const EVP_F_D2I_PKEY: u32 = 100;
pub const EVP_F_DO_SIGVER_INIT: u32 = 161;
pub const EVP_F_DSAPKEY2PKCS8: u32 = 134;
pub const EVP_F_DSA_PKEY2PKCS8: u32 = 135;
pub const EVP_F_ECDSA_PKEY2PKCS8: u32 = 129;
pub const EVP_F_ECKEY_PKEY2PKCS8: u32 = 132;
pub const EVP_F_EVP_CIPHERINIT_EX: u32 = 123;
pub const EVP_F_EVP_CIPHER_CTX_COPY: u32 = 163;
pub const EVP_F_EVP_CIPHER_CTX_CTRL: u32 = 124;
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH: u32 = 122;
pub const EVP_F_EVP_DECRYPTFINAL_EX: u32 = 101;
pub const EVP_F_EVP_DIGESTINIT_EX: u32 = 128;
pub const EVP_F_EVP_ENCRYPTFINAL_EX: u32 = 127;
pub const EVP_F_EVP_MD_CTX_COPY_EX: u32 = 110;
pub const EVP_F_EVP_MD_SIZE: u32 = 162;
pub const EVP_F_EVP_OPENINIT: u32 = 102;
pub const EVP_F_EVP_PBE_ALG_ADD: u32 = 115;
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE: u32 = 160;
pub const EVP_F_EVP_PBE_CIPHERINIT: u32 = 116;
pub const EVP_F_EVP_PKCS82PKEY: u32 = 111;
pub const EVP_F_EVP_PKCS82PKEY_BROKEN: u32 = 136;
pub const EVP_F_EVP_PKEY2PKCS8_BROKEN: u32 = 113;
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS: u32 = 103;
pub const EVP_F_EVP_PKEY_CTX_CTRL: u32 = 137;
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR: u32 = 150;
pub const EVP_F_EVP_PKEY_CTX_DUP: u32 = 156;
pub const EVP_F_EVP_PKEY_DECRYPT: u32 = 104;
pub const EVP_F_EVP_PKEY_DECRYPT_INIT: u32 = 138;
pub const EVP_F_EVP_PKEY_DECRYPT_OLD: u32 = 151;
pub const EVP_F_EVP_PKEY_DERIVE: u32 = 153;
pub const EVP_F_EVP_PKEY_DERIVE_INIT: u32 = 154;
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER: u32 = 155;
pub const EVP_F_EVP_PKEY_ENCRYPT: u32 = 105;
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT: u32 = 139;
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD: u32 = 152;
pub const EVP_F_EVP_PKEY_GET1_DH: u32 = 119;
pub const EVP_F_EVP_PKEY_GET1_DSA: u32 = 120;
pub const EVP_F_EVP_PKEY_GET1_ECDSA: u32 = 130;
pub const EVP_F_EVP_PKEY_GET1_EC_KEY: u32 = 131;
pub const EVP_F_EVP_PKEY_GET1_RSA: u32 = 121;
pub const EVP_F_EVP_PKEY_KEYGEN: u32 = 146;
pub const EVP_F_EVP_PKEY_KEYGEN_INIT: u32 = 147;
pub const EVP_F_EVP_PKEY_NEW: u32 = 106;
pub const EVP_F_EVP_PKEY_PARAMGEN: u32 = 148;
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT: u32 = 149;
pub const EVP_F_EVP_PKEY_SIGN: u32 = 140;
pub const EVP_F_EVP_PKEY_SIGN_INIT: u32 = 141;
pub const EVP_F_EVP_PKEY_VERIFY: u32 = 142;
pub const EVP_F_EVP_PKEY_VERIFY_INIT: u32 = 143;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER: u32 = 144;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT: u32 = 145;
pub const EVP_F_EVP_RIJNDAEL: u32 = 126;
pub const EVP_F_EVP_SIGNFINAL: u32 = 107;
pub const EVP_F_EVP_VERIFYFINAL: u32 = 108;
pub const EVP_F_FIPS_CIPHERINIT: u32 = 166;
pub const EVP_F_FIPS_CIPHER_CTX_COPY: u32 = 170;
pub const EVP_F_FIPS_CIPHER_CTX_CTRL: u32 = 167;
pub const EVP_F_FIPS_CIPHER_CTX_SET_KEY_LENGTH: u32 = 171;
pub const EVP_F_FIPS_DIGESTINIT: u32 = 168;
pub const EVP_F_FIPS_MD_CTX_COPY: u32 = 169;
pub const EVP_F_HMAC_INIT_EX: u32 = 174;
pub const EVP_F_INT_CTX_NEW: u32 = 157;
pub const EVP_F_PKCS5_PBE_KEYIVGEN: u32 = 117;
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN: u32 = 118;
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN: u32 = 164;
pub const EVP_F_PKCS8_SET_BROKEN: u32 = 112;
pub const EVP_F_PKEY_SET_TYPE: u32 = 158;
pub const EVP_F_RC2_MAGIC_TO_METH: u32 = 109;
pub const EVP_F_RC5_CTRL: u32 = 125;
pub const EVP_R_AES_IV_SETUP_FAILED: u32 = 162;
pub const EVP_R_AES_KEY_SETUP_FAILED: u32 = 143;
pub const EVP_R_ASN1_LIB: u32 = 140;
pub const EVP_R_BAD_BLOCK_LENGTH: u32 = 136;
pub const EVP_R_BAD_DECRYPT: u32 = 100;
pub const EVP_R_BAD_KEY_LENGTH: u32 = 137;
pub const EVP_R_BN_DECODE_ERROR: u32 = 112;
pub const EVP_R_BN_PUBKEY_ERROR: u32 = 113;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 155;
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED: u32 = 157;
pub const EVP_R_CIPHER_PARAMETER_ERROR: u32 = 122;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 147;
pub const EVP_R_CTRL_NOT_IMPLEMENTED: u32 = 132;
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 133;
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 138;
pub const EVP_R_DECODE_ERROR: u32 = 114;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 101;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 153;
pub const EVP_R_DISABLED_FOR_FIPS: u32 = 163;
pub const EVP_R_ENCODE_ERROR: u32 = 115;
pub const EVP_R_ERROR_LOADING_SECTION: u32 = 165;
pub const EVP_R_ERROR_SETTING_FIPS_MODE: u32 = 166;
pub const EVP_R_EVP_PBE_CIPHERINIT_ERROR: u32 = 119;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 127;
pub const EVP_R_EXPECTING_A_DH_KEY: u32 = 128;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 129;
pub const EVP_R_EXPECTING_A_ECDSA_KEY: u32 = 141;
pub const EVP_R_EXPECTING_A_EC_KEY: u32 = 142;
pub const EVP_R_FIPS_MODE_NOT_SUPPORTED: u32 = 167;
pub const EVP_R_INITIALIZATION_ERROR: u32 = 134;
pub const EVP_R_INPUT_NOT_INITIALIZED: u32 = 111;
pub const EVP_R_INVALID_DIGEST: u32 = 152;
pub const EVP_R_INVALID_FIPS_MODE: u32 = 168;
pub const EVP_R_INVALID_KEY: u32 = 171;
pub const EVP_R_INVALID_KEY_LENGTH: u32 = 130;
pub const EVP_R_INVALID_OPERATION: u32 = 148;
pub const EVP_R_IV_TOO_LARGE: u32 = 102;
pub const EVP_R_KEYGEN_FAILURE: u32 = 120;
pub const EVP_R_MESSAGE_DIGEST_IS_NULL: u32 = 159;
pub const EVP_R_METHOD_NOT_SUPPORTED: u32 = 144;
pub const EVP_R_MISSING_PARAMETERS: u32 = 103;
pub const EVP_R_NO_CIPHER_SET: u32 = 131;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 158;
pub const EVP_R_NO_DIGEST_SET: u32 = 139;
pub const EVP_R_NO_DSA_PARAMETERS: u32 = 116;
pub const EVP_R_NO_KEY_SET: u32 = 154;
pub const EVP_R_NO_OPERATION_SET: u32 = 149;
pub const EVP_R_NO_SIGN_FUNCTION_CONFIGURED: u32 = 104;
pub const EVP_R_NO_VERIFY_FUNCTION_CONFIGURED: u32 = 105;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 150;
pub const EVP_R_OPERATON_NOT_INITIALIZED: u32 = 151;
pub const EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE: u32 = 117;
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR: u32 = 145;
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR: u32 = 146;
pub const EVP_R_PUBLIC_KEY_NOT_RSA: u32 = 106;
pub const EVP_R_TOO_LARGE: u32 = 164;
pub const EVP_R_UNKNOWN_CIPHER: u32 = 160;
pub const EVP_R_UNKNOWN_DIGEST: u32 = 161;
pub const EVP_R_UNKNOWN_OPTION: u32 = 169;
pub const EVP_R_UNKNOWN_PBE_ALGORITHM: u32 = 121;
pub const EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS: u32 = 135;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 156;
pub const EVP_R_UNSUPPORTED_CIPHER: u32 = 107;
pub const EVP_R_UNSUPPORTED_KEYLENGTH: u32 = 123;
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION: u32 = 124;
pub const EVP_R_UNSUPPORTED_KEY_SIZE: u32 = 108;
pub const EVP_R_UNSUPPORTED_PRF: u32 = 125;
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM: u32 = 118;
pub const EVP_R_UNSUPPORTED_SALT_TYPE: u32 = 126;
pub const EVP_R_WRAP_MODE_NOT_ALLOWED: u32 = 170;
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 109;
pub const EVP_R_WRONG_PUBLIC_KEY_TYPE: u32 = 110;
pub const OPENSSL_ECC_MAX_FIELD_BITS: u32 = 661;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const EC_FLAG_NON_FIPS_ALLOW: u32 = 1;
pub const EC_FLAG_FIPS_CHECKED: u32 = 2;
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID: u32 = 4097;
pub const EVP_PKEY_CTRL_EC_PARAM_ENC: u32 = 4098;
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR: u32 = 4099;
pub const EVP_PKEY_CTRL_EC_KDF_TYPE: u32 = 4100;
pub const EVP_PKEY_CTRL_EC_KDF_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD: u32 = 4102;
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN: u32 = 4104;
pub const EVP_PKEY_CTRL_EC_KDF_UKM: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM: u32 = 4106;
pub const EVP_PKEY_ECDH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_ECDH_KDF_X9_62: u32 = 2;
pub const EC_F_BN_TO_FELEM: u32 = 224;
pub const EC_F_COMPUTE_WNAF: u32 = 143;
pub const EC_F_D2I_ECPARAMETERS: u32 = 144;
pub const EC_F_D2I_ECPKPARAMETERS: u32 = 145;
pub const EC_F_D2I_ECPRIVATEKEY: u32 = 146;
pub const EC_F_DO_EC_KEY_PRINT: u32 = 221;
pub const EC_F_ECDH_CMS_DECRYPT: u32 = 238;
pub const EC_F_ECDH_CMS_SET_SHARED_INFO: u32 = 239;
pub const EC_F_ECKEY_PARAM2TYPE: u32 = 223;
pub const EC_F_ECKEY_PARAM_DECODE: u32 = 212;
pub const EC_F_ECKEY_PRIV_DECODE: u32 = 213;
pub const EC_F_ECKEY_PRIV_ENCODE: u32 = 214;
pub const EC_F_ECKEY_PUB_DECODE: u32 = 215;
pub const EC_F_ECKEY_PUB_ENCODE: u32 = 216;
pub const EC_F_ECKEY_TYPE2PARAM: u32 = 220;
pub const EC_F_ECPARAMETERS_PRINT: u32 = 147;
pub const EC_F_ECPARAMETERS_PRINT_FP: u32 = 148;
pub const EC_F_ECPKPARAMETERS_PRINT: u32 = 149;
pub const EC_F_ECPKPARAMETERS_PRINT_FP: u32 = 150;
pub const EC_F_ECP_NISTZ256_GET_AFFINE: u32 = 240;
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE: u32 = 243;
pub const EC_F_ECP_NISTZ256_POINTS_MUL: u32 = 241;
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW: u32 = 244;
pub const EC_F_ECP_NISTZ256_SET_WORDS: u32 = 245;
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL: u32 = 242;
pub const EC_F_ECP_NIST_MOD_192: u32 = 203;
pub const EC_F_ECP_NIST_MOD_224: u32 = 204;
pub const EC_F_ECP_NIST_MOD_256: u32 = 205;
pub const EC_F_ECP_NIST_MOD_521: u32 = 206;
pub const EC_F_EC_ASN1_GROUP2CURVE: u32 = 153;
pub const EC_F_EC_ASN1_GROUP2FIELDID: u32 = 154;
pub const EC_F_EC_ASN1_GROUP2PARAMETERS: u32 = 155;
pub const EC_F_EC_ASN1_GROUP2PKPARAMETERS: u32 = 156;
pub const EC_F_EC_ASN1_PARAMETERS2GROUP: u32 = 157;
pub const EC_F_EC_ASN1_PKPARAMETERS2GROUP: u32 = 158;
pub const EC_F_EC_EX_DATA_SET_DATA: u32 = 211;
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY: u32 = 208;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 159;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE: u32 = 195;
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT: u32 = 160;
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT: u32 = 161;
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 162;
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 163;
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 164;
pub const EC_F_EC_GFP_MONT_FIELD_DECODE: u32 = 133;
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE: u32 = 134;
pub const EC_F_EC_GFP_MONT_FIELD_MUL: u32 = 131;
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE: u32 = 209;
pub const EC_F_EC_GFP_MONT_FIELD_SQR: u32 = 132;
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE: u32 = 189;
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE_GFP: u32 = 135;
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE: u32 = 225;
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL: u32 = 228;
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES: u32 = 226;
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE: u32 = 230;
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL: u32 = 231;
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES: u32 = 232;
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE: u32 = 233;
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL: u32 = 234;
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES: u32 = 235;
pub const EC_F_EC_GFP_NIST_FIELD_MUL: u32 = 200;
pub const EC_F_EC_GFP_NIST_FIELD_SQR: u32 = 201;
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE: u32 = 202;
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 165;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE: u32 = 166;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE_GFP: u32 = 100;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_GENERATOR: u32 = 101;
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE: u32 = 102;
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT: u32 = 103;
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT: u32 = 104;
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE: u32 = 137;
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 167;
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES_GFP: u32 = 105;
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 168;
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES_GFP: u32 = 128;
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 169;
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP: u32 = 129;
pub const EC_F_EC_GROUP_CHECK: u32 = 170;
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT: u32 = 171;
pub const EC_F_EC_GROUP_COPY: u32 = 106;
pub const EC_F_EC_GROUP_GET0_GENERATOR: u32 = 139;
pub const EC_F_EC_GROUP_GET_COFACTOR: u32 = 140;
pub const EC_F_EC_GROUP_GET_CURVE_GF2M: u32 = 172;
pub const EC_F_EC_GROUP_GET_CURVE_GFP: u32 = 130;
pub const EC_F_EC_GROUP_GET_DEGREE: u32 = 173;
pub const EC_F_EC_GROUP_GET_ORDER: u32 = 141;
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS: u32 = 193;
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS: u32 = 194;
pub const EC_F_EC_GROUP_NEW: u32 = 108;
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME: u32 = 174;
pub const EC_F_EC_GROUP_NEW_FROM_DATA: u32 = 175;
pub const EC_F_EC_GROUP_PRECOMPUTE_MULT: u32 = 142;
pub const EC_F_EC_GROUP_SET_CURVE_GF2M: u32 = 176;
pub const EC_F_EC_GROUP_SET_CURVE_GFP: u32 = 109;
pub const EC_F_EC_GROUP_SET_EXTRA_DATA: u32 = 110;
pub const EC_F_EC_GROUP_SET_GENERATOR: u32 = 111;
pub const EC_F_EC_KEY_CHECK_KEY: u32 = 177;
pub const EC_F_EC_KEY_COPY: u32 = 178;
pub const EC_F_EC_KEY_GENERATE_KEY: u32 = 179;
pub const EC_F_EC_KEY_NEW: u32 = 182;
pub const EC_F_EC_KEY_PRINT: u32 = 180;
pub const EC_F_EC_KEY_PRINT_FP: u32 = 181;
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES: u32 = 229;
pub const EC_F_EC_POINTS_MAKE_AFFINE: u32 = 136;
pub const EC_F_EC_POINT_ADD: u32 = 112;
pub const EC_F_EC_POINT_CMP: u32 = 113;
pub const EC_F_EC_POINT_COPY: u32 = 114;
pub const EC_F_EC_POINT_DBL: u32 = 115;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M: u32 = 183;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP: u32 = 116;
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP: u32 = 117;
pub const EC_F_EC_POINT_INVERT: u32 = 210;
pub const EC_F_EC_POINT_IS_AT_INFINITY: u32 = 118;
pub const EC_F_EC_POINT_IS_ON_CURVE: u32 = 119;
pub const EC_F_EC_POINT_MAKE_AFFINE: u32 = 120;
pub const EC_F_EC_POINT_MUL: u32 = 184;
pub const EC_F_EC_POINT_NEW: u32 = 121;
pub const EC_F_EC_POINT_OCT2POINT: u32 = 122;
pub const EC_F_EC_POINT_POINT2OCT: u32 = 123;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M: u32 = 185;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP: u32 = 124;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M: u32 = 186;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP: u32 = 125;
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP: u32 = 126;
pub const EC_F_EC_POINT_SET_TO_INFINITY: u32 = 127;
pub const EC_F_EC_PRE_COMP_DUP: u32 = 207;
pub const EC_F_EC_PRE_COMP_NEW: u32 = 196;
pub const EC_F_EC_WNAF_MUL: u32 = 187;
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT: u32 = 188;
pub const EC_F_I2D_ECPARAMETERS: u32 = 190;
pub const EC_F_I2D_ECPKPARAMETERS: u32 = 191;
pub const EC_F_I2D_ECPRIVATEKEY: u32 = 192;
pub const EC_F_I2O_ECPUBLICKEY: u32 = 151;
pub const EC_F_NISTP224_PRE_COMP_NEW: u32 = 227;
pub const EC_F_NISTP256_PRE_COMP_NEW: u32 = 236;
pub const EC_F_NISTP521_PRE_COMP_NEW: u32 = 237;
pub const EC_F_O2I_ECPUBLICKEY: u32 = 152;
pub const EC_F_OLD_EC_PRIV_DECODE: u32 = 222;
pub const EC_F_PKEY_EC_CTRL: u32 = 197;
pub const EC_F_PKEY_EC_CTRL_STR: u32 = 198;
pub const EC_F_PKEY_EC_DERIVE: u32 = 217;
pub const EC_F_PKEY_EC_KEYGEN: u32 = 199;
pub const EC_F_PKEY_EC_PARAMGEN: u32 = 219;
pub const EC_F_PKEY_EC_SIGN: u32 = 218;
pub const EC_R_ASN1_ERROR: u32 = 115;
pub const EC_R_ASN1_UNKNOWN_FIELD: u32 = 116;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 144;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 146;
pub const EC_R_D2I_ECPKPARAMETERS_FAILURE: u32 = 117;
pub const EC_R_DECODE_ERROR: u32 = 142;
pub const EC_R_DISCRIMINANT_IS_ZERO: u32 = 118;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 119;
pub const EC_R_FIELD_TOO_LARGE: u32 = 143;
pub const EC_R_GF2M_NOT_SUPPORTED: u32 = 147;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 120;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 121;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 101;
pub const EC_R_INVALID_ARGUMENT: u32 = 112;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 110;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 109;
pub const EC_R_INVALID_CURVE: u32 = 141;
pub const EC_R_INVALID_DIGEST: u32 = 151;
pub const EC_R_INVALID_DIGEST_TYPE: u32 = 138;
pub const EC_R_INVALID_ENCODING: u32 = 102;
pub const EC_R_INVALID_FIELD: u32 = 103;
pub const EC_R_INVALID_FORM: u32 = 104;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 122;
pub const EC_R_INVALID_PENTANOMIAL_BASIS: u32 = 132;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 123;
pub const EC_R_INVALID_TRINOMIAL_BASIS: u32 = 137;
pub const EC_R_KDF_PARAMETER_ERROR: u32 = 148;
pub const EC_R_KEYS_NOT_SET: u32 = 140;
pub const EC_R_MISSING_PARAMETERS: u32 = 124;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 125;
pub const EC_R_NOT_A_NIST_PRIME: u32 = 135;
pub const EC_R_NOT_A_SUPPORTED_NIST_PRIME: u32 = 136;
pub const EC_R_NOT_IMPLEMENTED: u32 = 126;
pub const EC_R_NOT_INITIALIZED: u32 = 111;
pub const EC_R_NO_FIELD_MOD: u32 = 133;
pub const EC_R_NO_PARAMETERS_SET: u32 = 139;
pub const EC_R_PASSED_NULL_PARAMETER: u32 = 134;
pub const EC_R_PEER_KEY_ERROR: u32 = 149;
pub const EC_R_PKPARAMETERS2GROUP_FAILURE: u32 = 127;
pub const EC_R_POINT_AT_INFINITY: u32 = 106;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 107;
pub const EC_R_SHARED_INFO_ERROR: u32 = 150;
pub const EC_R_SLOT_FULL: u32 = 108;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 113;
pub const EC_R_UNDEFINED_ORDER: u32 = 128;
pub const EC_R_UNKNOWN_GROUP: u32 = 129;
pub const EC_R_UNKNOWN_ORDER: u32 = 114;
pub const EC_R_UNSUPPORTED_FIELD: u32 = 131;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 145;
pub const EC_R_WRONG_ORDER: u32 = 130;
pub const ECDSA_F_ECDSA_CHECK: u32 = 104;
pub const ECDSA_F_ECDSA_DATA_NEW_METHOD: u32 = 100;
pub const ECDSA_F_ECDSA_DO_SIGN: u32 = 101;
pub const ECDSA_F_ECDSA_DO_VERIFY: u32 = 102;
pub const ECDSA_F_ECDSA_METHOD_NEW: u32 = 105;
pub const ECDSA_F_ECDSA_SIGN_SETUP: u32 = 103;
pub const ECDSA_R_BAD_SIGNATURE: u32 = 100;
pub const ECDSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 101;
pub const ECDSA_R_ERR_EC_LIB: u32 = 102;
pub const ECDSA_R_MISSING_PARAMETERS: u32 = 103;
pub const ECDSA_R_NEED_NEW_SETUP_VALUES: u32 = 106;
pub const ECDSA_R_NON_FIPS_METHOD: u32 = 107;
pub const ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 104;
pub const ECDSA_R_SIGNATURE_MALLOC_FAILED: u32 = 105;
pub const EC_FLAG_COFACTOR_ECDH: u32 = 4096;
pub const ECDH_F_ECDH_CHECK: u32 = 102;
pub const ECDH_F_ECDH_COMPUTE_KEY: u32 = 100;
pub const ECDH_F_ECDH_DATA_NEW_METHOD: u32 = 101;
pub const ECDH_R_KDF_FAILED: u32 = 102;
pub const ECDH_R_NON_FIPS_METHOD: u32 = 103;
pub const ECDH_R_NO_PRIVATE_VALUE: u32 = 100;
pub const ECDH_R_POINT_ARITHMETIC_FAILURE: u32 = 101;
pub const OPENSSL_RSA_MAX_MODULUS_BITS: u32 = 16384;
pub const OPENSSL_RSA_SMALL_MODULUS_BITS: u32 = 3072;
pub const OPENSSL_RSA_MAX_PUBEXP_BITS: u32 = 64;
pub const RSA_3: u32 = 3;
pub const RSA_F4: u32 = 65537;
pub const RSA_METHOD_FLAG_NO_CHECK: u32 = 1;
pub const RSA_FLAG_CACHE_PUBLIC: u32 = 2;
pub const RSA_FLAG_CACHE_PRIVATE: u32 = 4;
pub const RSA_FLAG_BLINDING: u32 = 8;
pub const RSA_FLAG_THREAD_SAFE: u32 = 16;
pub const RSA_FLAG_EXT_PKEY: u32 = 32;
pub const RSA_FLAG_SIGN_VER: u32 = 64;
pub const RSA_FLAG_NO_BLINDING: u32 = 128;
pub const RSA_FLAG_NO_CONSTTIME: u32 = 256;
pub const EVP_PKEY_CTRL_RSA_PADDING: u32 = 4097;
pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN: u32 = 4098;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_BITS: u32 = 4099;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP: u32 = 4100;
pub const EVP_PKEY_CTRL_RSA_MGF1_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_RSA_PADDING: u32 = 4102;
pub const EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_RSA_MGF1_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_RSA_OAEP_MD: u32 = 4105;
pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL: u32 = 4106;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_MD: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL: u32 = 4108;
pub const RSA_PKCS1_PADDING: u32 = 1;
pub const RSA_SSLV23_PADDING: u32 = 2;
pub const RSA_NO_PADDING: u32 = 3;
pub const RSA_PKCS1_OAEP_PADDING: u32 = 4;
pub const RSA_X931_PADDING: u32 = 5;
pub const RSA_PKCS1_PSS_PADDING: u32 = 6;
pub const RSA_PKCS1_PADDING_SIZE: u32 = 11;
pub const RSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const RSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const RSA_FLAG_CHECKED: u32 = 2048;
pub const RSA_F_CHECK_PADDING_MD: u32 = 140;
pub const RSA_F_DO_RSA_PRINT: u32 = 146;
pub const RSA_F_INT_RSA_VERIFY: u32 = 145;
pub const RSA_F_MEMORY_LOCK: u32 = 100;
pub const RSA_F_OLD_RSA_PRIV_DECODE: u32 = 147;
pub const RSA_F_PKEY_RSA_CTRL: u32 = 143;
pub const RSA_F_PKEY_RSA_CTRL_STR: u32 = 144;
pub const RSA_F_PKEY_RSA_SIGN: u32 = 142;
pub const RSA_F_PKEY_RSA_VERIFY: u32 = 154;
pub const RSA_F_PKEY_RSA_VERIFYRECOVER: u32 = 141;
pub const RSA_F_RSA_ALGOR_TO_MD: u32 = 157;
pub const RSA_F_RSA_BUILTIN_KEYGEN: u32 = 129;
pub const RSA_F_RSA_CHECK_KEY: u32 = 123;
pub const RSA_F_RSA_CMS_DECRYPT: u32 = 158;
pub const RSA_F_RSA_EAY_PRIVATE_DECRYPT: u32 = 101;
pub const RSA_F_RSA_EAY_PRIVATE_ENCRYPT: u32 = 102;
pub const RSA_F_RSA_EAY_PUBLIC_DECRYPT: u32 = 103;
pub const RSA_F_RSA_EAY_PUBLIC_ENCRYPT: u32 = 104;
pub const RSA_F_RSA_GENERATE_KEY: u32 = 105;
pub const RSA_F_RSA_GENERATE_KEY_EX: u32 = 155;
pub const RSA_F_RSA_ITEM_VERIFY: u32 = 156;
pub const RSA_F_RSA_MEMORY_LOCK: u32 = 130;
pub const RSA_F_RSA_MGF1_TO_MD: u32 = 159;
pub const RSA_F_RSA_NEW_METHOD: u32 = 106;
pub const RSA_F_RSA_NULL: u32 = 124;
pub const RSA_F_RSA_NULL_MOD_EXP: u32 = 131;
pub const RSA_F_RSA_NULL_PRIVATE_DECRYPT: u32 = 132;
pub const RSA_F_RSA_NULL_PRIVATE_ENCRYPT: u32 = 133;
pub const RSA_F_RSA_NULL_PUBLIC_DECRYPT: u32 = 134;
pub const RSA_F_RSA_NULL_PUBLIC_ENCRYPT: u32 = 135;
pub const RSA_F_RSA_PADDING_ADD_NONE: u32 = 107;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP: u32 = 121;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1: u32 = 160;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS: u32 = 125;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1: u32 = 148;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1: u32 = 108;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2: u32 = 109;
pub const RSA_F_RSA_PADDING_ADD_SSLV23: u32 = 110;
pub const RSA_F_RSA_PADDING_ADD_X931: u32 = 127;
pub const RSA_F_RSA_PADDING_CHECK_NONE: u32 = 111;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP: u32 = 122;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1: u32 = 161;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1: u32 = 112;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2: u32 = 113;
pub const RSA_F_RSA_PADDING_CHECK_SSLV23: u32 = 114;
pub const RSA_F_RSA_PADDING_CHECK_X931: u32 = 128;
pub const RSA_F_RSA_PRINT: u32 = 115;
pub const RSA_F_RSA_PRINT_FP: u32 = 116;
pub const RSA_F_RSA_PRIVATE_DECRYPT: u32 = 150;
pub const RSA_F_RSA_PRIVATE_ENCRYPT: u32 = 151;
pub const RSA_F_RSA_PRIV_DECODE: u32 = 137;
pub const RSA_F_RSA_PRIV_ENCODE: u32 = 138;
pub const RSA_F_RSA_PSS_TO_CTX: u32 = 162;
pub const RSA_F_RSA_PUBLIC_DECRYPT: u32 = 152;
pub const RSA_F_RSA_PUBLIC_ENCRYPT: u32 = 153;
pub const RSA_F_RSA_PUB_DECODE: u32 = 139;
pub const RSA_F_RSA_SETUP_BLINDING: u32 = 136;
pub const RSA_F_RSA_SIGN: u32 = 117;
pub const RSA_F_RSA_SIGN_ASN1_OCTET_STRING: u32 = 118;
pub const RSA_F_RSA_VERIFY: u32 = 119;
pub const RSA_F_RSA_VERIFY_ASN1_OCTET_STRING: u32 = 120;
pub const RSA_F_RSA_VERIFY_PKCS1_PSS: u32 = 126;
pub const RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1: u32 = 149;
pub const RSA_R_ALGORITHM_MISMATCH: u32 = 100;
pub const RSA_R_BAD_E_VALUE: u32 = 101;
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT: u32 = 102;
pub const RSA_R_BAD_PAD_BYTE_COUNT: u32 = 103;
pub const RSA_R_BAD_SIGNATURE: u32 = 104;
pub const RSA_R_BLOCK_TYPE_IS_NOT_01: u32 = 106;
pub const RSA_R_BLOCK_TYPE_IS_NOT_02: u32 = 107;
pub const RSA_R_DATA_GREATER_THAN_MOD_LEN: u32 = 108;
pub const RSA_R_DATA_TOO_LARGE: u32 = 109;
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 110;
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS: u32 = 132;
pub const RSA_R_DATA_TOO_SMALL: u32 = 111;
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE: u32 = 122;
pub const RSA_R_DIGEST_DOES_NOT_MATCH: u32 = 166;
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY: u32 = 112;
pub const RSA_R_DMP1_NOT_CONGRUENT_TO_D: u32 = 124;
pub const RSA_R_DMQ1_NOT_CONGRUENT_TO_D: u32 = 125;
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1: u32 = 123;
pub const RSA_R_FIRST_OCTET_INVALID: u32 = 133;
pub const RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE: u32 = 144;
pub const RSA_R_INVALID_DIGEST: u32 = 160;
pub const RSA_R_INVALID_DIGEST_LENGTH: u32 = 143;
pub const RSA_R_INVALID_HEADER: u32 = 137;
pub const RSA_R_INVALID_KEYBITS: u32 = 145;
pub const RSA_R_INVALID_LABEL: u32 = 161;
pub const RSA_R_INVALID_MESSAGE_LENGTH: u32 = 131;
pub const RSA_R_INVALID_MGF1_MD: u32 = 156;
pub const RSA_R_INVALID_OAEP_PARAMETERS: u32 = 162;
pub const RSA_R_INVALID_PADDING: u32 = 138;
pub const RSA_R_INVALID_PADDING_MODE: u32 = 141;
pub const RSA_R_INVALID_PSS_PARAMETERS: u32 = 149;
pub const RSA_R_INVALID_PSS_SALTLEN: u32 = 146;
pub const RSA_R_INVALID_SALT_LENGTH: u32 = 150;
pub const RSA_R_INVALID_TRAILER: u32 = 139;
pub const RSA_R_INVALID_X931_DIGEST: u32 = 142;
pub const RSA_R_IQMP_NOT_INVERSE_OF_Q: u32 = 126;
pub const RSA_R_KEY_SIZE_TOO_SMALL: u32 = 120;
pub const RSA_R_LAST_OCTET_INVALID: u32 = 134;
pub const RSA_R_MODULUS_TOO_LARGE: u32 = 105;
pub const RSA_R_NON_FIPS_RSA_METHOD: u32 = 157;
pub const RSA_R_NO_PUBLIC_EXPONENT: u32 = 140;
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING: u32 = 113;
pub const RSA_R_N_DOES_NOT_EQUAL_P_Q: u32 = 127;
pub const RSA_R_OAEP_DECODING_ERROR: u32 = 121;
pub const RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE: u32 = 158;
pub const RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 148;
pub const RSA_R_PADDING_CHECK_FAILED: u32 = 114;
pub const RSA_R_PKCS_DECODING_ERROR: u32 = 159;
pub const RSA_R_P_NOT_PRIME: u32 = 128;
pub const RSA_R_Q_NOT_PRIME: u32 = 129;
pub const RSA_R_RSA_OPERATIONS_NOT_SUPPORTED: u32 = 130;
pub const RSA_R_SLEN_CHECK_FAILED: u32 = 136;
pub const RSA_R_SLEN_RECOVERY_FAILED: u32 = 135;
pub const RSA_R_SSLV3_ROLLBACK_ATTACK: u32 = 115;
pub const RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 116;
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE: u32 = 117;
pub const RSA_R_UNKNOWN_DIGEST: u32 = 163;
pub const RSA_R_UNKNOWN_MASK_DIGEST: u32 = 151;
pub const RSA_R_UNKNOWN_PADDING_TYPE: u32 = 118;
pub const RSA_R_UNKNOWN_PSS_DIGEST: u32 = 152;
pub const RSA_R_UNSUPPORTED_ENCRYPTION_TYPE: u32 = 164;
pub const RSA_R_UNSUPPORTED_LABEL_SOURCE: u32 = 165;
pub const RSA_R_UNSUPPORTED_MASK_ALGORITHM: u32 = 153;
pub const RSA_R_UNSUPPORTED_MASK_PARAMETER: u32 = 154;
pub const RSA_R_UNSUPPORTED_SIGNATURE_TYPE: u32 = 155;
pub const RSA_R_VALUE_MISSING: u32 = 147;
pub const RSA_R_WRONG_SIGNATURE_LENGTH: u32 = 119;
pub const OPENSSL_DH_MAX_MODULUS_BITS: u32 = 10000;
pub const DH_FLAG_CACHE_MONT_P: u32 = 1;
pub const DH_FLAG_NO_EXP_CONSTTIME: u32 = 2;
pub const DH_FLAG_FIPS_METHOD: u32 = 1024;
pub const DH_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DH_GENERATOR_2: u32 = 2;
pub const DH_GENERATOR_5: u32 = 5;
pub const DH_CHECK_P_NOT_PRIME: u32 = 1;
pub const DH_CHECK_P_NOT_SAFE_PRIME: u32 = 2;
pub const DH_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_CHECK_Q_NOT_PRIME: u32 = 16;
pub const DH_CHECK_INVALID_Q_VALUE: u32 = 32;
pub const DH_CHECK_INVALID_J_VALUE: u32 = 64;
pub const DH_CHECK_PUBKEY_TOO_SMALL: u32 = 1;
pub const DH_CHECK_PUBKEY_TOO_LARGE: u32 = 2;
pub const DH_CHECK_PUBKEY_INVALID: u32 = 4;
pub const DH_CHECK_P_NOT_STRONG_PRIME: u32 = 2;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN: u32 = 4097;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR: u32 = 4098;
pub const EVP_PKEY_CTRL_DH_RFC5114: u32 = 4099;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN: u32 = 4100;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_TYPE: u32 = 4101;
pub const EVP_PKEY_CTRL_DH_KDF_TYPE: u32 = 4102;
pub const EVP_PKEY_CTRL_DH_KDF_MD: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_DH_KDF_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_DH_KDF_OUTLEN: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN: u32 = 4106;
pub const EVP_PKEY_CTRL_DH_KDF_UKM: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_DH_KDF_UKM: u32 = 4108;
pub const EVP_PKEY_CTRL_DH_KDF_OID: u32 = 4109;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OID: u32 = 4110;
pub const EVP_PKEY_DH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_DH_KDF_X9_42: u32 = 2;
pub const DH_F_COMPUTE_KEY: u32 = 102;
pub const DH_F_DHPARAMS_PRINT_FP: u32 = 101;
pub const DH_F_DH_BUILTIN_GENPARAMS: u32 = 106;
pub const DH_F_DH_CMS_DECRYPT: u32 = 117;
pub const DH_F_DH_CMS_SET_PEERKEY: u32 = 118;
pub const DH_F_DH_CMS_SET_SHARED_INFO: u32 = 119;
pub const DH_F_DH_COMPUTE_KEY: u32 = 114;
pub const DH_F_DH_GENERATE_KEY: u32 = 115;
pub const DH_F_DH_GENERATE_PARAMETERS_EX: u32 = 116;
pub const DH_F_DH_NEW_METHOD: u32 = 105;
pub const DH_F_DH_PARAM_DECODE: u32 = 107;
pub const DH_F_DH_PRIV_DECODE: u32 = 110;
pub const DH_F_DH_PRIV_ENCODE: u32 = 111;
pub const DH_F_DH_PUB_DECODE: u32 = 108;
pub const DH_F_DH_PUB_ENCODE: u32 = 109;
pub const DH_F_DO_DH_PRINT: u32 = 100;
pub const DH_F_GENERATE_KEY: u32 = 103;
pub const DH_F_GENERATE_PARAMETERS: u32 = 104;
pub const DH_F_PKEY_DH_DERIVE: u32 = 112;
pub const DH_F_PKEY_DH_KEYGEN: u32 = 113;
pub const DH_R_BAD_GENERATOR: u32 = 101;
pub const DH_R_BN_DECODE_ERROR: u32 = 109;
pub const DH_R_BN_ERROR: u32 = 106;
pub const DH_R_DECODE_ERROR: u32 = 104;
pub const DH_R_INVALID_PUBKEY: u32 = 102;
pub const DH_R_KDF_PARAMETER_ERROR: u32 = 112;
pub const DH_R_KEYS_NOT_SET: u32 = 108;
pub const DH_R_KEY_SIZE_TOO_SMALL: u32 = 110;
pub const DH_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DH_R_NON_FIPS_METHOD: u32 = 111;
pub const DH_R_NO_PARAMETERS_SET: u32 = 107;
pub const DH_R_NO_PRIVATE_VALUE: u32 = 100;
pub const DH_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DH_R_PEER_KEY_ERROR: u32 = 113;
pub const DH_R_SHARED_INFO_ERROR: u32 = 114;
pub const OPENSSL_DSA_MAX_MODULUS_BITS: u32 = 10000;
pub const DSA_FLAG_CACHE_MONT_P: u32 = 1;
pub const DSA_FLAG_NO_EXP_CONSTTIME: u32 = 2;
pub const DSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const DSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DSS_prime_checks: u32 = 64;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_BITS: u32 = 4097;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS: u32 = 4098;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_MD: u32 = 4099;
pub const DSA_F_D2I_DSA_SIG: u32 = 110;
pub const DSA_F_DO_DSA_PRINT: u32 = 104;
pub const DSA_F_DSAPARAMS_PRINT: u32 = 100;
pub const DSA_F_DSAPARAMS_PRINT_FP: u32 = 101;
pub const DSA_F_DSA_BUILTIN_PARAMGEN2: u32 = 126;
pub const DSA_F_DSA_DO_SIGN: u32 = 112;
pub const DSA_F_DSA_DO_VERIFY: u32 = 113;
pub const DSA_F_DSA_GENERATE_KEY: u32 = 124;
pub const DSA_F_DSA_GENERATE_PARAMETERS_EX: u32 = 123;
pub const DSA_F_DSA_NEW_METHOD: u32 = 103;
pub const DSA_F_DSA_PARAM_DECODE: u32 = 119;
pub const DSA_F_DSA_PRINT_FP: u32 = 105;
pub const DSA_F_DSA_PRIV_DECODE: u32 = 115;
pub const DSA_F_DSA_PRIV_ENCODE: u32 = 116;
pub const DSA_F_DSA_PUB_DECODE: u32 = 117;
pub const DSA_F_DSA_PUB_ENCODE: u32 = 118;
pub const DSA_F_DSA_SIGN: u32 = 106;
pub const DSA_F_DSA_SIGN_SETUP: u32 = 107;
pub const DSA_F_DSA_SIG_NEW: u32 = 109;
pub const DSA_F_DSA_SIG_PRINT: u32 = 125;
pub const DSA_F_DSA_VERIFY: u32 = 108;
pub const DSA_F_I2D_DSA_SIG: u32 = 111;
pub const DSA_F_OLD_DSA_PRIV_DECODE: u32 = 122;
pub const DSA_F_PKEY_DSA_CTRL: u32 = 120;
pub const DSA_F_PKEY_DSA_CTRL_STR: u32 = 127;
pub const DSA_F_PKEY_DSA_KEYGEN: u32 = 121;
pub const DSA_F_SIG_CB: u32 = 114;
pub const DSA_R_BAD_Q_VALUE: u32 = 102;
pub const DSA_R_BN_DECODE_ERROR: u32 = 108;
pub const DSA_R_BN_ERROR: u32 = 109;
pub const DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 100;
pub const DSA_R_DECODE_ERROR: u32 = 104;
pub const DSA_R_INVALID_DIGEST_TYPE: u32 = 106;
pub const DSA_R_INVALID_PARAMETERS: u32 = 112;
pub const DSA_R_MISSING_PARAMETERS: u32 = 101;
pub const DSA_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DSA_R_NEED_NEW_SETUP_VALUES: u32 = 110;
pub const DSA_R_NON_FIPS_DSA_METHOD: u32 = 111;
pub const DSA_R_NO_PARAMETERS_SET: u32 = 107;
pub const DSA_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DSA_R_Q_NOT_PRIME: u32 = 113;
pub const SHA_LBLOCK: u32 = 16;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_LAST_BLOCK: u32 = 56;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_CBLOCK: u32 = 128;
pub const X509_FILETYPE_PEM: u32 = 1;
pub const X509_FILETYPE_ASN1: u32 = 2;
pub const X509_FILETYPE_DEFAULT: u32 = 3;
pub const X509v3_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509v3_KU_NON_REPUDIATION: u32 = 64;
pub const X509v3_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509v3_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509v3_KU_KEY_AGREEMENT: u32 = 8;
pub const X509v3_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509v3_KU_CRL_SIGN: u32 = 2;
pub const X509v3_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509v3_KU_DECIPHER_ONLY: u32 = 32768;
pub const X509v3_KU_UNDEF: u32 = 65535;
pub const X509_EX_V_NETSCAPE_HACK: u32 = 32768;
pub const X509_EX_V_INIT: u32 = 1;
pub const X509_TRUST_DEFAULT: i32 = -1;
pub const X509_TRUST_COMPAT: u32 = 1;
pub const X509_TRUST_SSL_CLIENT: u32 = 2;
pub const X509_TRUST_SSL_SERVER: u32 = 3;
pub const X509_TRUST_EMAIL: u32 = 4;
pub const X509_TRUST_OBJECT_SIGN: u32 = 5;
pub const X509_TRUST_OCSP_SIGN: u32 = 6;
pub const X509_TRUST_OCSP_REQUEST: u32 = 7;
pub const X509_TRUST_TSA: u32 = 8;
pub const X509_TRUST_MIN: u32 = 1;
pub const X509_TRUST_MAX: u32 = 8;
pub const X509_TRUST_DYNAMIC: u32 = 1;
pub const X509_TRUST_DYNAMIC_NAME: u32 = 2;
pub const X509_TRUST_TRUSTED: u32 = 1;
pub const X509_TRUST_REJECTED: u32 = 2;
pub const X509_TRUST_UNTRUSTED: u32 = 3;
pub const X509_FLAG_COMPAT: u32 = 0;
pub const X509_FLAG_NO_HEADER: u32 = 1;
pub const X509_FLAG_NO_VERSION: u32 = 2;
pub const X509_FLAG_NO_SERIAL: u32 = 4;
pub const X509_FLAG_NO_SIGNAME: u32 = 8;
pub const X509_FLAG_NO_ISSUER: u32 = 16;
pub const X509_FLAG_NO_VALIDITY: u32 = 32;
pub const X509_FLAG_NO_SUBJECT: u32 = 64;
pub const X509_FLAG_NO_PUBKEY: u32 = 128;
pub const X509_FLAG_NO_EXTENSIONS: u32 = 256;
pub const X509_FLAG_NO_SIGDUMP: u32 = 512;
pub const X509_FLAG_NO_AUX: u32 = 1024;
pub const X509_FLAG_NO_ATTRIBUTES: u32 = 2048;
pub const X509_FLAG_NO_IDS: u32 = 4096;
pub const XN_FLAG_SEP_MASK: u32 = 983040;
pub const XN_FLAG_COMPAT: u32 = 0;
pub const XN_FLAG_SEP_COMMA_PLUS: u32 = 65536;
pub const XN_FLAG_SEP_CPLUS_SPC: u32 = 131072;
pub const XN_FLAG_SEP_SPLUS_SPC: u32 = 196608;
pub const XN_FLAG_SEP_MULTILINE: u32 = 262144;
pub const XN_FLAG_DN_REV: u32 = 1048576;
pub const XN_FLAG_FN_MASK: u32 = 6291456;
pub const XN_FLAG_FN_SN: u32 = 0;
pub const XN_FLAG_FN_LN: u32 = 2097152;
pub const XN_FLAG_FN_OID: u32 = 4194304;
pub const XN_FLAG_FN_NONE: u32 = 6291456;
pub const XN_FLAG_SPC_EQ: u32 = 8388608;
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS: u32 = 16777216;
pub const XN_FLAG_FN_ALIGN: u32 = 33554432;
pub const XN_FLAG_RFC2253: u32 = 17892119;
pub const XN_FLAG_ONELINE: u32 = 8520479;
pub const XN_FLAG_MULTILINE: u32 = 44302342;
pub const PKCS8_OK: u32 = 0;
pub const PKCS8_NO_OCTET: u32 = 1;
pub const PKCS8_EMBEDDED_PARAM: u32 = 2;
pub const PKCS8_NS_DB: u32 = 3;
pub const PKCS8_NEG_PRIVKEY: u32 = 4;
pub const LH_LOAD_MULT: u32 = 256;
pub const X509_LU_RETRY: i32 = -1;
pub const X509_LU_FAIL: u32 = 0;
pub const X509_LU_X509: u32 = 1;
pub const X509_LU_CRL: u32 = 2;
pub const X509_LU_PKEY: u32 = 3;
pub const X509_L_FILE_LOAD: u32 = 1;
pub const X509_L_ADD_DIR: u32 = 2;
pub const X509_V_OK: u32 = 0;
pub const X509_V_ERR_UNSPECIFIED: u32 = 1;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: u32 = 2;
pub const X509_V_ERR_UNABLE_TO_GET_CRL: u32 = 3;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: u32 = 4;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: u32 = 5;
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: u32 = 6;
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE: u32 = 7;
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE: u32 = 8;
pub const X509_V_ERR_CERT_NOT_YET_VALID: u32 = 9;
pub const X509_V_ERR_CERT_HAS_EXPIRED: u32 = 10;
pub const X509_V_ERR_CRL_NOT_YET_VALID: u32 = 11;
pub const X509_V_ERR_CRL_HAS_EXPIRED: u32 = 12;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: u32 = 13;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: u32 = 14;
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: u32 = 15;
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: u32 = 16;
pub const X509_V_ERR_OUT_OF_MEM: u32 = 17;
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: u32 = 18;
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: u32 = 19;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: u32 = 20;
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: u32 = 21;
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG: u32 = 22;
pub const X509_V_ERR_CERT_REVOKED: u32 = 23;
pub const X509_V_ERR_INVALID_CA: u32 = 24;
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED: u32 = 25;
pub const X509_V_ERR_INVALID_PURPOSE: u32 = 26;
pub const X509_V_ERR_CERT_UNTRUSTED: u32 = 27;
pub const X509_V_ERR_CERT_REJECTED: u32 = 28;
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH: u32 = 29;
pub const X509_V_ERR_AKID_SKID_MISMATCH: u32 = 30;
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: u32 = 31;
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN: u32 = 32;
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER: u32 = 33;
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION: u32 = 34;
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN: u32 = 35;
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: u32 = 36;
pub const X509_V_ERR_INVALID_NON_CA: u32 = 37;
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED: u32 = 38;
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: u32 = 39;
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: u32 = 40;
pub const X509_V_ERR_INVALID_EXTENSION: u32 = 41;
pub const X509_V_ERR_INVALID_POLICY_EXTENSION: u32 = 42;
pub const X509_V_ERR_NO_EXPLICIT_POLICY: u32 = 43;
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE: u32 = 44;
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: u32 = 45;
pub const X509_V_ERR_UNNESTED_RESOURCE: u32 = 46;
pub const X509_V_ERR_PERMITTED_VIOLATION: u32 = 47;
pub const X509_V_ERR_EXCLUDED_VIOLATION: u32 = 48;
pub const X509_V_ERR_SUBTREE_MINMAX: u32 = 49;
pub const X509_V_ERR_APPLICATION_VERIFICATION: u32 = 50;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: u32 = 51;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: u32 = 52;
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: u32 = 53;
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR: u32 = 54;
pub const X509_V_ERR_SUITE_B_INVALID_VERSION: u32 = 56;
pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM: u32 = 57;
pub const X509_V_ERR_SUITE_B_INVALID_CURVE: u32 = 58;
pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: u32 = 59;
pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED: u32 = 60;
pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: u32 = 61;
pub const X509_V_ERR_HOSTNAME_MISMATCH: u32 = 62;
pub const X509_V_ERR_EMAIL_MISMATCH: u32 = 63;
pub const X509_V_ERR_IP_ADDRESS_MISMATCH: u32 = 64;
pub const X509_V_ERR_INVALID_CALL: u32 = 65;
pub const X509_V_ERR_STORE_LOOKUP: u32 = 66;
pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION: u32 = 67;
pub const X509_V_FLAG_CB_ISSUER_CHECK: u32 = 1;
pub const X509_V_FLAG_USE_CHECK_TIME: u32 = 2;
pub const X509_V_FLAG_CRL_CHECK: u32 = 4;
pub const X509_V_FLAG_CRL_CHECK_ALL: u32 = 8;
pub const X509_V_FLAG_IGNORE_CRITICAL: u32 = 16;
pub const X509_V_FLAG_X509_STRICT: u32 = 32;
pub const X509_V_FLAG_ALLOW_PROXY_CERTS: u32 = 64;
pub const X509_V_FLAG_POLICY_CHECK: u32 = 128;
pub const X509_V_FLAG_EXPLICIT_POLICY: u32 = 256;
pub const X509_V_FLAG_INHIBIT_ANY: u32 = 512;
pub const X509_V_FLAG_INHIBIT_MAP: u32 = 1024;
pub const X509_V_FLAG_NOTIFY_POLICY: u32 = 2048;
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT: u32 = 4096;
pub const X509_V_FLAG_USE_DELTAS: u32 = 8192;
pub const X509_V_FLAG_CHECK_SS_SIGNATURE: u32 = 16384;
pub const X509_V_FLAG_TRUSTED_FIRST: u32 = 32768;
pub const X509_V_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const X509_V_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const X509_V_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const X509_V_FLAG_PARTIAL_CHAIN: u32 = 524288;
pub const X509_V_FLAG_NO_ALT_CHAINS: u32 = 1048576;
pub const X509_VP_FLAG_DEFAULT: u32 = 1;
pub const X509_VP_FLAG_OVERWRITE: u32 = 2;
pub const X509_VP_FLAG_RESET_FLAGS: u32 = 4;
pub const X509_VP_FLAG_LOCKED: u32 = 8;
pub const X509_VP_FLAG_ONCE: u32 = 16;
pub const X509_V_FLAG_POLICY_MASK: u32 = 1920;
pub const PKCS7_S_HEADER: u32 = 0;
pub const PKCS7_S_BODY: u32 = 1;
pub const PKCS7_S_TAIL: u32 = 2;
pub const PKCS7_OP_SET_DETACHED_SIGNATURE: u32 = 1;
pub const PKCS7_OP_GET_DETACHED_SIGNATURE: u32 = 2;
pub const PKCS7_TEXT: u32 = 1;
pub const PKCS7_NOCERTS: u32 = 2;
pub const PKCS7_NOSIGS: u32 = 4;
pub const PKCS7_NOCHAIN: u32 = 8;
pub const PKCS7_NOINTERN: u32 = 16;
pub const PKCS7_NOVERIFY: u32 = 32;
pub const PKCS7_DETACHED: u32 = 64;
pub const PKCS7_BINARY: u32 = 128;
pub const PKCS7_NOATTR: u32 = 256;
pub const PKCS7_NOSMIMECAP: u32 = 512;
pub const PKCS7_NOOLDMIMETYPE: u32 = 1024;
pub const PKCS7_CRLFEOL: u32 = 2048;
pub const PKCS7_STREAM: u32 = 4096;
pub const PKCS7_NOCRL: u32 = 8192;
pub const PKCS7_PARTIAL: u32 = 16384;
pub const PKCS7_REUSE_DIGEST: u32 = 32768;
pub const SMIME_TEXT: u32 = 1;
pub const SMIME_NOCERTS: u32 = 2;
pub const SMIME_NOSIGS: u32 = 4;
pub const SMIME_NOCHAIN: u32 = 8;
pub const SMIME_NOINTERN: u32 = 16;
pub const SMIME_NOVERIFY: u32 = 32;
pub const SMIME_DETACHED: u32 = 64;
pub const SMIME_BINARY: u32 = 128;
pub const SMIME_NOATTR: u32 = 256;
pub const PKCS7_F_B64_READ_PKCS7: u32 = 120;
pub const PKCS7_F_B64_WRITE_PKCS7: u32 = 121;
pub const PKCS7_F_DO_PKCS7_SIGNED_ATTRIB: u32 = 136;
pub const PKCS7_F_I2D_PKCS7_BIO_STREAM: u32 = 140;
pub const PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME: u32 = 135;
pub const PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP: u32 = 118;
pub const PKCS7_F_PKCS7_ADD_CERTIFICATE: u32 = 100;
pub const PKCS7_F_PKCS7_ADD_CRL: u32 = 101;
pub const PKCS7_F_PKCS7_ADD_RECIPIENT_INFO: u32 = 102;
pub const PKCS7_F_PKCS7_ADD_SIGNATURE: u32 = 131;
pub const PKCS7_F_PKCS7_ADD_SIGNER: u32 = 103;
pub const PKCS7_F_PKCS7_BIO_ADD_DIGEST: u32 = 125;
pub const PKCS7_F_PKCS7_COPY_EXISTING_DIGEST: u32 = 138;
pub const PKCS7_F_PKCS7_CTRL: u32 = 104;
pub const PKCS7_F_PKCS7_DATADECODE: u32 = 112;
pub const PKCS7_F_PKCS7_DATAFINAL: u32 = 128;
pub const PKCS7_F_PKCS7_DATAINIT: u32 = 105;
pub const PKCS7_F_PKCS7_DATASIGN: u32 = 106;
pub const PKCS7_F_PKCS7_DATAVERIFY: u32 = 107;
pub const PKCS7_F_PKCS7_DECRYPT: u32 = 114;
pub const PKCS7_F_PKCS7_DECRYPT_RINFO: u32 = 133;
pub const PKCS7_F_PKCS7_ENCODE_RINFO: u32 = 132;
pub const PKCS7_F_PKCS7_ENCRYPT: u32 = 115;
pub const PKCS7_F_PKCS7_FINAL: u32 = 134;
pub const PKCS7_F_PKCS7_FIND_DIGEST: u32 = 127;
pub const PKCS7_F_PKCS7_GET0_SIGNERS: u32 = 124;
pub const PKCS7_F_PKCS7_RECIP_INFO_SET: u32 = 130;
pub const PKCS7_F_PKCS7_SET_CIPHER: u32 = 108;
pub const PKCS7_F_PKCS7_SET_CONTENT: u32 = 109;
pub const PKCS7_F_PKCS7_SET_DIGEST: u32 = 126;
pub const PKCS7_F_PKCS7_SET_TYPE: u32 = 110;
pub const PKCS7_F_PKCS7_SIGN: u32 = 116;
pub const PKCS7_F_PKCS7_SIGNATUREVERIFY: u32 = 113;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SET: u32 = 129;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SIGN: u32 = 139;
pub const PKCS7_F_PKCS7_SIGN_ADD_SIGNER: u32 = 137;
pub const PKCS7_F_PKCS7_SIMPLE_SMIMECAP: u32 = 119;
pub const PKCS7_F_PKCS7_VERIFY: u32 = 117;
pub const PKCS7_F_SMIME_READ_PKCS7: u32 = 122;
pub const PKCS7_F_SMIME_TEXT: u32 = 123;
pub const PKCS7_R_CERTIFICATE_VERIFY_ERROR: u32 = 117;
pub const PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 144;
pub const PKCS7_R_CIPHER_NOT_INITIALIZED: u32 = 116;
pub const PKCS7_R_CONTENT_AND_DATA_PRESENT: u32 = 118;
pub const PKCS7_R_CTRL_ERROR: u32 = 152;
pub const PKCS7_R_DECODE_ERROR: u32 = 130;
pub const PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH: u32 = 100;
pub const PKCS7_R_DECRYPT_ERROR: u32 = 119;
pub const PKCS7_R_DIGEST_FAILURE: u32 = 101;
pub const PKCS7_R_ENCRYPTION_CTRL_FAILURE: u32 = 149;
pub const PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 150;
pub const PKCS7_R_ERROR_ADDING_RECIPIENT: u32 = 120;
pub const PKCS7_R_ERROR_SETTING_CIPHER: u32 = 121;
pub const PKCS7_R_INVALID_MIME_TYPE: u32 = 131;
pub const PKCS7_R_INVALID_NULL_POINTER: u32 = 143;
pub const PKCS7_R_INVALID_SIGNED_DATA_TYPE: u32 = 155;
pub const PKCS7_R_MIME_NO_CONTENT_TYPE: u32 = 132;
pub const PKCS7_R_MIME_PARSE_ERROR: u32 = 133;
pub const PKCS7_R_MIME_SIG_PARSE_ERROR: u32 = 134;
pub const PKCS7_R_MISSING_CERIPEND_INFO: u32 = 103;
pub const PKCS7_R_NO_CONTENT: u32 = 122;
pub const PKCS7_R_NO_CONTENT_TYPE: u32 = 135;
pub const PKCS7_R_NO_DEFAULT_DIGEST: u32 = 151;
pub const PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND: u32 = 154;
pub const PKCS7_R_NO_MULTIPART_BODY_FAILURE: u32 = 136;
pub const PKCS7_R_NO_MULTIPART_BOUNDARY: u32 = 137;
pub const PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE: u32 = 115;
pub const PKCS7_R_NO_RECIPIENT_MATCHES_KEY: u32 = 146;
pub const PKCS7_R_NO_SIGNATURES_ON_DATA: u32 = 123;
pub const PKCS7_R_NO_SIGNERS: u32 = 142;
pub const PKCS7_R_NO_SIG_CONTENT_TYPE: u32 = 138;
pub const PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE: u32 = 104;
pub const PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR: u32 = 124;
pub const PKCS7_R_PKCS7_ADD_SIGNER_ERROR: u32 = 153;
pub const PKCS7_R_PKCS7_DATAFINAL: u32 = 126;
pub const PKCS7_R_PKCS7_DATAFINAL_ERROR: u32 = 125;
pub const PKCS7_R_PKCS7_DATASIGN: u32 = 145;
pub const PKCS7_R_PKCS7_PARSE_ERROR: u32 = 139;
pub const PKCS7_R_PKCS7_SIG_PARSE_ERROR: u32 = 140;
pub const PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE: u32 = 127;
pub const PKCS7_R_SIGNATURE_FAILURE: u32 = 105;
pub const PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND: u32 = 128;
pub const PKCS7_R_SIGNING_CTRL_FAILURE: u32 = 147;
pub const PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 148;
pub const PKCS7_R_SIG_INVALID_MIME_TYPE: u32 = 141;
pub const PKCS7_R_SMIME_TEXT_ERROR: u32 = 129;
pub const PKCS7_R_UNABLE_TO_FIND_CERTIFICATE: u32 = 106;
pub const PKCS7_R_UNABLE_TO_FIND_MEM_BIO: u32 = 107;
pub const PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST: u32 = 108;
pub const PKCS7_R_UNKNOWN_DIGEST_TYPE: u32 = 109;
pub const PKCS7_R_UNKNOWN_OPERATION: u32 = 110;
pub const PKCS7_R_UNSUPPORTED_CIPHER_TYPE: u32 = 111;
pub const PKCS7_R_UNSUPPORTED_CONTENT_TYPE: u32 = 112;
pub const PKCS7_R_WRONG_CONTENT_TYPE: u32 = 113;
pub const PKCS7_R_WRONG_PKCS7_TYPE: u32 = 114;
pub const X509_EXT_PACK_UNKNOWN: u32 = 1;
pub const X509_EXT_PACK_STRING: u32 = 2;
pub const X509_F_ADD_CERT_DIR: u32 = 100;
pub const X509_F_BY_FILE_CTRL: u32 = 101;
pub const X509_F_CHECK_NAME_CONSTRAINTS: u32 = 106;
pub const X509_F_CHECK_POLICY: u32 = 145;
pub const X509_F_DIR_CTRL: u32 = 102;
pub const X509_F_GET_CERT_BY_SUBJECT: u32 = 103;
pub const X509_F_NETSCAPE_SPKI_B64_DECODE: u32 = 129;
pub const X509_F_NETSCAPE_SPKI_B64_ENCODE: u32 = 130;
pub const X509_F_X509AT_ADD1_ATTR: u32 = 135;
pub const X509_F_X509V3_ADD_EXT: u32 = 104;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_NID: u32 = 136;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ: u32 = 137;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_TXT: u32 = 140;
pub const X509_F_X509_ATTRIBUTE_GET0_DATA: u32 = 139;
pub const X509_F_X509_ATTRIBUTE_SET1_DATA: u32 = 138;
pub const X509_F_X509_CHECK_PRIVATE_KEY: u32 = 128;
pub const X509_F_X509_CRL_DIFF: u32 = 105;
pub const X509_F_X509_CRL_PRINT_FP: u32 = 147;
pub const X509_F_X509_EXTENSION_CREATE_BY_NID: u32 = 108;
pub const X509_F_X509_EXTENSION_CREATE_BY_OBJ: u32 = 109;
pub const X509_F_X509_GET_PUBKEY_PARAMETERS: u32 = 110;
pub const X509_F_X509_LOAD_CERT_CRL_FILE: u32 = 132;
pub const X509_F_X509_LOAD_CERT_FILE: u32 = 111;
pub const X509_F_X509_LOAD_CRL_FILE: u32 = 112;
pub const X509_F_X509_NAME_ADD_ENTRY: u32 = 113;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_NID: u32 = 114;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_TXT: u32 = 131;
pub const X509_F_X509_NAME_ENTRY_SET_OBJECT: u32 = 115;
pub const X509_F_X509_NAME_ONELINE: u32 = 116;
pub const X509_F_X509_NAME_PRINT: u32 = 117;
pub const X509_F_X509_PRINT_EX_FP: u32 = 118;
pub const X509_F_X509_PUBKEY_GET: u32 = 119;
pub const X509_F_X509_PUBKEY_SET: u32 = 120;
pub const X509_F_X509_REQ_CHECK_PRIVATE_KEY: u32 = 144;
pub const X509_F_X509_REQ_PRINT_EX: u32 = 121;
pub const X509_F_X509_REQ_PRINT_FP: u32 = 122;
pub const X509_F_X509_REQ_TO_X509: u32 = 123;
pub const X509_F_X509_STORE_ADD_CERT: u32 = 124;
pub const X509_F_X509_STORE_ADD_CRL: u32 = 125;
pub const X509_F_X509_STORE_CTX_GET1_ISSUER: u32 = 146;
pub const X509_F_X509_STORE_CTX_INIT: u32 = 143;
pub const X509_F_X509_STORE_CTX_NEW: u32 = 142;
pub const X509_F_X509_STORE_CTX_PURPOSE_INHERIT: u32 = 134;
pub const X509_F_X509_TO_X509_REQ: u32 = 126;
pub const X509_F_X509_TRUST_ADD: u32 = 133;
pub const X509_F_X509_TRUST_SET: u32 = 141;
pub const X509_F_X509_VERIFY_CERT: u32 = 127;
pub const X509_R_AKID_MISMATCH: u32 = 110;
pub const X509_R_BAD_X509_FILETYPE: u32 = 100;
pub const X509_R_BASE64_DECODE_ERROR: u32 = 118;
pub const X509_R_CANT_CHECK_DH_KEY: u32 = 114;
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE: u32 = 101;
pub const X509_R_CRL_ALREADY_DELTA: u32 = 127;
pub const X509_R_CRL_VERIFY_FAILURE: u32 = 131;
pub const X509_R_ERR_ASN1_LIB: u32 = 102;
pub const X509_R_IDP_MISMATCH: u32 = 128;
pub const X509_R_INVALID_DIRECTORY: u32 = 113;
pub const X509_R_INVALID_FIELD_NAME: u32 = 119;
pub const X509_R_INVALID_TRUST: u32 = 123;
pub const X509_R_ISSUER_MISMATCH: u32 = 129;
pub const X509_R_KEY_TYPE_MISMATCH: u32 = 115;
pub const X509_R_KEY_VALUES_MISMATCH: u32 = 116;
pub const X509_R_LOADING_CERT_DIR: u32 = 103;
pub const X509_R_LOADING_DEFAULTS: u32 = 104;
pub const X509_R_METHOD_NOT_SUPPORTED: u32 = 124;
pub const X509_R_NAME_TOO_LONG: u32 = 134;
pub const X509_R_NEWER_CRL_NOT_NEWER: u32 = 132;
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY: u32 = 105;
pub const X509_R_NO_CRL_NUMBER: u32 = 130;
pub const X509_R_PUBLIC_KEY_DECODE_ERROR: u32 = 125;
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR: u32 = 126;
pub const X509_R_SHOULD_RETRY: u32 = 106;
pub const X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN: u32 = 107;
pub const X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY: u32 = 108;
pub const X509_R_UNKNOWN_KEY_TYPE: u32 = 117;
pub const X509_R_UNKNOWN_NID: u32 = 109;
pub const X509_R_UNKNOWN_PURPOSE_ID: u32 = 121;
pub const X509_R_UNKNOWN_TRUST_ID: u32 = 120;
pub const X509_R_UNSUPPORTED_ALGORITHM: u32 = 111;
pub const X509_R_WRONG_LOOKUP_TYPE: u32 = 112;
pub const X509_R_WRONG_TYPE: u32 = 122;
pub const PEM_BUFSIZE: u32 = 1024;
pub const PEM_OBJ_UNDEF: u32 = 0;
pub const PEM_OBJ_X509: u32 = 1;
pub const PEM_OBJ_X509_REQ: u32 = 2;
pub const PEM_OBJ_CRL: u32 = 3;
pub const PEM_OBJ_SSL_SESSION: u32 = 4;
pub const PEM_OBJ_PRIV_KEY: u32 = 10;
pub const PEM_OBJ_PRIV_RSA: u32 = 11;
pub const PEM_OBJ_PRIV_DSA: u32 = 12;
pub const PEM_OBJ_PRIV_DH: u32 = 13;
pub const PEM_OBJ_PUB_RSA: u32 = 14;
pub const PEM_OBJ_PUB_DSA: u32 = 15;
pub const PEM_OBJ_PUB_DH: u32 = 16;
pub const PEM_OBJ_DHPARAMS: u32 = 17;
pub const PEM_OBJ_DSAPARAMS: u32 = 18;
pub const PEM_OBJ_PRIV_RSA_PUBLIC: u32 = 19;
pub const PEM_OBJ_PRIV_ECDSA: u32 = 20;
pub const PEM_OBJ_PUB_ECDSA: u32 = 21;
pub const PEM_OBJ_ECPARAMETERS: u32 = 22;
pub const PEM_ERROR: u32 = 30;
pub const PEM_DEK_DES_CBC: u32 = 40;
pub const PEM_DEK_IDEA_CBC: u32 = 45;
pub const PEM_DEK_DES_EDE: u32 = 50;
pub const PEM_DEK_DES_ECB: u32 = 60;
pub const PEM_DEK_RSA: u32 = 70;
pub const PEM_DEK_RSA_MD2: u32 = 80;
pub const PEM_DEK_RSA_MD5: u32 = 90;
pub const PEM_MD_MD2: u32 = 3;
pub const PEM_MD_MD5: u32 = 4;
pub const PEM_MD_SHA: u32 = 41;
pub const PEM_MD_MD2_RSA: u32 = 7;
pub const PEM_MD_MD5_RSA: u32 = 8;
pub const PEM_MD_SHA_RSA: u32 = 65;
pub const PEM_STRING_X509_OLD: &'static [u8; 17usize] = b"X509 CERTIFICATE\0";
pub const PEM_STRING_X509: &'static [u8; 12usize] = b"CERTIFICATE\0";
pub const PEM_STRING_X509_PAIR: &'static [u8; 17usize] = b"CERTIFICATE PAIR\0";
pub const PEM_STRING_X509_TRUSTED: &'static [u8; 20usize] = b"TRUSTED CERTIFICATE\0";
pub const PEM_STRING_X509_REQ_OLD: &'static [u8; 24usize] = b"NEW CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_REQ: &'static [u8; 20usize] = b"CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_CRL: &'static [u8; 9usize] = b"X509 CRL\0";
pub const PEM_STRING_EVP_PKEY: &'static [u8; 16usize] = b"ANY PRIVATE KEY\0";
pub const PEM_STRING_PUBLIC: &'static [u8; 11usize] = b"PUBLIC KEY\0";
pub const PEM_STRING_RSA: &'static [u8; 16usize] = b"RSA PRIVATE KEY\0";
pub const PEM_STRING_RSA_PUBLIC: &'static [u8; 15usize] = b"RSA PUBLIC KEY\0";
pub const PEM_STRING_DSA: &'static [u8; 16usize] = b"DSA PRIVATE KEY\0";
pub const PEM_STRING_DSA_PUBLIC: &'static [u8; 15usize] = b"DSA PUBLIC KEY\0";
pub const PEM_STRING_PKCS7: &'static [u8; 6usize] = b"PKCS7\0";
pub const PEM_STRING_PKCS7_SIGNED: &'static [u8; 20usize] = b"PKCS #7 SIGNED DATA\0";
pub const PEM_STRING_PKCS8: &'static [u8; 22usize] = b"ENCRYPTED PRIVATE KEY\0";
pub const PEM_STRING_PKCS8INF: &'static [u8; 12usize] = b"PRIVATE KEY\0";
pub const PEM_STRING_DHPARAMS: &'static [u8; 14usize] = b"DH PARAMETERS\0";
pub const PEM_STRING_DHXPARAMS: &'static [u8; 20usize] = b"X9.42 DH PARAMETERS\0";
pub const PEM_STRING_SSL_SESSION: &'static [u8; 23usize] = b"SSL SESSION PARAMETERS\0";
pub const PEM_STRING_DSAPARAMS: &'static [u8; 15usize] = b"DSA PARAMETERS\0";
pub const PEM_STRING_ECDSA_PUBLIC: &'static [u8; 17usize] = b"ECDSA PUBLIC KEY\0";
pub const PEM_STRING_ECPARAMETERS: &'static [u8; 14usize] = b"EC PARAMETERS\0";
pub const PEM_STRING_ECPRIVATEKEY: &'static [u8; 15usize] = b"EC PRIVATE KEY\0";
pub const PEM_STRING_PARAMETERS: &'static [u8; 11usize] = b"PARAMETERS\0";
pub const PEM_STRING_CMS: &'static [u8; 4usize] = b"CMS\0";
pub const PEM_TYPE_ENCRYPTED: u32 = 10;
pub const PEM_TYPE_MIC_ONLY: u32 = 20;
pub const PEM_TYPE_MIC_CLEAR: u32 = 30;
pub const PEM_TYPE_CLEAR: u32 = 40;
pub const PEM_F_B2I_DSS: u32 = 127;
pub const PEM_F_B2I_PVK_BIO: u32 = 128;
pub const PEM_F_B2I_RSA: u32 = 129;
pub const PEM_F_CHECK_BITLEN_DSA: u32 = 130;
pub const PEM_F_CHECK_BITLEN_RSA: u32 = 131;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_BIO: u32 = 120;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_FP: u32 = 121;
pub const PEM_F_DO_B2I: u32 = 132;
pub const PEM_F_DO_B2I_BIO: u32 = 133;
pub const PEM_F_DO_BLOB_HEADER: u32 = 134;
pub const PEM_F_DO_PK8PKEY: u32 = 126;
pub const PEM_F_DO_PK8PKEY_FP: u32 = 125;
pub const PEM_F_DO_PVK_BODY: u32 = 135;
pub const PEM_F_DO_PVK_HEADER: u32 = 136;
pub const PEM_F_I2B_PVK: u32 = 137;
pub const PEM_F_I2B_PVK_BIO: u32 = 138;
pub const PEM_F_LOAD_IV: u32 = 101;
pub const PEM_F_PEM_ASN1_READ: u32 = 102;
pub const PEM_F_PEM_ASN1_READ_BIO: u32 = 103;
pub const PEM_F_PEM_ASN1_WRITE: u32 = 104;
pub const PEM_F_PEM_ASN1_WRITE_BIO: u32 = 105;
pub const PEM_F_PEM_DEF_CALLBACK: u32 = 100;
pub const PEM_F_PEM_DO_HEADER: u32 = 106;
pub const PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY: u32 = 118;
pub const PEM_F_PEM_GET_EVP_CIPHER_INFO: u32 = 107;
pub const PEM_F_PEM_PK8PKEY: u32 = 119;
pub const PEM_F_PEM_READ: u32 = 108;
pub const PEM_F_PEM_READ_BIO: u32 = 109;
pub const PEM_F_PEM_READ_BIO_DHPARAMS: u32 = 141;
pub const PEM_F_PEM_READ_BIO_PARAMETERS: u32 = 140;
pub const PEM_F_PEM_READ_BIO_PRIVATEKEY: u32 = 123;
pub const PEM_F_PEM_READ_DHPARAMS: u32 = 142;
pub const PEM_F_PEM_READ_PRIVATEKEY: u32 = 124;
pub const PEM_F_PEM_SEALFINAL: u32 = 110;
pub const PEM_F_PEM_SEALINIT: u32 = 111;
pub const PEM_F_PEM_SIGNFINAL: u32 = 112;
pub const PEM_F_PEM_WRITE: u32 = 113;
pub const PEM_F_PEM_WRITE_BIO: u32 = 114;
pub const PEM_F_PEM_WRITE_PRIVATEKEY: u32 = 139;
pub const PEM_F_PEM_X509_INFO_READ: u32 = 115;
pub const PEM_F_PEM_X509_INFO_READ_BIO: u32 = 116;
pub const PEM_F_PEM_X509_INFO_WRITE_BIO: u32 = 117;
pub const PEM_R_BAD_BASE64_DECODE: u32 = 100;
pub const PEM_R_BAD_DECRYPT: u32 = 101;
pub const PEM_R_BAD_END_LINE: u32 = 102;
pub const PEM_R_BAD_IV_CHARS: u32 = 103;
pub const PEM_R_BAD_MAGIC_NUMBER: u32 = 116;
pub const PEM_R_BAD_PASSWORD_READ: u32 = 104;
pub const PEM_R_BAD_VERSION_NUMBER: u32 = 117;
pub const PEM_R_BIO_WRITE_FAILURE: u32 = 118;
pub const PEM_R_CIPHER_IS_NULL: u32 = 127;
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY: u32 = 115;
pub const PEM_R_EXPECTING_PRIVATE_KEY_BLOB: u32 = 119;
pub const PEM_R_EXPECTING_PUBLIC_KEY_BLOB: u32 = 120;
pub const PEM_R_HEADER_TOO_LONG: u32 = 128;
pub const PEM_R_INCONSISTENT_HEADER: u32 = 121;
pub const PEM_R_KEYBLOB_HEADER_PARSE_ERROR: u32 = 122;
pub const PEM_R_KEYBLOB_TOO_SHORT: u32 = 123;
pub const PEM_R_NOT_DEK_INFO: u32 = 105;
pub const PEM_R_NOT_ENCRYPTED: u32 = 106;
pub const PEM_R_NOT_PROC_TYPE: u32 = 107;
pub const PEM_R_NO_START_LINE: u32 = 108;
pub const PEM_R_PROBLEMS_GETTING_PASSWORD: u32 = 109;
pub const PEM_R_PUBLIC_KEY_NO_RSA: u32 = 110;
pub const PEM_R_PVK_DATA_TOO_SHORT: u32 = 124;
pub const PEM_R_PVK_TOO_SHORT: u32 = 125;
pub const PEM_R_READ_KEY: u32 = 111;
pub const PEM_R_SHORT_HEADER: u32 = 112;
pub const PEM_R_UNSUPPORTED_CIPHER: u32 = 113;
pub const PEM_R_UNSUPPORTED_ENCRYPTION: u32 = 114;
pub const PEM_R_UNSUPPORTED_KEY_COMPONENTS: u32 = 126;
pub const HMAC_MAX_MD_CBLOCK: u32 = 128;
pub const SSL_SESSION_ASN1_VERSION: u32 = 1;
pub const SSL_MAX_KRB5_PRINCIPAL_LENGTH: u32 = 256;
pub const SSL_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL_MAX_SID_CTX_LENGTH: u32 = 32;
pub const SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES: u32 = 64;
pub const SSL_MAX_KEY_ARG_LENGTH: u32 = 8;
pub const SSL_MAX_MASTER_KEY_LENGTH: u32 = 48;
pub const SSL_TXT_EXP40: &'static [u8; 9usize] = b"EXPORT40\0";
pub const SSL_TXT_EXP56: &'static [u8; 9usize] = b"EXPORT56\0";
pub const SSL_TXT_LOW: &'static [u8; 4usize] = b"LOW\0";
pub const SSL_TXT_MEDIUM: &'static [u8; 7usize] = b"MEDIUM\0";
pub const SSL_TXT_HIGH: &'static [u8; 5usize] = b"HIGH\0";
pub const SSL_TXT_FIPS: &'static [u8; 5usize] = b"FIPS\0";
pub const SSL_TXT_kFZA: &'static [u8; 5usize] = b"kFZA\0";
pub const SSL_TXT_aFZA: &'static [u8; 5usize] = b"aFZA\0";
pub const SSL_TXT_eFZA: &'static [u8; 5usize] = b"eFZA\0";
pub const SSL_TXT_FZA: &'static [u8; 4usize] = b"FZA\0";
pub const SSL_TXT_aNULL: &'static [u8; 6usize] = b"aNULL\0";
pub const SSL_TXT_eNULL: &'static [u8; 6usize] = b"eNULL\0";
pub const SSL_TXT_NULL: &'static [u8; 5usize] = b"NULL\0";
pub const SSL_TXT_kRSA: &'static [u8; 5usize] = b"kRSA\0";
pub const SSL_TXT_kDHr: &'static [u8; 5usize] = b"kDHr\0";
pub const SSL_TXT_kDHd: &'static [u8; 5usize] = b"kDHd\0";
pub const SSL_TXT_kDH: &'static [u8; 4usize] = b"kDH\0";
pub const SSL_TXT_kEDH: &'static [u8; 5usize] = b"kEDH\0";
pub const SSL_TXT_kDHE: &'static [u8; 5usize] = b"kDHE\0";
pub const SSL_TXT_kKRB5: &'static [u8; 6usize] = b"kKRB5\0";
pub const SSL_TXT_kECDHr: &'static [u8; 7usize] = b"kECDHr\0";
pub const SSL_TXT_kECDHe: &'static [u8; 7usize] = b"kECDHe\0";
pub const SSL_TXT_kECDH: &'static [u8; 6usize] = b"kECDH\0";
pub const SSL_TXT_kEECDH: &'static [u8; 7usize] = b"kEECDH\0";
pub const SSL_TXT_kECDHE: &'static [u8; 7usize] = b"kECDHE\0";
pub const SSL_TXT_kPSK: &'static [u8; 5usize] = b"kPSK\0";
pub const SSL_TXT_kGOST: &'static [u8; 6usize] = b"kGOST\0";
pub const SSL_TXT_kSRP: &'static [u8; 5usize] = b"kSRP\0";
pub const SSL_TXT_aRSA: &'static [u8; 5usize] = b"aRSA\0";
pub const SSL_TXT_aDSS: &'static [u8; 5usize] = b"aDSS\0";
pub const SSL_TXT_aDH: &'static [u8; 4usize] = b"aDH\0";
pub const SSL_TXT_aECDH: &'static [u8; 6usize] = b"aECDH\0";
pub const SSL_TXT_aKRB5: &'static [u8; 6usize] = b"aKRB5\0";
pub const SSL_TXT_aECDSA: &'static [u8; 7usize] = b"aECDSA\0";
pub const SSL_TXT_aPSK: &'static [u8; 5usize] = b"aPSK\0";
pub const SSL_TXT_aGOST94: &'static [u8; 8usize] = b"aGOST94\0";
pub const SSL_TXT_aGOST01: &'static [u8; 8usize] = b"aGOST01\0";
pub const SSL_TXT_aGOST: &'static [u8; 6usize] = b"aGOST\0";
pub const SSL_TXT_aSRP: &'static [u8; 5usize] = b"aSRP\0";
pub const SSL_TXT_DSS: &'static [u8; 4usize] = b"DSS\0";
pub const SSL_TXT_DH: &'static [u8; 3usize] = b"DH\0";
pub const SSL_TXT_EDH: &'static [u8; 4usize] = b"EDH\0";
pub const SSL_TXT_DHE: &'static [u8; 4usize] = b"DHE\0";
pub const SSL_TXT_ADH: &'static [u8; 4usize] = b"ADH\0";
pub const SSL_TXT_RSA: &'static [u8; 4usize] = b"RSA\0";
pub const SSL_TXT_ECDH: &'static [u8; 5usize] = b"ECDH\0";
pub const SSL_TXT_EECDH: &'static [u8; 6usize] = b"EECDH\0";
pub const SSL_TXT_ECDHE: &'static [u8; 6usize] = b"ECDHE\0";
pub const SSL_TXT_AECDH: &'static [u8; 6usize] = b"AECDH\0";
pub const SSL_TXT_ECDSA: &'static [u8; 6usize] = b"ECDSA\0";
pub const SSL_TXT_KRB5: &'static [u8; 5usize] = b"KRB5\0";
pub const SSL_TXT_PSK: &'static [u8; 4usize] = b"PSK\0";
pub const SSL_TXT_SRP: &'static [u8; 4usize] = b"SRP\0";
pub const SSL_TXT_DES: &'static [u8; 4usize] = b"DES\0";
pub const SSL_TXT_3DES: &'static [u8; 5usize] = b"3DES\0";
pub const SSL_TXT_RC4: &'static [u8; 4usize] = b"RC4\0";
pub const SSL_TXT_RC2: &'static [u8; 4usize] = b"RC2\0";
pub const SSL_TXT_IDEA: &'static [u8; 5usize] = b"IDEA\0";
pub const SSL_TXT_SEED: &'static [u8; 5usize] = b"SEED\0";
pub const SSL_TXT_AES128: &'static [u8; 7usize] = b"AES128\0";
pub const SSL_TXT_AES256: &'static [u8; 7usize] = b"AES256\0";
pub const SSL_TXT_AES: &'static [u8; 4usize] = b"AES\0";
pub const SSL_TXT_AES_GCM: &'static [u8; 7usize] = b"AESGCM\0";
pub const SSL_TXT_CAMELLIA128: &'static [u8; 12usize] = b"CAMELLIA128\0";
pub const SSL_TXT_CAMELLIA256: &'static [u8; 12usize] = b"CAMELLIA256\0";
pub const SSL_TXT_CAMELLIA: &'static [u8; 9usize] = b"CAMELLIA\0";
pub const SSL_TXT_MD5: &'static [u8; 4usize] = b"MD5\0";
pub const SSL_TXT_SHA1: &'static [u8; 5usize] = b"SHA1\0";
pub const SSL_TXT_SHA: &'static [u8; 4usize] = b"SHA\0";
pub const SSL_TXT_GOST94: &'static [u8; 7usize] = b"GOST94\0";
pub const SSL_TXT_GOST89MAC: &'static [u8; 10usize] = b"GOST89MAC\0";
pub const SSL_TXT_SHA256: &'static [u8; 7usize] = b"SHA256\0";
pub const SSL_TXT_SHA384: &'static [u8; 7usize] = b"SHA384\0";
pub const SSL_TXT_SSLV2: &'static [u8; 6usize] = b"SSLv2\0";
pub const SSL_TXT_SSLV3: &'static [u8; 6usize] = b"SSLv3\0";
pub const SSL_TXT_TLSV1: &'static [u8; 6usize] = b"TLSv1\0";
pub const SSL_TXT_TLSV1_1: &'static [u8; 8usize] = b"TLSv1.1\0";
pub const SSL_TXT_TLSV1_2: &'static [u8; 8usize] = b"TLSv1.2\0";
pub const SSL_TXT_EXP: &'static [u8; 4usize] = b"EXP\0";
pub const SSL_TXT_EXPORT: &'static [u8; 7usize] = b"EXPORT\0";
pub const SSL_TXT_ALL: &'static [u8; 4usize] = b"ALL\0";
pub const SSL_TXT_CMPALL: &'static [u8; 16usize] = b"COMPLEMENTOFALL\0";
pub const SSL_TXT_CMPDEF: &'static [u8; 20usize] = b"COMPLEMENTOFDEFAULT\0";
pub const SSL_DEFAULT_CIPHER_LIST: &'static [u8; 38usize] =
    b"ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2\0";
pub const SSL_SENT_SHUTDOWN: u32 = 1;
pub const SSL_RECEIVED_SHUTDOWN: u32 = 2;
pub const SSL_FILETYPE_ASN1: u32 = 2;
pub const SSL_FILETYPE_PEM: u32 = 1;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG: u32 = 1;
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: u32 = 2;
pub const SSL_OP_LEGACY_SERVER_CONNECT: u32 = 4;
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: u32 = 8;
pub const SSL_OP_TLSEXT_PADDING: u32 = 16;
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: u32 = 32;
pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG: u32 = 64;
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: u32 = 128;
pub const SSL_OP_TLS_D5_BUG: u32 = 256;
pub const SSL_OP_TLS_BLOCK_PADDING_BUG: u32 = 512;
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING: u32 = 0;
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: u32 = 0;
pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: u32 = 2048;
pub const SSL_OP_ALL: u32 = 2147486719;
pub const SSL_OP_NO_QUERY_MTU: u32 = 4096;
pub const SSL_OP_COOKIE_EXCHANGE: u32 = 8192;
pub const SSL_OP_NO_TICKET: u32 = 16384;
pub const SSL_OP_CISCO_ANYCONNECT: u32 = 32768;
pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: u32 = 65536;
pub const SSL_OP_NO_COMPRESSION: u32 = 131072;
pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: u32 = 262144;
pub const SSL_OP_SINGLE_ECDH_USE: u32 = 524288;
pub const SSL_OP_SINGLE_DH_USE: u32 = 1048576;
pub const SSL_OP_EPHEMERAL_RSA: u32 = 0;
pub const SSL_OP_CIPHER_SERVER_PREFERENCE: u32 = 4194304;
pub const SSL_OP_TLS_ROLLBACK_BUG: u32 = 8388608;
pub const SSL_OP_NO_SSLv2: u32 = 16777216;
pub const SSL_OP_NO_SSLv3: u32 = 33554432;
pub const SSL_OP_NO_TLSv1: u32 = 67108864;
pub const SSL_OP_NO_TLSv1_2: u32 = 134217728;
pub const SSL_OP_NO_TLSv1_1: u32 = 268435456;
pub const SSL_OP_NO_DTLSv1: u32 = 67108864;
pub const SSL_OP_NO_DTLSv1_2: u32 = 134217728;
pub const SSL_OP_NO_SSL_MASK: u32 = 520093696;
pub const SSL_OP_PKCS1_CHECK_1: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_2: u32 = 0;
pub const SSL_OP_NETSCAPE_CA_DN_BUG: u32 = 536870912;
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: u32 = 1073741824;
pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG: u32 = 2147483648;
pub const SSL_MODE_ENABLE_PARTIAL_WRITE: u32 = 1;
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER: u32 = 2;
pub const SSL_MODE_AUTO_RETRY: u32 = 4;
pub const SSL_MODE_NO_AUTO_CHAIN: u32 = 8;
pub const SSL_MODE_RELEASE_BUFFERS: u32 = 16;
pub const SSL_MODE_SEND_CLIENTHELLO_TIME: u32 = 32;
pub const SSL_MODE_SEND_SERVERHELLO_TIME: u32 = 64;
pub const SSL_MODE_SEND_FALLBACK_SCSV: u32 = 128;
pub const SSL_CERT_FLAG_TLS_STRICT: u32 = 1;
pub const SSL_CERT_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const SSL_CERT_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const SSL_CERT_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const SSL_CERT_FLAG_BROKEN_PROTOCOL: u32 = 268435456;
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED: u32 = 1;
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT: u32 = 2;
pub const SSL_BUILD_CHAIN_FLAG_CHECK: u32 = 4;
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR: u32 = 8;
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR: u32 = 16;
pub const CERT_PKEY_VALID: u32 = 1;
pub const CERT_PKEY_SIGN: u32 = 2;
pub const CERT_PKEY_EE_SIGNATURE: u32 = 16;
pub const CERT_PKEY_CA_SIGNATURE: u32 = 32;
pub const CERT_PKEY_EE_PARAM: u32 = 64;
pub const CERT_PKEY_CA_PARAM: u32 = 128;
pub const CERT_PKEY_EXPLICIT_SIGN: u32 = 256;
pub const CERT_PKEY_ISSUER_NAME: u32 = 512;
pub const CERT_PKEY_CERT_TYPE: u32 = 1024;
pub const CERT_PKEY_SUITEB: u32 = 2048;
pub const SSL_CONF_FLAG_CMDLINE: u32 = 1;
pub const SSL_CONF_FLAG_FILE: u32 = 2;
pub const SSL_CONF_FLAG_CLIENT: u32 = 4;
pub const SSL_CONF_FLAG_SERVER: u32 = 8;
pub const SSL_CONF_FLAG_SHOW_ERRORS: u32 = 16;
pub const SSL_CONF_FLAG_CERTIFICATE: u32 = 32;
pub const SSL_CONF_TYPE_UNKNOWN: u32 = 0;
pub const SSL_CONF_TYPE_STRING: u32 = 1;
pub const SSL_CONF_TYPE_FILE: u32 = 2;
pub const SSL_CONF_TYPE_DIR: u32 = 3;
pub const SSL_MAX_CERT_LIST_DEFAULT: u32 = 102400;
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT: u32 = 20480;
pub const SSL_MAX_BUF_FREELIST_LEN_DEFAULT: u32 = 32;
pub const SSL_SESS_CACHE_OFF: u32 = 0;
pub const SSL_SESS_CACHE_CLIENT: u32 = 1;
pub const SSL_SESS_CACHE_SERVER: u32 = 2;
pub const SSL_SESS_CACHE_BOTH: u32 = 3;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR: u32 = 128;
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP: u32 = 256;
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE: u32 = 512;
pub const SSL_SESS_CACHE_NO_INTERNAL: u32 = 768;
pub const OPENSSL_NPN_UNSUPPORTED: u32 = 0;
pub const OPENSSL_NPN_NEGOTIATED: u32 = 1;
pub const OPENSSL_NPN_NO_OVERLAP: u32 = 2;
pub const PSK_MAX_IDENTITY_LEN: u32 = 128;
pub const PSK_MAX_PSK_LEN: u32 = 256;
pub const SSL_NOTHING: u32 = 1;
pub const SSL_WRITING: u32 = 2;
pub const SSL_READING: u32 = 3;
pub const SSL_X509_LOOKUP: u32 = 4;
pub const SSL_MAC_FLAG_READ_MAC_STREAM: u32 = 1;
pub const SSL_MAC_FLAG_WRITE_MAC_STREAM: u32 = 2;
pub const SSL2_VERSION: u32 = 2;
pub const SSL2_VERSION_MAJOR: u32 = 0;
pub const SSL2_VERSION_MINOR: u32 = 2;
pub const SSL2_MT_ERROR: u32 = 0;
pub const SSL2_MT_CLIENT_HELLO: u32 = 1;
pub const SSL2_MT_CLIENT_MASTER_KEY: u32 = 2;
pub const SSL2_MT_CLIENT_FINISHED: u32 = 3;
pub const SSL2_MT_SERVER_HELLO: u32 = 4;
pub const SSL2_MT_SERVER_VERIFY: u32 = 5;
pub const SSL2_MT_SERVER_FINISHED: u32 = 6;
pub const SSL2_MT_REQUEST_CERTIFICATE: u32 = 7;
pub const SSL2_MT_CLIENT_CERTIFICATE: u32 = 8;
pub const SSL2_PE_UNDEFINED_ERROR: u32 = 0;
pub const SSL2_PE_NO_CIPHER: u32 = 1;
pub const SSL2_PE_NO_CERTIFICATE: u32 = 2;
pub const SSL2_PE_BAD_CERTIFICATE: u32 = 4;
pub const SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE: u32 = 6;
pub const SSL2_CK_NULL_WITH_MD5: u32 = 33554432;
pub const SSL2_CK_RC4_128_WITH_MD5: u32 = 33620096;
pub const SSL2_CK_RC4_128_EXPORT40_WITH_MD5: u32 = 33685632;
pub const SSL2_CK_RC2_128_CBC_WITH_MD5: u32 = 33751168;
pub const SSL2_CK_RC2_128_CBC_EXPORT40_WITH_MD5: u32 = 33816704;
pub const SSL2_CK_IDEA_128_CBC_WITH_MD5: u32 = 33882240;
pub const SSL2_CK_DES_64_CBC_WITH_MD5: u32 = 33947712;
pub const SSL2_CK_DES_64_CBC_WITH_SHA: u32 = 33947968;
pub const SSL2_CK_DES_192_EDE3_CBC_WITH_MD5: u32 = 34013376;
pub const SSL2_CK_DES_192_EDE3_CBC_WITH_SHA: u32 = 34013632;
pub const SSL2_CK_RC4_64_WITH_MD5: u32 = 34078848;
pub const SSL2_CK_DES_64_CFB64_WITH_MD5_1: u32 = 50268160;
pub const SSL2_CK_NULL: u32 = 50268176;
pub const SSL2_TXT_DES_64_CFB64_WITH_MD5_1: &'static [u8; 11usize] = b"DES-CFB-M1\0";
pub const SSL2_TXT_NULL_WITH_MD5: &'static [u8; 9usize] = b"NULL-MD5\0";
pub const SSL2_TXT_RC4_128_WITH_MD5: &'static [u8; 8usize] = b"RC4-MD5\0";
pub const SSL2_TXT_RC4_128_EXPORT40_WITH_MD5: &'static [u8; 12usize] = b"EXP-RC4-MD5\0";
pub const SSL2_TXT_RC2_128_CBC_WITH_MD5: &'static [u8; 12usize] = b"RC2-CBC-MD5\0";
pub const SSL2_TXT_RC2_128_CBC_EXPORT40_WITH_MD5: &'static [u8; 16usize] = b"EXP-RC2-CBC-MD5\0";
pub const SSL2_TXT_IDEA_128_CBC_WITH_MD5: &'static [u8; 13usize] = b"IDEA-CBC-MD5\0";
pub const SSL2_TXT_DES_64_CBC_WITH_MD5: &'static [u8; 12usize] = b"DES-CBC-MD5\0";
pub const SSL2_TXT_DES_64_CBC_WITH_SHA: &'static [u8; 12usize] = b"DES-CBC-SHA\0";
pub const SSL2_TXT_DES_192_EDE3_CBC_WITH_MD5: &'static [u8; 13usize] = b"DES-CBC3-MD5\0";
pub const SSL2_TXT_DES_192_EDE3_CBC_WITH_SHA: &'static [u8; 13usize] = b"DES-CBC3-SHA\0";
pub const SSL2_TXT_RC4_64_WITH_MD5: &'static [u8; 11usize] = b"RC4-64-MD5\0";
pub const SSL2_TXT_NULL: &'static [u8; 5usize] = b"NULL\0";
pub const SSL2_CF_5_BYTE_ENC: u32 = 1;
pub const SSL2_CF_8_BYTE_ENC: u32 = 2;
pub const SSL2_CT_X509_CERTIFICATE: u32 = 1;
pub const SSL2_AT_MD5_WITH_RSA_ENCRYPTION: u32 = 1;
pub const SSL2_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL2_MAX_MASTER_KEY_LENGTH_IN_BITS: u32 = 256;
pub const SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER: u32 = 32767;
pub const SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER: u32 = 16383;
pub const SSL2_CHALLENGE_LENGTH: u32 = 16;
pub const SSL2_MIN_CHALLENGE_LENGTH: u32 = 16;
pub const SSL2_MAX_CHALLENGE_LENGTH: u32 = 32;
pub const SSL2_CONNECTION_ID_LENGTH: u32 = 16;
pub const SSL2_MAX_CONNECTION_ID_LENGTH: u32 = 16;
pub const SSL2_SSL_SESSION_ID_LENGTH: u32 = 16;
pub const SSL2_MAX_CERT_CHALLENGE_LENGTH: u32 = 32;
pub const SSL2_MIN_CERT_CHALLENGE_LENGTH: u32 = 16;
pub const SSL2_MAX_KEY_MATERIAL_LENGTH: u32 = 24;
pub const SSL3_CK_SCSV: u32 = 50331903;
pub const SSL3_CK_FALLBACK_SCSV: u32 = 50353664;
pub const SSL3_CK_RSA_NULL_MD5: u32 = 50331649;
pub const SSL3_CK_RSA_NULL_SHA: u32 = 50331650;
pub const SSL3_CK_RSA_RC4_40_MD5: u32 = 50331651;
pub const SSL3_CK_RSA_RC4_128_MD5: u32 = 50331652;
pub const SSL3_CK_RSA_RC4_128_SHA: u32 = 50331653;
pub const SSL3_CK_RSA_RC2_40_MD5: u32 = 50331654;
pub const SSL3_CK_RSA_IDEA_128_SHA: u32 = 50331655;
pub const SSL3_CK_RSA_DES_40_CBC_SHA: u32 = 50331656;
pub const SSL3_CK_RSA_DES_64_CBC_SHA: u32 = 50331657;
pub const SSL3_CK_RSA_DES_192_CBC3_SHA: u32 = 50331658;
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA: u32 = 50331659;
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA: u32 = 50331660;
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA: u32 = 50331661;
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA: u32 = 50331662;
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA: u32 = 50331663;
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA: u32 = 50331664;
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_DHE_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_DHE_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_DHE_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_DHE_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_DHE_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_DHE_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_ADH_RC4_40_MD5: u32 = 50331671;
pub const SSL3_CK_ADH_RC4_128_MD5: u32 = 50331672;
pub const SSL3_CK_ADH_DES_40_CBC_SHA: u32 = 50331673;
pub const SSL3_CK_ADH_DES_64_CBC_SHA: u32 = 50331674;
pub const SSL3_CK_ADH_DES_192_CBC_SHA: u32 = 50331675;
pub const SSL3_CK_KRB5_DES_64_CBC_SHA: u32 = 50331678;
pub const SSL3_CK_KRB5_DES_192_CBC3_SHA: u32 = 50331679;
pub const SSL3_CK_KRB5_RC4_128_SHA: u32 = 50331680;
pub const SSL3_CK_KRB5_IDEA_128_CBC_SHA: u32 = 50331681;
pub const SSL3_CK_KRB5_DES_64_CBC_MD5: u32 = 50331682;
pub const SSL3_CK_KRB5_DES_192_CBC3_MD5: u32 = 50331683;
pub const SSL3_CK_KRB5_RC4_128_MD5: u32 = 50331684;
pub const SSL3_CK_KRB5_IDEA_128_CBC_MD5: u32 = 50331685;
pub const SSL3_CK_KRB5_DES_40_CBC_SHA: u32 = 50331686;
pub const SSL3_CK_KRB5_RC2_40_CBC_SHA: u32 = 50331687;
pub const SSL3_CK_KRB5_RC4_40_SHA: u32 = 50331688;
pub const SSL3_CK_KRB5_DES_40_CBC_MD5: u32 = 50331689;
pub const SSL3_CK_KRB5_RC2_40_CBC_MD5: u32 = 50331690;
pub const SSL3_CK_KRB5_RC4_40_MD5: u32 = 50331691;
pub const SSL3_TXT_RSA_NULL_MD5: &'static [u8; 9usize] = b"NULL-MD5\0";
pub const SSL3_TXT_RSA_NULL_SHA: &'static [u8; 9usize] = b"NULL-SHA\0";
pub const SSL3_TXT_RSA_RC4_40_MD5: &'static [u8; 12usize] = b"EXP-RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_MD5: &'static [u8; 8usize] = b"RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_SHA: &'static [u8; 8usize] = b"RC4-SHA\0";
pub const SSL3_TXT_RSA_RC2_40_MD5: &'static [u8; 16usize] = b"EXP-RC2-CBC-MD5\0";
pub const SSL3_TXT_RSA_IDEA_128_SHA: &'static [u8; 13usize] = b"IDEA-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA: &'static [u8; 16usize] = b"EXP-DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA: &'static [u8; 12usize] = b"DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA: &'static [u8; 13usize] = b"DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA: &'static [u8; 23usize] = b"EXP-DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA: &'static [u8; 19usize] = b"DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA: &'static [u8; 20usize] = b"DH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA: &'static [u8; 23usize] = b"EXP-DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA: &'static [u8; 19usize] = b"DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA: &'static [u8; 20usize] = b"DH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_40_CBC_SHA: &'static [u8; 24usize] = b"EXP-DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_64_CBC_SHA: &'static [u8; 20usize] = b"DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA: &'static [u8; 21usize] = b"DHE-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_40_CBC_SHA: &'static [u8; 24usize] = b"EXP-DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_64_CBC_SHA: &'static [u8; 20usize] = b"DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA: &'static [u8; 21usize] = b"DHE-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA: &'static [u8; 24usize] = b"EXP-EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA: &'static [u8; 20usize] = b"EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA: &'static [u8; 21usize] = b"EDH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA: &'static [u8; 24usize] = b"EXP-EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA: &'static [u8; 20usize] = b"EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA: &'static [u8; 21usize] = b"EDH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_ADH_RC4_40_MD5: &'static [u8; 16usize] = b"EXP-ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_RC4_128_MD5: &'static [u8; 12usize] = b"ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA: &'static [u8; 20usize] = b"EXP-ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA: &'static [u8; 16usize] = b"ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA: &'static [u8; 17usize] = b"ADH-DES-CBC3-SHA\0";
pub const SSL3_TXT_KRB5_DES_64_CBC_SHA: &'static [u8; 17usize] = b"KRB5-DES-CBC-SHA\0";
pub const SSL3_TXT_KRB5_DES_192_CBC3_SHA: &'static [u8; 18usize] = b"KRB5-DES-CBC3-SHA\0";
pub const SSL3_TXT_KRB5_RC4_128_SHA: &'static [u8; 13usize] = b"KRB5-RC4-SHA\0";
pub const SSL3_TXT_KRB5_IDEA_128_CBC_SHA: &'static [u8; 18usize] = b"KRB5-IDEA-CBC-SHA\0";
pub const SSL3_TXT_KRB5_DES_64_CBC_MD5: &'static [u8; 17usize] = b"KRB5-DES-CBC-MD5\0";
pub const SSL3_TXT_KRB5_DES_192_CBC3_MD5: &'static [u8; 18usize] = b"KRB5-DES-CBC3-MD5\0";
pub const SSL3_TXT_KRB5_RC4_128_MD5: &'static [u8; 13usize] = b"KRB5-RC4-MD5\0";
pub const SSL3_TXT_KRB5_IDEA_128_CBC_MD5: &'static [u8; 18usize] = b"KRB5-IDEA-CBC-MD5\0";
pub const SSL3_TXT_KRB5_DES_40_CBC_SHA: &'static [u8; 21usize] = b"EXP-KRB5-DES-CBC-SHA\0";
pub const SSL3_TXT_KRB5_RC2_40_CBC_SHA: &'static [u8; 21usize] = b"EXP-KRB5-RC2-CBC-SHA\0";
pub const SSL3_TXT_KRB5_RC4_40_SHA: &'static [u8; 17usize] = b"EXP-KRB5-RC4-SHA\0";
pub const SSL3_TXT_KRB5_DES_40_CBC_MD5: &'static [u8; 21usize] = b"EXP-KRB5-DES-CBC-MD5\0";
pub const SSL3_TXT_KRB5_RC2_40_CBC_MD5: &'static [u8; 21usize] = b"EXP-KRB5-RC2-CBC-MD5\0";
pub const SSL3_TXT_KRB5_RC4_40_MD5: &'static [u8; 17usize] = b"EXP-KRB5-RC4-MD5\0";
pub const SSL3_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MASTER_SECRET_SIZE: u32 = 48;
pub const SSL3_RANDOM_SIZE: u32 = 32;
pub const SSL3_SESSION_ID_SIZE: u32 = 32;
pub const SSL3_RT_HEADER_LENGTH: u32 = 5;
pub const SSL3_HM_HEADER_LENGTH: u32 = 4;
pub const SSL3_ALIGN_PAYLOAD: u32 = 8;
pub const SSL3_RT_MAX_MD_SIZE: u32 = 64;
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE: u32 = 16;
pub const SSL3_RT_MAX_EXTRA: u32 = 16384;
pub const SSL3_RT_MAX_PLAIN_LENGTH: u32 = 16384;
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD: u32 = 1024;
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD: u32 = 320;
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD: u32 = 80;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH: u32 = 17408;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH: u32 = 17728;
pub const SSL3_RT_MAX_PACKET_SIZE: u32 = 17733;
pub const SSL3_MD_CLIENT_FINISHED_CONST: &'static [u8; 5usize] = b"CLNT\0";
pub const SSL3_MD_SERVER_FINISHED_CONST: &'static [u8; 5usize] = b"SRVR\0";
pub const SSL3_VERSION: u32 = 768;
pub const SSL3_VERSION_MAJOR: u32 = 3;
pub const SSL3_VERSION_MINOR: u32 = 0;
pub const SSL3_RT_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL3_RT_ALERT: u32 = 21;
pub const SSL3_RT_HANDSHAKE: u32 = 22;
pub const SSL3_RT_APPLICATION_DATA: u32 = 23;
pub const TLS1_RT_HEARTBEAT: u32 = 24;
pub const TLS1_RT_CRYPTO: u32 = 4096;
pub const TLS1_RT_CRYPTO_PREMASTER: u32 = 4097;
pub const TLS1_RT_CRYPTO_CLIENT_RANDOM: u32 = 4098;
pub const TLS1_RT_CRYPTO_SERVER_RANDOM: u32 = 4099;
pub const TLS1_RT_CRYPTO_MASTER: u32 = 4100;
pub const TLS1_RT_CRYPTO_READ: u32 = 0;
pub const TLS1_RT_CRYPTO_WRITE: u32 = 256;
pub const TLS1_RT_CRYPTO_MAC: u32 = 4101;
pub const TLS1_RT_CRYPTO_KEY: u32 = 4102;
pub const TLS1_RT_CRYPTO_IV: u32 = 4103;
pub const TLS1_RT_CRYPTO_FIXED_IV: u32 = 4104;
pub const SSL3_RT_HEADER: u32 = 256;
pub const SSL3_AL_WARNING: u32 = 1;
pub const SSL3_AL_FATAL: u32 = 2;
pub const SSL3_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL3_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL3_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL3_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL3_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL3_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL3_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL3_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL3_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL3_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL3_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const TLS1_HB_REQUEST: u32 = 1;
pub const TLS1_HB_RESPONSE: u32 = 2;
pub const SSL3_CT_RSA_SIGN: u32 = 1;
pub const SSL3_CT_DSS_SIGN: u32 = 2;
pub const SSL3_CT_RSA_FIXED_DH: u32 = 3;
pub const SSL3_CT_DSS_FIXED_DH: u32 = 4;
pub const SSL3_CT_RSA_EPHEMERAL_DH: u32 = 5;
pub const SSL3_CT_DSS_EPHEMERAL_DH: u32 = 6;
pub const SSL3_CT_FORTEZZA_DMS: u32 = 20;
pub const SSL3_CT_NUMBER: u32 = 9;
pub const SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS: u32 = 1;
pub const SSL3_FLAGS_DELAY_CLIENT_FINISHED: u32 = 2;
pub const SSL3_FLAGS_POP_BUFFER: u32 = 4;
pub const TLS1_FLAGS_TLS_PADDING_BUG: u32 = 8;
pub const TLS1_FLAGS_SKIP_CERT_VERIFY: u32 = 16;
pub const TLS1_FLAGS_KEEP_HANDSHAKE: u32 = 32;
pub const SSL3_FLAGS_CCS_OK: u32 = 128;
pub const SSL3_FLAGS_SGC_RESTART_DONE: u32 = 64;
pub const SSL3_MT_HELLO_REQUEST: u32 = 0;
pub const SSL3_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_MT_SERVER_HELLO: u32 = 2;
pub const SSL3_MT_NEWSESSION_TICKET: u32 = 4;
pub const SSL3_MT_CERTIFICATE: u32 = 11;
pub const SSL3_MT_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL3_MT_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL3_MT_SERVER_DONE: u32 = 14;
pub const SSL3_MT_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL3_MT_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL3_MT_FINISHED: u32 = 20;
pub const SSL3_MT_CERTIFICATE_STATUS: u32 = 22;
pub const SSL3_MT_NEXT_PROTO: u32 = 67;
pub const DTLS1_MT_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL3_MT_CCS: u32 = 1;
pub const SSL3_CC_READ: u32 = 1;
pub const SSL3_CC_WRITE: u32 = 2;
pub const SSL3_CC_CLIENT: u32 = 16;
pub const SSL3_CC_SERVER: u32 = 32;
pub const SSL3_CHANGE_CIPHER_CLIENT_WRITE: u32 = 18;
pub const SSL3_CHANGE_CIPHER_SERVER_READ: u32 = 33;
pub const SSL3_CHANGE_CIPHER_CLIENT_READ: u32 = 17;
pub const SSL3_CHANGE_CIPHER_SERVER_WRITE: u32 = 34;
pub const TLS1_ALLOW_EXPERIMENTAL_CIPHERSUITES: u32 = 0;
pub const TLS1_VERSION: u32 = 769;
pub const TLS1_1_VERSION: u32 = 770;
pub const TLS1_2_VERSION: u32 = 771;
pub const TLS_MAX_VERSION: u32 = 771;
pub const TLS1_VERSION_MAJOR: u32 = 3;
pub const TLS1_VERSION_MINOR: u32 = 1;
pub const TLS1_1_VERSION_MAJOR: u32 = 3;
pub const TLS1_1_VERSION_MINOR: u32 = 2;
pub const TLS1_2_VERSION_MAJOR: u32 = 3;
pub const TLS1_2_VERSION_MINOR: u32 = 3;
pub const TLS1_AD_DECRYPTION_FAILED: u32 = 21;
pub const TLS1_AD_RECORD_OVERFLOW: u32 = 22;
pub const TLS1_AD_UNKNOWN_CA: u32 = 48;
pub const TLS1_AD_ACCESS_DENIED: u32 = 49;
pub const TLS1_AD_DECODE_ERROR: u32 = 50;
pub const TLS1_AD_DECRYPT_ERROR: u32 = 51;
pub const TLS1_AD_EXPORT_RESTRICTION: u32 = 60;
pub const TLS1_AD_PROTOCOL_VERSION: u32 = 70;
pub const TLS1_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const TLS1_AD_INTERNAL_ERROR: u32 = 80;
pub const TLS1_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const TLS1_AD_USER_CANCELLED: u32 = 90;
pub const TLS1_AD_NO_RENEGOTIATION: u32 = 100;
pub const TLS1_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const TLS1_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const TLSEXT_TYPE_server_name: u32 = 0;
pub const TLSEXT_TYPE_max_fragment_length: u32 = 1;
pub const TLSEXT_TYPE_client_certificate_url: u32 = 2;
pub const TLSEXT_TYPE_trusted_ca_keys: u32 = 3;
pub const TLSEXT_TYPE_truncated_hmac: u32 = 4;
pub const TLSEXT_TYPE_status_request: u32 = 5;
pub const TLSEXT_TYPE_user_mapping: u32 = 6;
pub const TLSEXT_TYPE_client_authz: u32 = 7;
pub const TLSEXT_TYPE_server_authz: u32 = 8;
pub const TLSEXT_TYPE_cert_type: u32 = 9;
pub const TLSEXT_TYPE_elliptic_curves: u32 = 10;
pub const TLSEXT_TYPE_ec_point_formats: u32 = 11;
pub const TLSEXT_TYPE_srp: u32 = 12;
pub const TLSEXT_TYPE_signature_algorithms: u32 = 13;
pub const TLSEXT_TYPE_use_srtp: u32 = 14;
pub const TLSEXT_TYPE_heartbeat: u32 = 15;
pub const TLSEXT_TYPE_application_layer_protocol_negotiation: u32 = 16;
pub const TLSEXT_TYPE_padding: u32 = 21;
pub const TLSEXT_TYPE_session_ticket: u32 = 35;
pub const TLSEXT_TYPE_renegotiate: u32 = 65281;
pub const TLSEXT_TYPE_next_proto_neg: u32 = 13172;
pub const TLSEXT_NAMETYPE_host_name: u32 = 0;
pub const TLSEXT_STATUSTYPE_ocsp: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_first: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_uncompressed: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2: u32 = 2;
pub const TLSEXT_ECPOINTFORMAT_last: u32 = 2;
pub const TLSEXT_signature_anonymous: u32 = 0;
pub const TLSEXT_signature_rsa: u32 = 1;
pub const TLSEXT_signature_dsa: u32 = 2;
pub const TLSEXT_signature_ecdsa: u32 = 3;
pub const TLSEXT_signature_num: u32 = 4;
pub const TLSEXT_hash_none: u32 = 0;
pub const TLSEXT_hash_md5: u32 = 1;
pub const TLSEXT_hash_sha1: u32 = 2;
pub const TLSEXT_hash_sha224: u32 = 3;
pub const TLSEXT_hash_sha256: u32 = 4;
pub const TLSEXT_hash_sha384: u32 = 5;
pub const TLSEXT_hash_sha512: u32 = 6;
pub const TLSEXT_hash_num: u32 = 7;
pub const TLSEXT_nid_unknown: u32 = 16777216;
pub const TLSEXT_curve_P_256: u32 = 23;
pub const TLSEXT_curve_P_384: u32 = 24;
pub const TLSEXT_MAXLEN_host_name: u32 = 255;
pub const SSL_TLSEXT_ERR_OK: u32 = 0;
pub const SSL_TLSEXT_ERR_ALERT_WARNING: u32 = 1;
pub const SSL_TLSEXT_ERR_ALERT_FATAL: u32 = 2;
pub const SSL_TLSEXT_ERR_NOACK: u32 = 3;
pub const SSL_TLSEXT_HB_ENABLED: u32 = 1;
pub const SSL_TLSEXT_HB_DONT_SEND_REQUESTS: u32 = 2;
pub const SSL_TLSEXT_HB_DONT_RECV_REQUESTS: u32 = 4;
pub const TLS1_CK_PSK_WITH_RC4_128_SHA: u32 = 50331786;
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331787;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA: u32 = 50331788;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA: u32 = 50331789;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5: u32 = 50331744;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5: u32 = 50331745;
pub const TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA: u32 = 50331746;
pub const TLS1_CK_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA: u32 = 50331747;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA: u32 = 50331748;
pub const TLS1_CK_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA: u32 = 50331749;
pub const TLS1_CK_DHE_DSS_WITH_RC4_128_SHA: u32 = 50331750;
pub const TLS1_CK_RSA_WITH_AES_128_SHA: u32 = 50331695;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA: u32 = 50331696;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA: u32 = 50331697;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA: u32 = 50331698;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA: u32 = 50331699;
pub const TLS1_CK_ADH_WITH_AES_128_SHA: u32 = 50331700;
pub const TLS1_CK_RSA_WITH_AES_256_SHA: u32 = 50331701;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA: u32 = 50331702;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA: u32 = 50331703;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA: u32 = 50331704;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA: u32 = 50331705;
pub const TLS1_CK_ADH_WITH_AES_256_SHA: u32 = 50331706;
pub const TLS1_CK_RSA_WITH_NULL_SHA256: u32 = 50331707;
pub const TLS1_CK_RSA_WITH_AES_128_SHA256: u32 = 50331708;
pub const TLS1_CK_RSA_WITH_AES_256_SHA256: u32 = 50331709;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256: u32 = 50331710;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256: u32 = 50331711;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: u32 = 50331712;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331713;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331714;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331715;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331716;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331717;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331718;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: u32 = 50331751;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256: u32 = 50331752;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256: u32 = 50331753;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: u32 = 50331754;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: u32 = 50331755;
pub const TLS1_CK_ADH_WITH_AES_128_SHA256: u32 = 50331756;
pub const TLS1_CK_ADH_WITH_AES_256_SHA256: u32 = 50331757;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331780;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331781;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331782;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331783;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331784;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331785;
pub const TLS1_CK_RSA_WITH_SEED_SHA: u32 = 50331798;
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA: u32 = 50331799;
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA: u32 = 50331800;
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA: u32 = 50331801;
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA: u32 = 50331802;
pub const TLS1_CK_ADH_WITH_SEED_SHA: u32 = 50331803;
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331804;
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331805;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331806;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331807;
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331808;
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331809;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331810;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331811;
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331812;
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331813;
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: u32 = 50331814;
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: u32 = 50331815;
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: u32 = 50380801;
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 50380802;
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380803;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380804;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380805;
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 50380806;
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 50380807;
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380808;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380809;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380810;
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA: u32 = 50380811;
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: u32 = 50380812;
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380813;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 50380814;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 50380815;
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: u32 = 50380816;
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 50380817;
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380818;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 50380819;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 50380820;
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA: u32 = 50380821;
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: u32 = 50380822;
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: u32 = 50380823;
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 50380824;
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 50380825;
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: u32 = 50380826;
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 50380827;
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 50380828;
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: u32 = 50380829;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: u32 = 50380830;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: u32 = 50380831;
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: u32 = 50380832;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: u32 = 50380833;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: u32 = 50380834;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: u32 = 50380835;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: u32 = 50380836;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: u32 = 50380837;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: u32 = 50380838;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: u32 = 50380839;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: u32 = 50380840;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: u32 = 50380841;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: u32 = 50380842;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380843;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380844;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380845;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380846;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380847;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380848;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380849;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380850;
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC4_56_MD5: &'static [u8; 16usize] = b"EXP1024-RC4-MD5\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5: &'static [u8; 20usize] =
    b"EXP1024-RC2-CBC-MD5\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_DES_CBC_SHA: &'static [u8; 20usize] =
    b"EXP1024-DES-CBC-SHA\0";
pub const TLS1_TXT_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA: &'static [u8; 28usize] =
    b"EXP1024-DHE-DSS-DES-CBC-SHA\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC4_56_SHA: &'static [u8; 16usize] = b"EXP1024-RC4-SHA\0";
pub const TLS1_TXT_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA: &'static [u8; 24usize] =
    b"EXP1024-DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA: &'static [u8; 16usize] = b"DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA: &'static [u8; 11usize] = b"AES128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA: &'static [u8; 18usize] = b"DH-DSS-AES128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA: &'static [u8; 18usize] = b"DH-RSA-AES128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA: &'static [u8; 19usize] = b"DHE-DSS-AES128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA: &'static [u8; 19usize] = b"DHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA: &'static [u8; 15usize] = b"ADH-AES128-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA: &'static [u8; 11usize] = b"AES256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA: &'static [u8; 18usize] = b"DH-DSS-AES256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA: &'static [u8; 18usize] = b"DH-RSA-AES256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA: &'static [u8; 19usize] = b"DHE-DSS-AES256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA: &'static [u8; 19usize] = b"DHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA: &'static [u8; 15usize] = b"ADH-AES256-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA: &'static [u8; 20usize] = b"ECDH-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA: &'static [u8; 19usize] = b"ECDH-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: &'static [u8; 24usize] =
    b"ECDH-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA: &'static [u8; 22usize] =
    b"ECDH-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA: &'static [u8; 22usize] =
    b"ECDH-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA: &'static [u8; 21usize] = b"ECDHE-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA: &'static [u8; 20usize] = b"ECDHE-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &'static [u8; 25usize] =
    b"ECDHE-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &'static [u8; 23usize] =
    b"ECDHE-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &'static [u8; 23usize] =
    b"ECDHE-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA: &'static [u8; 18usize] = b"ECDH-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA: &'static [u8; 17usize] = b"ECDH-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA: &'static [u8; 22usize] =
    b"ECDH-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA: &'static [u8; 20usize] = b"ECDH-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA: &'static [u8; 20usize] = b"ECDH-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA: &'static [u8; 19usize] = b"ECDHE-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA: &'static [u8; 18usize] = b"ECDHE-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &'static [u8; 23usize] =
    b"ECDHE-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA: &'static [u8; 21usize] =
    b"ECDHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA: &'static [u8; 21usize] =
    b"ECDHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA: &'static [u8; 15usize] = b"AECDH-NULL-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA: &'static [u8; 14usize] = b"AECDH-RC4-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA: &'static [u8; 19usize] =
    b"AECDH-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA: &'static [u8; 17usize] = b"AECDH-AES128-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA: &'static [u8; 17usize] = b"AECDH-AES256-SHA\0";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA: &'static [u8; 12usize] = b"PSK-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA: &'static [u8; 21usize] = b"PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA: &'static [u8; 19usize] = b"PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA: &'static [u8; 19usize] = b"PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &'static [u8; 21usize] =
    b"SRP-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &'static [u8; 25usize] =
    b"SRP-RSA-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &'static [u8; 25usize] =
    b"SRP-DSS-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA: &'static [u8; 20usize] = b"SRP-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &'static [u8; 24usize] =
    b"SRP-RSA-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &'static [u8; 24usize] =
    b"SRP-DSS-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA: &'static [u8; 20usize] = b"SRP-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &'static [u8; 24usize] =
    b"SRP-RSA-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &'static [u8; 24usize] =
    b"SRP-DSS-AES-256-CBC-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 16usize] = b"CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 23usize] =
    b"DH-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 23usize] =
    b"DH-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 24usize] =
    b"DHE-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 24usize] =
    b"DHE-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA: &'static [u8; 20usize] = b"ADH-CAMELLIA128-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 16usize] = b"CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 23usize] =
    b"DH-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 23usize] =
    b"DH-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 24usize] =
    b"DHE-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 24usize] =
    b"DHE-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA: &'static [u8; 20usize] = b"ADH-CAMELLIA256-SHA\0";
pub const TLS1_TXT_RSA_WITH_SEED_SHA: &'static [u8; 9usize] = b"SEED-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA: &'static [u8; 16usize] = b"DH-DSS-SEED-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA: &'static [u8; 16usize] = b"DH-RSA-SEED-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA: &'static [u8; 17usize] = b"DHE-DSS-SEED-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA: &'static [u8; 17usize] = b"DHE-RSA-SEED-SHA\0";
pub const TLS1_TXT_ADH_WITH_SEED_SHA: &'static [u8; 13usize] = b"ADH-SEED-SHA\0";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256: &'static [u8; 12usize] = b"NULL-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256: &'static [u8; 14usize] = b"AES128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256: &'static [u8; 14usize] = b"AES256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256: &'static [u8; 21usize] = b"DH-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256: &'static [u8; 21usize] = b"DH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256: &'static [u8; 22usize] = b"DHE-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256: &'static [u8; 22usize] = b"DHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256: &'static [u8; 21usize] = b"DH-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256: &'static [u8; 21usize] = b"DH-RSA-AES256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256: &'static [u8; 22usize] = b"DHE-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256: &'static [u8; 22usize] = b"DHE-RSA-AES256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256: &'static [u8; 18usize] = b"ADH-AES128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256: &'static [u8; 18usize] = b"ADH-AES256-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256: &'static [u8; 18usize] = b"AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384: &'static [u8; 18usize] = b"AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256: &'static [u8; 26usize] =
    b"DHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384: &'static [u8; 26usize] =
    b"DHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256: &'static [u8; 25usize] =
    b"DH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384: &'static [u8; 25usize] =
    b"DH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256: &'static [u8; 26usize] =
    b"DHE-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384: &'static [u8; 26usize] =
    b"DHE-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256: &'static [u8; 25usize] =
    b"DH-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384: &'static [u8; 25usize] =
    b"DH-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256: &'static [u8; 22usize] = b"ADH-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384: &'static [u8; 22usize] = b"ADH-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256: &'static [u8; 26usize] =
    b"ECDHE-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384: &'static [u8; 26usize] =
    b"ECDHE-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256: &'static [u8; 25usize] =
    b"ECDH-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384: &'static [u8; 25usize] =
    b"ECDH-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256: &'static [u8; 24usize] =
    b"ECDHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384: &'static [u8; 24usize] =
    b"ECDHE-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256: &'static [u8; 23usize] =
    b"ECDH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384: &'static [u8; 23usize] =
    b"ECDH-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &'static [u8; 30usize] =
    b"ECDHE-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &'static [u8; 30usize] =
    b"ECDHE-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: &'static [u8; 29usize] =
    b"ECDH-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: &'static [u8; 29usize] =
    b"ECDH-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &'static [u8; 28usize] =
    b"ECDHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &'static [u8; 28usize] =
    b"ECDHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256: &'static [u8; 27usize] =
    b"ECDH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384: &'static [u8; 27usize] =
    b"ECDH-RSA-AES256-GCM-SHA384\0";
pub const TLS_CT_RSA_SIGN: u32 = 1;
pub const TLS_CT_DSS_SIGN: u32 = 2;
pub const TLS_CT_RSA_FIXED_DH: u32 = 3;
pub const TLS_CT_DSS_FIXED_DH: u32 = 4;
pub const TLS_CT_ECDSA_SIGN: u32 = 64;
pub const TLS_CT_RSA_FIXED_ECDH: u32 = 65;
pub const TLS_CT_ECDSA_FIXED_ECDH: u32 = 66;
pub const TLS_CT_GOST94_SIGN: u32 = 21;
pub const TLS_CT_GOST01_SIGN: u32 = 22;
pub const TLS_CT_NUMBER: u32 = 9;
pub const TLS1_FINISH_MAC_LENGTH: u32 = 12;
pub const TLS_MD_MAX_CONST_SIZE: u32 = 20;
pub const TLS_MD_CLIENT_FINISH_CONST: &'static [u8; 16usize] = b"client finished\0";
pub const TLS_MD_CLIENT_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_SERVER_FINISH_CONST: &'static [u8; 16usize] = b"server finished\0";
pub const TLS_MD_SERVER_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_SERVER_WRITE_KEY_CONST: &'static [u8; 17usize] = b"server write key\0";
pub const TLS_MD_SERVER_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_KEY_EXPANSION_CONST: &'static [u8; 14usize] = b"key expansion\0";
pub const TLS_MD_KEY_EXPANSION_CONST_SIZE: u32 = 13;
pub const TLS_MD_CLIENT_WRITE_KEY_CONST: &'static [u8; 17usize] = b"client write key\0";
pub const TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_IV_BLOCK_CONST: &'static [u8; 9usize] = b"IV block\0";
pub const TLS_MD_IV_BLOCK_CONST_SIZE: u32 = 8;
pub const TLS_MD_MASTER_SECRET_CONST: &'static [u8; 14usize] = b"master secret\0";
pub const TLS_MD_MASTER_SECRET_CONST_SIZE: u32 = 13;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const DTLS1_VERSION: u32 = 65279;
pub const DTLS1_2_VERSION: u32 = 65277;
pub const DTLS_MAX_VERSION: u32 = 65277;
pub const DTLS1_VERSION_MAJOR: u32 = 254;
pub const DTLS1_BAD_VER: u32 = 256;
pub const DTLS_ANY_VERSION: u32 = 131071;
pub const DTLS1_COOKIE_LENGTH: u32 = 256;
pub const DTLS1_RT_HEADER_LENGTH: u32 = 13;
pub const DTLS1_HM_HEADER_LENGTH: u32 = 12;
pub const DTLS1_HM_BAD_FRAGMENT: i32 = -2;
pub const DTLS1_HM_FRAGMENT_RETRY: i32 = -3;
pub const DTLS1_CCS_HEADER_LENGTH: u32 = 1;
pub const DTLS1_AL_HEADER_LENGTH: u32 = 2;
pub const DTLS1_MAX_MTU_OVERHEAD: u32 = 48;
pub const DTLS1_TMO_READ_COUNT: u32 = 2;
pub const DTLS1_TMO_WRITE_COUNT: u32 = 2;
pub const DTLS1_TMO_ALERT_COUNT: u32 = 12;
pub const SRTP_AES128_CM_SHA1_80: u32 = 1;
pub const SRTP_AES128_CM_SHA1_32: u32 = 2;
pub const SRTP_AES128_F8_SHA1_80: u32 = 3;
pub const SRTP_AES128_F8_SHA1_32: u32 = 4;
pub const SRTP_NULL_SHA1_80: u32 = 5;
pub const SRTP_NULL_SHA1_32: u32 = 6;
pub const SSL_ST_CONNECT: u32 = 4096;
pub const SSL_ST_ACCEPT: u32 = 8192;
pub const SSL_ST_MASK: u32 = 4095;
pub const SSL_ST_INIT: u32 = 12288;
pub const SSL_ST_BEFORE: u32 = 16384;
pub const SSL_ST_OK: u32 = 3;
pub const SSL_ST_RENEGOTIATE: u32 = 12292;
pub const SSL_ST_ERR: u32 = 12293;
pub const SSL_CB_LOOP: u32 = 1;
pub const SSL_CB_EXIT: u32 = 2;
pub const SSL_CB_READ: u32 = 4;
pub const SSL_CB_WRITE: u32 = 8;
pub const SSL_CB_ALERT: u32 = 16384;
pub const SSL_CB_READ_ALERT: u32 = 16388;
pub const SSL_CB_WRITE_ALERT: u32 = 16392;
pub const SSL_CB_ACCEPT_LOOP: u32 = 8193;
pub const SSL_CB_ACCEPT_EXIT: u32 = 8194;
pub const SSL_CB_CONNECT_LOOP: u32 = 4097;
pub const SSL_CB_CONNECT_EXIT: u32 = 4098;
pub const SSL_CB_HANDSHAKE_START: u32 = 16;
pub const SSL_CB_HANDSHAKE_DONE: u32 = 32;
pub const SSL_ST_READ_HEADER: u32 = 240;
pub const SSL_ST_READ_BODY: u32 = 241;
pub const SSL_ST_READ_DONE: u32 = 242;
pub const SSL_VERIFY_NONE: u32 = 0;
pub const SSL_VERIFY_PEER: u32 = 1;
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: u32 = 2;
pub const SSL_VERIFY_CLIENT_ONCE: u32 = 4;
pub const SSL_AD_REASON_OFFSET: u32 = 1000;
pub const SSL_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL_AD_DECRYPTION_FAILED: u32 = 21;
pub const SSL_AD_RECORD_OVERFLOW: u32 = 22;
pub const SSL_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_AD_UNKNOWN_CA: u32 = 48;
pub const SSL_AD_ACCESS_DENIED: u32 = 49;
pub const SSL_AD_DECODE_ERROR: u32 = 50;
pub const SSL_AD_DECRYPT_ERROR: u32 = 51;
pub const SSL_AD_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_AD_PROTOCOL_VERSION: u32 = 70;
pub const SSL_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_AD_INTERNAL_ERROR: u32 = 80;
pub const SSL_AD_USER_CANCELLED: u32 = 90;
pub const SSL_AD_NO_RENEGOTIATION: u32 = 100;
pub const SSL_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const SSL_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_ERROR_NONE: u32 = 0;
pub const SSL_ERROR_SSL: u32 = 1;
pub const SSL_ERROR_WANT_READ: u32 = 2;
pub const SSL_ERROR_WANT_WRITE: u32 = 3;
pub const SSL_ERROR_WANT_X509_LOOKUP: u32 = 4;
pub const SSL_ERROR_SYSCALL: u32 = 5;
pub const SSL_ERROR_ZERO_RETURN: u32 = 6;
pub const SSL_ERROR_WANT_CONNECT: u32 = 7;
pub const SSL_ERROR_WANT_ACCEPT: u32 = 8;
pub const SSL_CTRL_NEED_TMP_RSA: u32 = 1;
pub const SSL_CTRL_SET_TMP_RSA: u32 = 2;
pub const SSL_CTRL_SET_TMP_DH: u32 = 3;
pub const SSL_CTRL_SET_TMP_ECDH: u32 = 4;
pub const SSL_CTRL_SET_TMP_RSA_CB: u32 = 5;
pub const SSL_CTRL_SET_TMP_DH_CB: u32 = 6;
pub const SSL_CTRL_SET_TMP_ECDH_CB: u32 = 7;
pub const SSL_CTRL_GET_SESSION_REUSED: u32 = 8;
pub const SSL_CTRL_GET_CLIENT_CERT_REQUEST: u32 = 9;
pub const SSL_CTRL_GET_NUM_RENEGOTIATIONS: u32 = 10;
pub const SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS: u32 = 11;
pub const SSL_CTRL_GET_TOTAL_RENEGOTIATIONS: u32 = 12;
pub const SSL_CTRL_GET_FLAGS: u32 = 13;
pub const SSL_CTRL_EXTRA_CHAIN_CERT: u32 = 14;
pub const SSL_CTRL_SET_MSG_CALLBACK: u32 = 15;
pub const SSL_CTRL_SET_MSG_CALLBACK_ARG: u32 = 16;
pub const SSL_CTRL_SET_MTU: u32 = 17;
pub const SSL_CTRL_SESS_NUMBER: u32 = 20;
pub const SSL_CTRL_SESS_CONNECT: u32 = 21;
pub const SSL_CTRL_SESS_CONNECT_GOOD: u32 = 22;
pub const SSL_CTRL_SESS_CONNECT_RENEGOTIATE: u32 = 23;
pub const SSL_CTRL_SESS_ACCEPT: u32 = 24;
pub const SSL_CTRL_SESS_ACCEPT_GOOD: u32 = 25;
pub const SSL_CTRL_SESS_ACCEPT_RENEGOTIATE: u32 = 26;
pub const SSL_CTRL_SESS_HIT: u32 = 27;
pub const SSL_CTRL_SESS_CB_HIT: u32 = 28;
pub const SSL_CTRL_SESS_MISSES: u32 = 29;
pub const SSL_CTRL_SESS_TIMEOUTS: u32 = 30;
pub const SSL_CTRL_SESS_CACHE_FULL: u32 = 31;
pub const SSL_CTRL_OPTIONS: u32 = 32;
pub const SSL_CTRL_MODE: u32 = 33;
pub const SSL_CTRL_GET_READ_AHEAD: u32 = 40;
pub const SSL_CTRL_SET_READ_AHEAD: u32 = 41;
pub const SSL_CTRL_SET_SESS_CACHE_SIZE: u32 = 42;
pub const SSL_CTRL_GET_SESS_CACHE_SIZE: u32 = 43;
pub const SSL_CTRL_SET_SESS_CACHE_MODE: u32 = 44;
pub const SSL_CTRL_GET_SESS_CACHE_MODE: u32 = 45;
pub const SSL_CTRL_GET_MAX_CERT_LIST: u32 = 50;
pub const SSL_CTRL_SET_MAX_CERT_LIST: u32 = 51;
pub const SSL_CTRL_SET_MAX_SEND_FRAGMENT: u32 = 52;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB: u32 = 53;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG: u32 = 54;
pub const SSL_CTRL_SET_TLSEXT_HOSTNAME: u32 = 55;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_CB: u32 = 56;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_ARG: u32 = 57;
pub const SSL_CTRL_GET_TLSEXT_TICKET_KEYS: u32 = 58;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEYS: u32 = 59;
pub const SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT: u32 = 60;
pub const SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB: u32 = 61;
pub const SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG: u32 = 62;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB: u32 = 63;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG: u32 = 64;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: u32 = 65;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS: u32 = 66;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS: u32 = 67;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS: u32 = 68;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS: u32 = 69;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 70;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 71;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB: u32 = 72;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB: u32 = 75;
pub const SSL_CTRL_SET_SRP_VERIFY_PARAM_CB: u32 = 76;
pub const SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB: u32 = 77;
pub const SSL_CTRL_SET_SRP_ARG: u32 = 78;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME: u32 = 79;
pub const SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH: u32 = 80;
pub const SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD: u32 = 81;
pub const SSL_CTRL_TLS_EXT_SEND_HEARTBEAT: u32 = 85;
pub const SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING: u32 = 86;
pub const SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS: u32 = 87;
pub const DTLS_CTRL_GET_TIMEOUT: u32 = 73;
pub const DTLS_CTRL_HANDLE_TIMEOUT: u32 = 74;
pub const DTLS_CTRL_LISTEN: u32 = 75;
pub const SSL_CTRL_GET_RI_SUPPORT: u32 = 76;
pub const SSL_CTRL_CLEAR_OPTIONS: u32 = 77;
pub const SSL_CTRL_CLEAR_MODE: u32 = 78;
pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS: u32 = 82;
pub const SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS: u32 = 83;
pub const SSL_CTRL_CHAIN: u32 = 88;
pub const SSL_CTRL_CHAIN_CERT: u32 = 89;
pub const SSL_CTRL_GET_CURVES: u32 = 90;
pub const SSL_CTRL_SET_CURVES: u32 = 91;
pub const SSL_CTRL_SET_CURVES_LIST: u32 = 92;
pub const SSL_CTRL_GET_SHARED_CURVE: u32 = 93;
pub const SSL_CTRL_SET_ECDH_AUTO: u32 = 94;
pub const SSL_CTRL_SET_SIGALGS: u32 = 97;
pub const SSL_CTRL_SET_SIGALGS_LIST: u32 = 98;
pub const SSL_CTRL_CERT_FLAGS: u32 = 99;
pub const SSL_CTRL_CLEAR_CERT_FLAGS: u32 = 100;
pub const SSL_CTRL_SET_CLIENT_SIGALGS: u32 = 101;
pub const SSL_CTRL_SET_CLIENT_SIGALGS_LIST: u32 = 102;
pub const SSL_CTRL_GET_CLIENT_CERT_TYPES: u32 = 103;
pub const SSL_CTRL_SET_CLIENT_CERT_TYPES: u32 = 104;
pub const SSL_CTRL_BUILD_CERT_CHAIN: u32 = 105;
pub const SSL_CTRL_SET_VERIFY_CERT_STORE: u32 = 106;
pub const SSL_CTRL_SET_CHAIN_CERT_STORE: u32 = 107;
pub const SSL_CTRL_GET_PEER_SIGNATURE_NID: u32 = 108;
pub const SSL_CTRL_GET_SERVER_TMP_KEY: u32 = 109;
pub const SSL_CTRL_GET_RAW_CIPHERLIST: u32 = 110;
pub const SSL_CTRL_GET_EC_POINT_FORMATS: u32 = 111;
pub const SSL_CTRL_GET_CHAIN_CERTS: u32 = 115;
pub const SSL_CTRL_SELECT_CURRENT_CERT: u32 = 116;
pub const SSL_CTRL_SET_CURRENT_CERT: u32 = 117;
pub const SSL_CTRL_CHECK_PROTO_VERSION: u32 = 119;
pub const DTLS_CTRL_SET_LINK_MTU: u32 = 120;
pub const DTLS_CTRL_GET_LINK_MIN_MTU: u32 = 121;
pub const SSL_CERT_SET_FIRST: u32 = 1;
pub const SSL_CERT_SET_NEXT: u32 = 2;
pub const SSL_CERT_SET_SERVER: u32 = 3;
pub const SSL_F_CHECK_SUITEB_CIPHER_LIST: u32 = 331;
pub const SSL_F_CLIENT_CERTIFICATE: u32 = 100;
pub const SSL_F_CLIENT_FINISHED: u32 = 167;
pub const SSL_F_CLIENT_HELLO: u32 = 101;
pub const SSL_F_CLIENT_MASTER_KEY: u32 = 102;
pub const SSL_F_D2I_SSL_SESSION: u32 = 103;
pub const SSL_F_DO_DTLS1_WRITE: u32 = 245;
pub const SSL_F_DO_SSL3_WRITE: u32 = 104;
pub const SSL_F_DTLS1_ACCEPT: u32 = 246;
pub const SSL_F_DTLS1_ADD_CERT_TO_BUF: u32 = 295;
pub const SSL_F_DTLS1_BUFFER_RECORD: u32 = 247;
pub const SSL_F_DTLS1_CHECK_TIMEOUT_NUM: u32 = 316;
pub const SSL_F_DTLS1_CLIENT_HELLO: u32 = 248;
pub const SSL_F_DTLS1_CONNECT: u32 = 249;
pub const SSL_F_DTLS1_ENC: u32 = 250;
pub const SSL_F_DTLS1_GET_HELLO_VERIFY: u32 = 251;
pub const SSL_F_DTLS1_GET_MESSAGE: u32 = 252;
pub const SSL_F_DTLS1_GET_MESSAGE_FRAGMENT: u32 = 253;
pub const SSL_F_DTLS1_GET_RECORD: u32 = 254;
pub const SSL_F_DTLS1_HANDLE_TIMEOUT: u32 = 297;
pub const SSL_F_DTLS1_HEARTBEAT: u32 = 305;
pub const SSL_F_DTLS1_OUTPUT_CERT_CHAIN: u32 = 255;
pub const SSL_F_DTLS1_PREPROCESS_FRAGMENT: u32 = 288;
pub const SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS: u32 = 424;
pub const SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE: u32 = 256;
pub const SSL_F_DTLS1_PROCESS_RECORD: u32 = 257;
pub const SSL_F_DTLS1_READ_BYTES: u32 = 258;
pub const SSL_F_DTLS1_READ_FAILED: u32 = 259;
pub const SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST: u32 = 260;
pub const SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE: u32 = 261;
pub const SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE: u32 = 262;
pub const SSL_F_DTLS1_SEND_CLIENT_VERIFY: u32 = 263;
pub const SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST: u32 = 264;
pub const SSL_F_DTLS1_SEND_SERVER_CERTIFICATE: u32 = 265;
pub const SSL_F_DTLS1_SEND_SERVER_HELLO: u32 = 266;
pub const SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE: u32 = 267;
pub const SSL_F_DTLS1_WRITE_APP_DATA_BYTES: u32 = 268;
pub const SSL_F_GET_CLIENT_FINISHED: u32 = 105;
pub const SSL_F_GET_CLIENT_HELLO: u32 = 106;
pub const SSL_F_GET_CLIENT_MASTER_KEY: u32 = 107;
pub const SSL_F_GET_SERVER_FINISHED: u32 = 108;
pub const SSL_F_GET_SERVER_HELLO: u32 = 109;
pub const SSL_F_GET_SERVER_STATIC_DH_KEY: u32 = 340;
pub const SSL_F_GET_SERVER_VERIFY: u32 = 110;
pub const SSL_F_I2D_SSL_SESSION: u32 = 111;
pub const SSL_F_READ_N: u32 = 112;
pub const SSL_F_REQUEST_CERTIFICATE: u32 = 113;
pub const SSL_F_SERVER_FINISH: u32 = 239;
pub const SSL_F_SERVER_HELLO: u32 = 114;
pub const SSL_F_SERVER_VERIFY: u32 = 240;
pub const SSL_F_SSL23_ACCEPT: u32 = 115;
pub const SSL_F_SSL23_CLIENT_HELLO: u32 = 116;
pub const SSL_F_SSL23_CONNECT: u32 = 117;
pub const SSL_F_SSL23_GET_CLIENT_HELLO: u32 = 118;
pub const SSL_F_SSL23_GET_SERVER_HELLO: u32 = 119;
pub const SSL_F_SSL23_PEEK: u32 = 237;
pub const SSL_F_SSL23_READ: u32 = 120;
pub const SSL_F_SSL23_WRITE: u32 = 121;
pub const SSL_F_SSL2_ACCEPT: u32 = 122;
pub const SSL_F_SSL2_CONNECT: u32 = 123;
pub const SSL_F_SSL2_ENC_INIT: u32 = 124;
pub const SSL_F_SSL2_GENERATE_KEY_MATERIAL: u32 = 241;
pub const SSL_F_SSL2_PEEK: u32 = 234;
pub const SSL_F_SSL2_READ: u32 = 125;
pub const SSL_F_SSL2_READ_INTERNAL: u32 = 236;
pub const SSL_F_SSL2_SET_CERTIFICATE: u32 = 126;
pub const SSL_F_SSL2_WRITE: u32 = 127;
pub const SSL_F_SSL3_ACCEPT: u32 = 128;
pub const SSL_F_SSL3_ADD_CERT_TO_BUF: u32 = 296;
pub const SSL_F_SSL3_CALLBACK_CTRL: u32 = 233;
pub const SSL_F_SSL3_CHANGE_CIPHER_STATE: u32 = 129;
pub const SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM: u32 = 130;
pub const SSL_F_SSL3_CHECK_CLIENT_HELLO: u32 = 304;
pub const SSL_F_SSL3_CHECK_FINISHED: u32 = 339;
pub const SSL_F_SSL3_CLIENT_HELLO: u32 = 131;
pub const SSL_F_SSL3_CONNECT: u32 = 132;
pub const SSL_F_SSL3_CTRL: u32 = 213;
pub const SSL_F_SSL3_CTX_CTRL: u32 = 133;
pub const SSL_F_SSL3_DIGEST_CACHED_RECORDS: u32 = 293;
pub const SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC: u32 = 292;
pub const SSL_F_SSL3_ENC: u32 = 134;
pub const SSL_F_SSL3_GENERATE_KEY_BLOCK: u32 = 238;
pub const SSL_F_SSL3_GENERATE_MASTER_SECRET: u32 = 388;
pub const SSL_F_SSL3_GET_CERTIFICATE_REQUEST: u32 = 135;
pub const SSL_F_SSL3_GET_CERT_STATUS: u32 = 289;
pub const SSL_F_SSL3_GET_CERT_VERIFY: u32 = 136;
pub const SSL_F_SSL3_GET_CLIENT_CERTIFICATE: u32 = 137;
pub const SSL_F_SSL3_GET_CLIENT_HELLO: u32 = 138;
pub const SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE: u32 = 139;
pub const SSL_F_SSL3_GET_FINISHED: u32 = 140;
pub const SSL_F_SSL3_GET_KEY_EXCHANGE: u32 = 141;
pub const SSL_F_SSL3_GET_MESSAGE: u32 = 142;
pub const SSL_F_SSL3_GET_NEW_SESSION_TICKET: u32 = 283;
pub const SSL_F_SSL3_GET_NEXT_PROTO: u32 = 306;
pub const SSL_F_SSL3_GET_RECORD: u32 = 143;
pub const SSL_F_SSL3_GET_SERVER_CERTIFICATE: u32 = 144;
pub const SSL_F_SSL3_GET_SERVER_DONE: u32 = 145;
pub const SSL_F_SSL3_GET_SERVER_HELLO: u32 = 146;
pub const SSL_F_SSL3_HANDSHAKE_MAC: u32 = 285;
pub const SSL_F_SSL3_NEW_SESSION_TICKET: u32 = 287;
pub const SSL_F_SSL3_OUTPUT_CERT_CHAIN: u32 = 147;
pub const SSL_F_SSL3_PEEK: u32 = 235;
pub const SSL_F_SSL3_READ_BYTES: u32 = 148;
pub const SSL_F_SSL3_READ_N: u32 = 149;
pub const SSL_F_SSL3_SEND_CERTIFICATE_REQUEST: u32 = 150;
pub const SSL_F_SSL3_SEND_CLIENT_CERTIFICATE: u32 = 151;
pub const SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE: u32 = 152;
pub const SSL_F_SSL3_SEND_CLIENT_VERIFY: u32 = 153;
pub const SSL_F_SSL3_SEND_SERVER_CERTIFICATE: u32 = 154;
pub const SSL_F_SSL3_SEND_SERVER_HELLO: u32 = 242;
pub const SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE: u32 = 155;
pub const SSL_F_SSL3_SETUP_KEY_BLOCK: u32 = 157;
pub const SSL_F_SSL3_SETUP_READ_BUFFER: u32 = 156;
pub const SSL_F_SSL3_SETUP_WRITE_BUFFER: u32 = 291;
pub const SSL_F_SSL3_WRITE_BYTES: u32 = 158;
pub const SSL_F_SSL3_WRITE_PENDING: u32 = 159;
pub const SSL_F_SSL_ADD_CERT_CHAIN: u32 = 318;
pub const SSL_F_SSL_ADD_CERT_TO_BUF: u32 = 319;
pub const SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 298;
pub const SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT: u32 = 277;
pub const SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT: u32 = 307;
pub const SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK: u32 = 215;
pub const SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK: u32 = 216;
pub const SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT: u32 = 299;
pub const SSL_F_SSL_ADD_SERVERHELLO_TLSEXT: u32 = 278;
pub const SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT: u32 = 308;
pub const SSL_F_SSL_BAD_METHOD: u32 = 160;
pub const SSL_F_SSL_BUILD_CERT_CHAIN: u32 = 332;
pub const SSL_F_SSL_BYTES_TO_CIPHER_LIST: u32 = 161;
pub const SSL_F_SSL_CERT_DUP: u32 = 221;
pub const SSL_F_SSL_CERT_INST: u32 = 222;
pub const SSL_F_SSL_CERT_INSTANTIATE: u32 = 214;
pub const SSL_F_SSL_CERT_NEW: u32 = 162;
pub const SSL_F_SSL_CHECK_PRIVATE_KEY: u32 = 163;
pub const SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT: u32 = 280;
pub const SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG: u32 = 279;
pub const SSL_F_SSL_CIPHER_PROCESS_RULESTR: u32 = 230;
pub const SSL_F_SSL_CIPHER_STRENGTH_SORT: u32 = 231;
pub const SSL_F_SSL_CLEAR: u32 = 164;
pub const SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD: u32 = 165;
pub const SSL_F_SSL_CONF_CMD: u32 = 334;
pub const SSL_F_SSL_CREATE_CIPHER_LIST: u32 = 166;
pub const SSL_F_SSL_CTRL: u32 = 232;
pub const SSL_F_SSL_CTX_CHECK_PRIVATE_KEY: u32 = 168;
pub const SSL_F_SSL_CTX_MAKE_PROFILES: u32 = 309;
pub const SSL_F_SSL_CTX_NEW: u32 = 169;
pub const SSL_F_SSL_CTX_SET_CIPHER_LIST: u32 = 269;
pub const SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE: u32 = 290;
pub const SSL_F_SSL_CTX_SET_PURPOSE: u32 = 226;
pub const SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT: u32 = 219;
pub const SSL_F_SSL_CTX_SET_SSL_VERSION: u32 = 170;
pub const SSL_F_SSL_CTX_SET_TRUST: u32 = 229;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE: u32 = 171;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1: u32 = 172;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE: u32 = 220;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_FILE: u32 = 173;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY: u32 = 174;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1: u32 = 175;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE: u32 = 176;
pub const SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT: u32 = 272;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY: u32 = 177;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1: u32 = 178;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE: u32 = 179;
pub const SSL_F_SSL_CTX_USE_SERVERINFO: u32 = 336;
pub const SSL_F_SSL_CTX_USE_SERVERINFO_FILE: u32 = 337;
pub const SSL_F_SSL_DO_HANDSHAKE: u32 = 180;
pub const SSL_F_SSL_GET_NEW_SESSION: u32 = 181;
pub const SSL_F_SSL_GET_PREV_SESSION: u32 = 217;
pub const SSL_F_SSL_GET_SERVER_CERT_INDEX: u32 = 322;
pub const SSL_F_SSL_GET_SERVER_SEND_CERT: u32 = 182;
pub const SSL_F_SSL_GET_SERVER_SEND_PKEY: u32 = 317;
pub const SSL_F_SSL_GET_SIGN_PKEY: u32 = 183;
pub const SSL_F_SSL_INIT_WBIO_BUFFER: u32 = 184;
pub const SSL_F_SSL_LOAD_CLIENT_CA_FILE: u32 = 185;
pub const SSL_F_SSL_NEW: u32 = 186;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 300;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT: u32 = 302;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT: u32 = 310;
pub const SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT: u32 = 301;
pub const SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT: u32 = 303;
pub const SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT: u32 = 311;
pub const SSL_F_SSL_PEEK: u32 = 270;
pub const SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT: u32 = 281;
pub const SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT: u32 = 282;
pub const SSL_F_SSL_READ: u32 = 223;
pub const SSL_F_SSL_RSA_PRIVATE_DECRYPT: u32 = 187;
pub const SSL_F_SSL_RSA_PUBLIC_ENCRYPT: u32 = 188;
pub const SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT: u32 = 320;
pub const SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT: u32 = 321;
pub const SSL_F_SSL_SESSION_DUP: u32 = 348;
pub const SSL_F_SSL_SESSION_NEW: u32 = 189;
pub const SSL_F_SSL_SESSION_PRINT_FP: u32 = 190;
pub const SSL_F_SSL_SESSION_SET1_ID_CONTEXT: u32 = 312;
pub const SSL_F_SSL_SESS_CERT_NEW: u32 = 225;
pub const SSL_F_SSL_SET_CERT: u32 = 191;
pub const SSL_F_SSL_SET_CIPHER_LIST: u32 = 271;
pub const SSL_F_SSL_SET_FD: u32 = 192;
pub const SSL_F_SSL_SET_PKEY: u32 = 193;
pub const SSL_F_SSL_SET_PURPOSE: u32 = 227;
pub const SSL_F_SSL_SET_RFD: u32 = 194;
pub const SSL_F_SSL_SET_SESSION: u32 = 195;
pub const SSL_F_SSL_SET_SESSION_ID_CONTEXT: u32 = 218;
pub const SSL_F_SSL_SET_SESSION_TICKET_EXT: u32 = 294;
pub const SSL_F_SSL_SET_TRUST: u32 = 228;
pub const SSL_F_SSL_SET_WFD: u32 = 196;
pub const SSL_F_SSL_SHUTDOWN: u32 = 224;
pub const SSL_F_SSL_SRP_CTX_INIT: u32 = 313;
pub const SSL_F_SSL_UNDEFINED_CONST_FUNCTION: u32 = 243;
pub const SSL_F_SSL_UNDEFINED_FUNCTION: u32 = 197;
pub const SSL_F_SSL_UNDEFINED_VOID_FUNCTION: u32 = 244;
pub const SSL_F_SSL_USE_CERTIFICATE: u32 = 198;
pub const SSL_F_SSL_USE_CERTIFICATE_ASN1: u32 = 199;
pub const SSL_F_SSL_USE_CERTIFICATE_FILE: u32 = 200;
pub const SSL_F_SSL_USE_PRIVATEKEY: u32 = 201;
pub const SSL_F_SSL_USE_PRIVATEKEY_ASN1: u32 = 202;
pub const SSL_F_SSL_USE_PRIVATEKEY_FILE: u32 = 203;
pub const SSL_F_SSL_USE_PSK_IDENTITY_HINT: u32 = 273;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY: u32 = 204;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1: u32 = 205;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_FILE: u32 = 206;
pub const SSL_F_SSL_VERIFY_CERT_CHAIN: u32 = 207;
pub const SSL_F_SSL_WRITE: u32 = 208;
pub const SSL_F_TLS12_CHECK_PEER_SIGALG: u32 = 333;
pub const SSL_F_TLS1_CERT_VERIFY_MAC: u32 = 286;
pub const SSL_F_TLS1_CHANGE_CIPHER_STATE: u32 = 209;
pub const SSL_F_TLS1_CHECK_SERVERHELLO_TLSEXT: u32 = 274;
pub const SSL_F_TLS1_ENC: u32 = 210;
pub const SSL_F_TLS1_EXPORT_KEYING_MATERIAL: u32 = 314;
pub const SSL_F_TLS1_GET_CURVELIST: u32 = 338;
pub const SSL_F_TLS1_HEARTBEAT: u32 = 315;
pub const SSL_F_TLS1_PREPARE_CLIENTHELLO_TLSEXT: u32 = 275;
pub const SSL_F_TLS1_PREPARE_SERVERHELLO_TLSEXT: u32 = 276;
pub const SSL_F_TLS1_PRF: u32 = 284;
pub const SSL_F_TLS1_SETUP_KEY_BLOCK: u32 = 211;
pub const SSL_F_TLS1_SET_SERVER_SIGALGS: u32 = 335;
pub const SSL_F_WRITE_PENDING: u32 = 212;
pub const SSL_R_APP_DATA_IN_HANDSHAKE: u32 = 100;
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT: u32 = 272;
pub const SSL_R_BAD_ALERT_RECORD: u32 = 101;
pub const SSL_R_BAD_AUTHENTICATION_TYPE: u32 = 102;
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC: u32 = 103;
pub const SSL_R_BAD_CHECKSUM: u32 = 104;
pub const SSL_R_BAD_DATA: u32 = 390;
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK: u32 = 106;
pub const SSL_R_BAD_DECOMPRESSION: u32 = 107;
pub const SSL_R_BAD_DH_G_LENGTH: u32 = 108;
pub const SSL_R_BAD_DH_G_VALUE: u32 = 375;
pub const SSL_R_BAD_DH_PUB_KEY_LENGTH: u32 = 109;
pub const SSL_R_BAD_DH_PUB_KEY_VALUE: u32 = 393;
pub const SSL_R_BAD_DH_P_LENGTH: u32 = 110;
pub const SSL_R_BAD_DH_P_VALUE: u32 = 395;
pub const SSL_R_BAD_DIGEST_LENGTH: u32 = 111;
pub const SSL_R_BAD_DSA_SIGNATURE: u32 = 112;
pub const SSL_R_BAD_ECC_CERT: u32 = 304;
pub const SSL_R_BAD_ECDSA_SIGNATURE: u32 = 305;
pub const SSL_R_BAD_ECPOINT: u32 = 306;
pub const SSL_R_BAD_HANDSHAKE_LENGTH: u32 = 332;
pub const SSL_R_BAD_HELLO_REQUEST: u32 = 105;
pub const SSL_R_BAD_LENGTH: u32 = 271;
pub const SSL_R_BAD_MAC_DECODE: u32 = 113;
pub const SSL_R_BAD_MAC_LENGTH: u32 = 333;
pub const SSL_R_BAD_MESSAGE_TYPE: u32 = 114;
pub const SSL_R_BAD_PACKET_LENGTH: u32 = 115;
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER: u32 = 116;
pub const SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH: u32 = 316;
pub const SSL_R_BAD_RESPONSE_ARGUMENT: u32 = 117;
pub const SSL_R_BAD_RSA_DECRYPT: u32 = 118;
pub const SSL_R_BAD_RSA_ENCRYPT: u32 = 119;
pub const SSL_R_BAD_RSA_E_LENGTH: u32 = 120;
pub const SSL_R_BAD_RSA_MODULUS_LENGTH: u32 = 121;
pub const SSL_R_BAD_RSA_SIGNATURE: u32 = 122;
pub const SSL_R_BAD_SIGNATURE: u32 = 123;
pub const SSL_R_BAD_SRP_A_LENGTH: u32 = 347;
pub const SSL_R_BAD_SRP_B_LENGTH: u32 = 348;
pub const SSL_R_BAD_SRP_G_LENGTH: u32 = 349;
pub const SSL_R_BAD_SRP_N_LENGTH: u32 = 350;
pub const SSL_R_BAD_SRP_PARAMETERS: u32 = 371;
pub const SSL_R_BAD_SRP_S_LENGTH: u32 = 351;
pub const SSL_R_BAD_SRTP_MKI_VALUE: u32 = 352;
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST: u32 = 353;
pub const SSL_R_BAD_SSL_FILETYPE: u32 = 124;
pub const SSL_R_BAD_SSL_SESSION_ID_LENGTH: u32 = 125;
pub const SSL_R_BAD_STATE: u32 = 126;
pub const SSL_R_BAD_VALUE: u32 = 384;
pub const SSL_R_BAD_WRITE_RETRY: u32 = 127;
pub const SSL_R_BIO_NOT_SET: u32 = 128;
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG: u32 = 129;
pub const SSL_R_BN_LIB: u32 = 130;
pub const SSL_R_CA_DN_LENGTH_MISMATCH: u32 = 131;
pub const SSL_R_CA_DN_TOO_LONG: u32 = 132;
pub const SSL_R_CCS_RECEIVED_EARLY: u32 = 133;
pub const SSL_R_CERTIFICATE_VERIFY_FAILED: u32 = 134;
pub const SSL_R_CERT_CB_ERROR: u32 = 377;
pub const SSL_R_CERT_LENGTH_MISMATCH: u32 = 135;
pub const SSL_R_CHALLENGE_IS_DIFFERENT: u32 = 136;
pub const SSL_R_CIPHER_CODE_WRONG_LENGTH: u32 = 137;
pub const SSL_R_CIPHER_OR_HASH_UNAVAILABLE: u32 = 138;
pub const SSL_R_CIPHER_TABLE_SRC_ERROR: u32 = 139;
pub const SSL_R_CLIENTHELLO_TLSEXT: u32 = 226;
pub const SSL_R_COMPRESSED_LENGTH_TOO_LONG: u32 = 140;
pub const SSL_R_COMPRESSION_DISABLED: u32 = 343;
pub const SSL_R_COMPRESSION_FAILURE: u32 = 141;
pub const SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE: u32 = 307;
pub const SSL_R_COMPRESSION_LIBRARY_ERROR: u32 = 142;
pub const SSL_R_CONNECTION_ID_IS_DIFFERENT: u32 = 143;
pub const SSL_R_CONNECTION_TYPE_NOT_SET: u32 = 144;
pub const SSL_R_COOKIE_MISMATCH: u32 = 308;
pub const SSL_R_DATA_BETWEEN_CCS_AND_FINISHED: u32 = 145;
pub const SSL_R_DATA_LENGTH_TOO_LONG: u32 = 146;
pub const SSL_R_DECRYPTION_FAILED: u32 = 147;
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC: u32 = 281;
pub const SSL_R_DH_KEY_TOO_SMALL: u32 = 372;
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG: u32 = 148;
pub const SSL_R_DIGEST_CHECK_FAILED: u32 = 149;
pub const SSL_R_DTLS_MESSAGE_TOO_BIG: u32 = 334;
pub const SSL_R_DUPLICATE_COMPRESSION_ID: u32 = 309;
pub const SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT: u32 = 317;
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING: u32 = 318;
pub const SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE: u32 = 322;
pub const SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE: u32 = 323;
pub const SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE: u32 = 374;
pub const SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER: u32 = 310;
pub const SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST: u32 = 354;
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG: u32 = 150;
pub const SSL_R_ERROR_GENERATING_TMP_RSA_KEY: u32 = 282;
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST: u32 = 151;
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE: u32 = 152;
pub const SSL_R_EXTRA_DATA_IN_MESSAGE: u32 = 153;
pub const SSL_R_GOT_A_FIN_BEFORE_A_CCS: u32 = 154;
pub const SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS: u32 = 355;
pub const SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION: u32 = 356;
pub const SSL_R_HTTPS_PROXY_REQUEST: u32 = 155;
pub const SSL_R_HTTP_REQUEST: u32 = 156;
pub const SSL_R_ILLEGAL_PADDING: u32 = 283;
pub const SSL_R_ILLEGAL_SUITEB_DIGEST: u32 = 380;
pub const SSL_R_INAPPROPRIATE_FALLBACK: u32 = 373;
pub const SSL_R_INCONSISTENT_COMPRESSION: u32 = 340;
pub const SSL_R_INVALID_CHALLENGE_LENGTH: u32 = 158;
pub const SSL_R_INVALID_COMMAND: u32 = 280;
pub const SSL_R_INVALID_COMPRESSION_ALGORITHM: u32 = 341;
pub const SSL_R_INVALID_NULL_CMD_NAME: u32 = 385;
pub const SSL_R_INVALID_PURPOSE: u32 = 278;
pub const SSL_R_INVALID_SERVERINFO_DATA: u32 = 388;
pub const SSL_R_INVALID_SRP_USERNAME: u32 = 357;
pub const SSL_R_INVALID_STATUS_RESPONSE: u32 = 328;
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH: u32 = 325;
pub const SSL_R_INVALID_TRUST: u32 = 279;
pub const SSL_R_KEY_ARG_TOO_LONG: u32 = 284;
pub const SSL_R_KRB5: u32 = 285;
pub const SSL_R_KRB5_C_CC_PRINC: u32 = 286;
pub const SSL_R_KRB5_C_GET_CRED: u32 = 287;
pub const SSL_R_KRB5_C_INIT: u32 = 288;
pub const SSL_R_KRB5_C_MK_REQ: u32 = 289;
pub const SSL_R_KRB5_S_BAD_TICKET: u32 = 290;
pub const SSL_R_KRB5_S_INIT: u32 = 291;
pub const SSL_R_KRB5_S_RD_REQ: u32 = 292;
pub const SSL_R_KRB5_S_TKT_EXPIRED: u32 = 293;
pub const SSL_R_KRB5_S_TKT_NYV: u32 = 294;
pub const SSL_R_KRB5_S_TKT_SKEW: u32 = 295;
pub const SSL_R_LENGTH_MISMATCH: u32 = 159;
pub const SSL_R_LENGTH_TOO_LONG: u32 = 404;
pub const SSL_R_LENGTH_TOO_SHORT: u32 = 160;
pub const SSL_R_LIBRARY_BUG: u32 = 274;
pub const SSL_R_LIBRARY_HAS_NO_CIPHERS: u32 = 161;
pub const SSL_R_MESSAGE_TOO_LONG: u32 = 296;
pub const SSL_R_MISSING_DH_DSA_CERT: u32 = 162;
pub const SSL_R_MISSING_DH_KEY: u32 = 163;
pub const SSL_R_MISSING_DH_RSA_CERT: u32 = 164;
pub const SSL_R_MISSING_DSA_SIGNING_CERT: u32 = 165;
pub const SSL_R_MISSING_ECDH_CERT: u32 = 382;
pub const SSL_R_MISSING_ECDSA_SIGNING_CERT: u32 = 381;
pub const SSL_R_MISSING_EXPORT_TMP_DH_KEY: u32 = 166;
pub const SSL_R_MISSING_EXPORT_TMP_RSA_KEY: u32 = 167;
pub const SSL_R_MISSING_RSA_CERTIFICATE: u32 = 168;
pub const SSL_R_MISSING_RSA_ENCRYPTING_CERT: u32 = 169;
pub const SSL_R_MISSING_RSA_SIGNING_CERT: u32 = 170;
pub const SSL_R_MISSING_SRP_PARAM: u32 = 358;
pub const SSL_R_MISSING_TMP_DH_KEY: u32 = 171;
pub const SSL_R_MISSING_TMP_ECDH_KEY: u32 = 311;
pub const SSL_R_MISSING_TMP_RSA_KEY: u32 = 172;
pub const SSL_R_MISSING_TMP_RSA_PKEY: u32 = 173;
pub const SSL_R_MISSING_VERIFY_MESSAGE: u32 = 174;
pub const SSL_R_MULTIPLE_SGC_RESTARTS: u32 = 346;
pub const SSL_R_NON_SSLV2_INITIAL_PACKET: u32 = 175;
pub const SSL_R_NO_CERTIFICATES_RETURNED: u32 = 176;
pub const SSL_R_NO_CERTIFICATE_ASSIGNED: u32 = 177;
pub const SSL_R_NO_CERTIFICATE_RETURNED: u32 = 178;
pub const SSL_R_NO_CERTIFICATE_SET: u32 = 179;
pub const SSL_R_NO_CERTIFICATE_SPECIFIED: u32 = 180;
pub const SSL_R_NO_CIPHERS_AVAILABLE: u32 = 181;
pub const SSL_R_NO_CIPHERS_PASSED: u32 = 182;
pub const SSL_R_NO_CIPHERS_SPECIFIED: u32 = 183;
pub const SSL_R_NO_CIPHER_LIST: u32 = 184;
pub const SSL_R_NO_CIPHER_MATCH: u32 = 185;
pub const SSL_R_NO_CLIENT_CERT_METHOD: u32 = 331;
pub const SSL_R_NO_CLIENT_CERT_RECEIVED: u32 = 186;
pub const SSL_R_NO_COMPRESSION_SPECIFIED: u32 = 187;
pub const SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER: u32 = 330;
pub const SSL_R_NO_METHOD_SPECIFIED: u32 = 188;
pub const SSL_R_NO_PEM_EXTENSIONS: u32 = 389;
pub const SSL_R_NO_PRIVATEKEY: u32 = 189;
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED: u32 = 190;
pub const SSL_R_NO_PROTOCOLS_AVAILABLE: u32 = 191;
pub const SSL_R_NO_PUBLICKEY: u32 = 192;
pub const SSL_R_NO_RENEGOTIATION: u32 = 339;
pub const SSL_R_NO_REQUIRED_DIGEST: u32 = 324;
pub const SSL_R_NO_SHARED_CIPHER: u32 = 193;
pub const SSL_R_NO_SHARED_SIGATURE_ALGORITHMS: u32 = 376;
pub const SSL_R_NO_SRTP_PROFILES: u32 = 359;
pub const SSL_R_NO_VERIFY_CALLBACK: u32 = 194;
pub const SSL_R_NULL_SSL_CTX: u32 = 195;
pub const SSL_R_NULL_SSL_METHOD_PASSED: u32 = 196;
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED: u32 = 197;
pub const SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED: u32 = 344;
pub const SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE: u32 = 387;
pub const SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE: u32 = 379;
pub const SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE: u32 = 297;
pub const SSL_R_OPAQUE_PRF_INPUT_TOO_LONG: u32 = 327;
pub const SSL_R_PACKET_LENGTH_TOO_LONG: u32 = 198;
pub const SSL_R_PARSE_TLSEXT: u32 = 227;
pub const SSL_R_PATH_TOO_LONG: u32 = 270;
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE: u32 = 199;
pub const SSL_R_PEER_ERROR: u32 = 200;
pub const SSL_R_PEER_ERROR_CERTIFICATE: u32 = 201;
pub const SSL_R_PEER_ERROR_NO_CERTIFICATE: u32 = 202;
pub const SSL_R_PEER_ERROR_NO_CIPHER: u32 = 203;
pub const SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE: u32 = 204;
pub const SSL_R_PEM_NAME_BAD_PREFIX: u32 = 391;
pub const SSL_R_PEM_NAME_TOO_SHORT: u32 = 392;
pub const SSL_R_PRE_MAC_LENGTH_TOO_LONG: u32 = 205;
pub const SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS: u32 = 206;
pub const SSL_R_PROTOCOL_IS_SHUTDOWN: u32 = 207;
pub const SSL_R_PSK_IDENTITY_NOT_FOUND: u32 = 223;
pub const SSL_R_PSK_NO_CLIENT_CB: u32 = 224;
pub const SSL_R_PSK_NO_SERVER_CB: u32 = 225;
pub const SSL_R_PUBLIC_KEY_ENCRYPT_ERROR: u32 = 208;
pub const SSL_R_PUBLIC_KEY_IS_NOT_RSA: u32 = 209;
pub const SSL_R_PUBLIC_KEY_NOT_RSA: u32 = 210;
pub const SSL_R_READ_BIO_NOT_SET: u32 = 211;
pub const SSL_R_READ_TIMEOUT_EXPIRED: u32 = 312;
pub const SSL_R_READ_WRONG_PACKET_TYPE: u32 = 212;
pub const SSL_R_RECORD_LENGTH_MISMATCH: u32 = 213;
pub const SSL_R_RECORD_TOO_LARGE: u32 = 214;
pub const SSL_R_RECORD_TOO_SMALL: u32 = 298;
pub const SSL_R_RENEGOTIATE_EXT_TOO_LONG: u32 = 335;
pub const SSL_R_RENEGOTIATION_ENCODING_ERR: u32 = 336;
pub const SSL_R_RENEGOTIATION_MISMATCH: u32 = 337;
pub const SSL_R_REQUIRED_CIPHER_MISSING: u32 = 215;
pub const SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING: u32 = 342;
pub const SSL_R_REUSE_CERT_LENGTH_NOT_ZERO: u32 = 216;
pub const SSL_R_REUSE_CERT_TYPE_NOT_ZERO: u32 = 217;
pub const SSL_R_REUSE_CIPHER_LIST_NOT_ZERO: u32 = 218;
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING: u32 = 345;
pub const SSL_R_SERVERHELLO_TLSEXT: u32 = 275;
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED: u32 = 277;
pub const SSL_R_SHORT_READ: u32 = 219;
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT: u32 = 407;
pub const SSL_R_SIGNATURE_ALGORITHMS_ERROR: u32 = 360;
pub const SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE: u32 = 220;
pub const SSL_R_SRP_A_CALC: u32 = 361;
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES: u32 = 362;
pub const SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG: u32 = 363;
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE: u32 = 364;
pub const SSL_R_SSL23_DOING_SESSION_ID_REUSE: u32 = 221;
pub const SSL_R_SSL2_CONNECTION_ID_TOO_LONG: u32 = 299;
pub const SSL_R_SSL3_EXT_INVALID_ECPOINTFORMAT: u32 = 321;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME: u32 = 319;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE: u32 = 320;
pub const SSL_R_SSL3_SESSION_ID_TOO_LONG: u32 = 300;
pub const SSL_R_SSL3_SESSION_ID_TOO_SHORT: u32 = 222;
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE: u32 = 1042;
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC: u32 = 1020;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED: u32 = 1045;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED: u32 = 1044;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN: u32 = 1046;
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE: u32 = 1030;
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE: u32 = 1040;
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER: u32 = 1047;
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE: u32 = 1041;
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE: u32 = 1010;
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE: u32 = 1043;
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION: u32 = 228;
pub const SSL_R_SSL_HANDSHAKE_FAILURE: u32 = 229;
pub const SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS: u32 = 230;
pub const SSL_R_SSL_SESSION_ID_CALLBACK_FAILED: u32 = 301;
pub const SSL_R_SSL_SESSION_ID_CONFLICT: u32 = 302;
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG: u32 = 273;
pub const SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH: u32 = 303;
pub const SSL_R_SSL_SESSION_ID_IS_DIFFERENT: u32 = 231;
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED: u32 = 1049;
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR: u32 = 1050;
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED: u32 = 1021;
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR: u32 = 1051;
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION: u32 = 1060;
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK: u32 = 1086;
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY: u32 = 1071;
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR: u32 = 1080;
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION: u32 = 1100;
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION: u32 = 1070;
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW: u32 = 1022;
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA: u32 = 1048;
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED: u32 = 1090;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE: u32 = 1114;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 1113;
pub const SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE: u32 = 1111;
pub const SSL_R_TLSV1_UNRECOGNIZED_NAME: u32 = 1112;
pub const SSL_R_TLSV1_UNSUPPORTED_EXTENSION: u32 = 1110;
pub const SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER: u32 = 232;
pub const SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT: u32 = 365;
pub const SSL_R_TLS_HEARTBEAT_PENDING: u32 = 366;
pub const SSL_R_TLS_ILLEGAL_EXPORTER_LABEL: u32 = 367;
pub const SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST: u32 = 157;
pub const SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST: u32 = 233;
pub const SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG: u32 = 234;
pub const SSL_R_TOO_MANY_WARN_ALERTS: u32 = 409;
pub const SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER: u32 = 235;
pub const SSL_R_UNABLE_TO_DECODE_DH_CERTS: u32 = 236;
pub const SSL_R_UNABLE_TO_DECODE_ECDH_CERTS: u32 = 313;
pub const SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY: u32 = 237;
pub const SSL_R_UNABLE_TO_FIND_DH_PARAMETERS: u32 = 238;
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS: u32 = 314;
pub const SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS: u32 = 239;
pub const SSL_R_UNABLE_TO_FIND_SSL_METHOD: u32 = 240;
pub const SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES: u32 = 241;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES: u32 = 242;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES: u32 = 243;
pub const SSL_R_UNEXPECTED_MESSAGE: u32 = 244;
pub const SSL_R_UNEXPECTED_RECORD: u32 = 245;
pub const SSL_R_UNINITIALIZED: u32 = 276;
pub const SSL_R_UNKNOWN_ALERT_TYPE: u32 = 246;
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE: u32 = 247;
pub const SSL_R_UNKNOWN_CIPHER_RETURNED: u32 = 248;
pub const SSL_R_UNKNOWN_CIPHER_TYPE: u32 = 249;
pub const SSL_R_UNKNOWN_CMD_NAME: u32 = 386;
pub const SSL_R_UNKNOWN_DIGEST: u32 = 368;
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE: u32 = 250;
pub const SSL_R_UNKNOWN_PKEY_TYPE: u32 = 251;
pub const SSL_R_UNKNOWN_PROTOCOL: u32 = 252;
pub const SSL_R_UNKNOWN_REMOTE_ERROR_TYPE: u32 = 253;
pub const SSL_R_UNKNOWN_SSL_VERSION: u32 = 254;
pub const SSL_R_UNKNOWN_STATE: u32 = 255;
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED: u32 = 338;
pub const SSL_R_UNSUPPORTED_CIPHER: u32 = 256;
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM: u32 = 257;
pub const SSL_R_UNSUPPORTED_DIGEST_TYPE: u32 = 326;
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE: u32 = 315;
pub const SSL_R_UNSUPPORTED_PROTOCOL: u32 = 258;
pub const SSL_R_UNSUPPORTED_SSL_VERSION: u32 = 259;
pub const SSL_R_UNSUPPORTED_STATUS_TYPE: u32 = 329;
pub const SSL_R_USE_SRTP_NOT_NEGOTIATED: u32 = 369;
pub const SSL_R_WRITE_BIO_NOT_SET: u32 = 260;
pub const SSL_R_WRONG_CERTIFICATE_TYPE: u32 = 383;
pub const SSL_R_WRONG_CIPHER_RETURNED: u32 = 261;
pub const SSL_R_WRONG_CURVE: u32 = 378;
pub const SSL_R_WRONG_MESSAGE_TYPE: u32 = 262;
pub const SSL_R_WRONG_NUMBER_OF_KEY_BITS: u32 = 263;
pub const SSL_R_WRONG_SIGNATURE_LENGTH: u32 = 264;
pub const SSL_R_WRONG_SIGNATURE_SIZE: u32 = 265;
pub const SSL_R_WRONG_SIGNATURE_TYPE: u32 = 370;
pub const SSL_R_WRONG_SSL_VERSION: u32 = 266;
pub const SSL_R_WRONG_VERSION_NUMBER: u32 = 267;
pub const SSL_R_X509_LIB: u32 = 268;
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS: u32 = 269;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st {
    pub num: ::std::os::raw::c_int,
    pub data: *mut *mut ::std::os::raw::c_char,
    pub sorted: ::std::os::raw::c_int,
    pub num_alloc: ::std::os::raw::c_int,
    pub comp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_stack_st() {
    assert_eq!(
        ::std::mem::size_of::<stack_st>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st>())).sorted as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st),
            "::",
            stringify!(sorted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st>())).num_alloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st),
            "::",
            stringify!(num_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st>())).comp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st),
            "::",
            stringify!(comp)
        )
    );
}
pub type _STACK = stack_st;
extern "C" {
    pub fn sk_num(arg1: *const _STACK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_value(
        arg1: *const _STACK,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_set(
        arg1: *mut _STACK,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_new(
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut _STACK;
}
extern "C" {
    pub fn sk_new_null() -> *mut _STACK;
}
extern "C" {
    pub fn sk_free(arg1: *mut _STACK);
}
extern "C" {
    pub fn sk_pop_free(
        st: *mut _STACK,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn sk_deep_copy(
        arg1: *mut _STACK,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut _STACK;
}
extern "C" {
    pub fn sk_insert(
        sk: *mut _STACK,
        data: *mut ::std::os::raw::c_void,
        where_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_delete(st: *mut _STACK, loc: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_delete_ptr(
        st: *mut _STACK,
        p: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_find(st: *mut _STACK, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_find_ex(st: *mut _STACK, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_push(st: *mut _STACK, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_unshift(st: *mut _STACK, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sk_shift(st: *mut _STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_pop(st: *mut _STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sk_zero(st: *mut _STACK);
}
extern "C" {
    pub fn sk_set_cmp_func(
        sk: *mut _STACK,
        c: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            sk: *mut _STACK,
            c: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn sk_dup(st: *mut _STACK) -> *mut _STACK;
}
extern "C" {
    pub fn sk_sort(st: *mut _STACK);
}
extern "C" {
    pub fn sk_is_sorted(st: *const _STACK) -> ::std::os::raw::c_int;
}
pub type OPENSSL_STRING = *mut ::std::os::raw::c_char;
pub type OPENSSL_CSTRING = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_STRING {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_OPENSSL_STRING() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_OPENSSL_STRING>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_OPENSSL_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_OPENSSL_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_OPENSSL_STRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_OPENSSL_STRING>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_OPENSSL_STRING),
            "::",
            stringify!(stack)
        )
    );
}
pub type OPENSSL_BLOCK = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_BLOCK {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_OPENSSL_BLOCK() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_OPENSSL_BLOCK>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_OPENSSL_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_OPENSSL_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_OPENSSL_BLOCK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_OPENSSL_BLOCK>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_OPENSSL_BLOCK),
            "::",
            stringify!(stack)
        )
    );
}
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_BOOLEAN = ::std::os::raw::c_int;
pub type ASN1_NULL = ::std::os::raw::c_int;
pub type ASN1_OBJECT = asn1_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    _unused: [u8; 0],
}
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
pub type BIGNUM = bignum_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_blinding_st {
    _unused: [u8; 0],
}
pub type BN_BLINDING = bn_blinding_st;
pub type BN_MONT_CTX = bn_mont_ctx_st;
pub type BN_RECP_CTX = bn_recp_ctx_st;
pub type BN_GENCB = bn_gencb_st;
pub type BUF_MEM = buf_mem_st;
pub type EVP_CIPHER = evp_cipher_st;
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
pub type EVP_MD = env_md_st;
pub type EVP_MD_CTX = env_md_ctx_st;
pub type EVP_PKEY = evp_pkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_METHOD = evp_pkey_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
pub type DH = dh_st;
pub type DH_METHOD = dh_method;
pub type DSA = dsa_st;
pub type DSA_METHOD = dsa_method;
pub type RSA = rsa_st;
pub type RSA_METHOD = rsa_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    _unused: [u8; 0],
}
pub type RAND_METHOD = rand_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdh_method {
    _unused: [u8; 0],
}
pub type ECDH_METHOD = ecdh_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdsa_method {
    _unused: [u8; 0],
}
pub type ECDSA_METHOD = ecdsa_method;
pub type X509 = x509_st;
pub type X509_ALGOR = X509_algor_st;
pub type X509_CRL = X509_crl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl_method_st {
    _unused: [u8; 0],
}
pub type X509_CRL_METHOD = x509_crl_method_st;
pub type X509_REVOKED = x509_revoked_st;
pub type X509_NAME = X509_name_st;
pub type X509_PUBKEY = X509_pubkey_st;
pub type X509_STORE = x509_store_st;
pub type X509_STORE_CTX = x509_store_ctx_st;
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_ctx {
    _unused: [u8; 0],
}
pub type X509V3_CTX = v3_ext_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_st {
    _unused: [u8; 0],
}
pub type CONF = conf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct store_st {
    _unused: [u8; 0],
}
pub type STORE = store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct store_method_st {
    _unused: [u8; 0],
}
pub type STORE_METHOD = store_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_st {
    _unused: [u8; 0],
}
pub type UI = ui_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_method_st {
    _unused: [u8; 0],
}
pub type UI_METHOD = ui_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_ERR_FNS {
    _unused: [u8; 0],
}
pub type ERR_FNS = st_ERR_FNS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
pub type SSL = ssl_st;
pub type SSL_CTX = ssl_ctx_st;
pub type COMP_METHOD = comp_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_NODE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_NODE = X509_POLICY_NODE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_LEVEL_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_LEVEL = X509_POLICY_LEVEL_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_TREE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_TREE = X509_POLICY_TREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_CACHE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_CACHE = X509_POLICY_CACHE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUTHORITY_KEYID_st {
    _unused: [u8; 0],
}
pub type AUTHORITY_KEYID = AUTHORITY_KEYID_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIST_POINT_st {
    _unused: [u8; 0],
}
pub type DIST_POINT = DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUING_DIST_POINT_st {
    _unused: [u8; 0],
}
pub type ISSUING_DIST_POINT = ISSUING_DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAME_CONSTRAINTS_st {
    _unused: [u8; 0],
}
pub type NAME_CONSTRAINTS = NAME_CONSTRAINTS_st;
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
pub type CRYPTO_EX_new = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type CRYPTO_EX_free = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ),
>;
pub type CRYPTO_EX_dup = ::std::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *mut CRYPTO_EX_DATA,
        from_d: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_ctx_st {
    _unused: [u8; 0],
}
pub type OCSP_REQ_CTX = ocsp_req_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPONSE = ocsp_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_responder_id_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPID = ocsp_responder_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openssl_item_st {
    pub code: ::std::os::raw::c_int,
    pub value: *mut ::std::os::raw::c_void,
    pub value_size: usize,
    pub value_length: *mut usize,
}
#[test]
fn bindgen_test_layout_openssl_item_st() {
    assert_eq!(
        ::std::mem::size_of::<openssl_item_st>(),
        32usize,
        concat!("Size of: ", stringify!(openssl_item_st))
    );
    assert_eq!(
        ::std::mem::align_of::<openssl_item_st>(),
        8usize,
        concat!("Alignment of ", stringify!(openssl_item_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openssl_item_st>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_item_st),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openssl_item_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_item_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openssl_item_st>())).value_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_item_st),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openssl_item_st>())).value_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_item_st),
            "::",
            stringify!(value_length)
        )
    );
}
pub type OPENSSL_ITEM = openssl_item_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub references: ::std::os::raw::c_int,
    pub data: *mut CRYPTO_dynlock_value,
}
#[test]
fn bindgen_test_layout_CRYPTO_dynlock() {
    assert_eq!(
        ::std::mem::size_of::<CRYPTO_dynlock>(),
        16usize,
        concat!("Size of: ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CRYPTO_dynlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CRYPTO_dynlock>())).references as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CRYPTO_dynlock>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(data)
        )
    );
}
pub type BIO_dummy = bio_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub sk: *mut stack_st_void,
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_ex_data_st>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_st>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_st),
            "::",
            stringify!(sk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_st>())).dummy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_st),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_void() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_void>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_void))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_void>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_void))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_void>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_void),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_func_st {
    pub argl: ::std::os::raw::c_long,
    pub argp: *mut ::std::os::raw::c_void,
    pub new_func: CRYPTO_EX_new,
    pub free_func: CRYPTO_EX_free,
    pub dup_func: CRYPTO_EX_dup,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_func_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_ex_data_func_st>(),
        40usize,
        concat!("Size of: ", stringify!(crypto_ex_data_func_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_ex_data_func_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_func_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_func_st>())).argl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_func_st),
            "::",
            stringify!(argl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_func_st>())).argp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_func_st),
            "::",
            stringify!(argp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_func_st>())).new_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_func_st),
            "::",
            stringify!(new_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_ex_data_func_st>())).free_func as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_func_st),
            "::",
            stringify!(free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_func_st>())).dup_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_func_st),
            "::",
            stringify!(dup_func)
        )
    );
}
pub type CRYPTO_EX_DATA_FUNCS = crypto_ex_data_func_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CRYPTO_EX_DATA_FUNCS {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_CRYPTO_EX_DATA_FUNCS() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_CRYPTO_EX_DATA_FUNCS>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_CRYPTO_EX_DATA_FUNCS))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_CRYPTO_EX_DATA_FUNCS>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_CRYPTO_EX_DATA_FUNCS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_CRYPTO_EX_DATA_FUNCS>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_CRYPTO_EX_DATA_FUNCS),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub fn CRYPTO_mem_ctrl(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_is_mem_check_on() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSLeay_version(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSLeay() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OPENSSL_issetugid() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_CRYPTO_EX_DATA_IMPL {
    _unused: [u8; 0],
}
pub type CRYPTO_EX_DATA_IMPL = st_CRYPTO_EX_DATA_IMPL;
extern "C" {
    pub fn CRYPTO_get_ex_data_implementation() -> *const CRYPTO_EX_DATA_IMPL;
}
extern "C" {
    pub fn CRYPTO_set_ex_data_implementation(
        i: *const CRYPTO_EX_DATA_IMPL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_ex_data_new_class() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_ex_new_index(
        class_index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_new_ex_data(
        class_index: ::std::os::raw::c_int,
        obj: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_dup_ex_data(
        class_index: ::std::os::raw::c_int,
        to: *mut CRYPTO_EX_DATA,
        from: *mut CRYPTO_EX_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_data(
        class_index: ::std::os::raw::c_int,
        obj: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
    );
}
extern "C" {
    pub fn CRYPTO_set_ex_data(
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_ex_data(
        ad: *const CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_cleanup_all_ex_data();
}
extern "C" {
    pub fn CRYPTO_get_new_lockid(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_num_locks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_lock(
        mode: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_set_locking_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                type_: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_locking_callback() -> ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn CRYPTO_set_add_lock_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                num: *mut ::std::os::raw::c_int,
                mount: ::std::os::raw::c_int,
                type_: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_add_lock_callback(
    ) -> ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_threadid_st {
    pub ptr: *mut ::std::os::raw::c_void,
    pub val: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_crypto_threadid_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_threadid_st>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_threadid_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_threadid_st>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_threadid_st),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_threadid_st>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_threadid_st),
            "::",
            stringify!(val)
        )
    );
}
pub type CRYPTO_THREADID = crypto_threadid_st;
extern "C" {
    pub fn CRYPTO_THREADID_set_numeric(id: *mut CRYPTO_THREADID, val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn CRYPTO_THREADID_set_pointer(id: *mut CRYPTO_THREADID, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CRYPTO_THREADID_set_callback(
        threadid_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut CRYPTO_THREADID)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREADID_get_callback() -> ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn CRYPTO_THREADID_current(id: *mut CRYPTO_THREADID);
}
extern "C" {
    pub fn CRYPTO_THREADID_cmp(
        a: *const CRYPTO_THREADID,
        b: *const CRYPTO_THREADID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREADID_cpy(dest: *mut CRYPTO_THREADID, src: *const CRYPTO_THREADID);
}
extern "C" {
    pub fn CRYPTO_THREADID_hash(id: *const CRYPTO_THREADID) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CRYPTO_set_id_callback(
        func: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    );
}
extern "C" {
    pub fn CRYPTO_get_id_callback(
    ) -> ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>;
}
extern "C" {
    pub fn CRYPTO_thread_id() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CRYPTO_get_lock_name(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_add_lock(
        pointer: *mut ::std::os::raw::c_int,
        amount: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_new_dynlockid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_destroy_dynlockid(i: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CRYPTO_get_dynlock_value(i: ::std::os::raw::c_int) -> *mut CRYPTO_dynlock_value;
}
extern "C" {
    pub fn CRYPTO_set_dynlock_create_callback(
        dyn_create_function: ::std::option::Option<
            unsafe extern "C" fn(
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> *mut CRYPTO_dynlock_value,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_lock_callback(
        dyn_lock_function: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_destroy_callback(
        dyn_destroy_function: ::std::option::Option<
            unsafe extern "C" fn(
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_dynlock_create_callback(
    ) -> ::std::option::Option<unsafe extern "C" fn() -> *mut CRYPTO_dynlock_value>;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_lock_callback() -> ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_destroy_callback() -> ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn CRYPTO_set_mem_functions(
        m: ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
        r: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_locked_mem_functions(
        m: ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_mem_ex_functions(
        m: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        r: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_locked_mem_ex_functions(
        m: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_mem_debug_functions(
        m: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_int,
            ),
        >,
        r: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
                arg4: *const ::std::os::raw::c_char,
                arg5: ::std::os::raw::c_int,
                arg6: ::std::os::raw::c_int,
            ),
        >,
        f: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int),
        >,
        so: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_long)>,
        go: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_mem_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        r: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn CRYPTO_get_locked_mem_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        f: *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn CRYPTO_get_mem_ex_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        r: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn CRYPTO_get_locked_mem_ex_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn CRYPTO_get_mem_debug_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_int,
            ),
        >,
        r: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
                arg4: *const ::std::os::raw::c_char,
                arg5: ::std::os::raw::c_int,
                arg6: ::std::os::raw::c_int,
            ),
        >,
        f: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int),
        >,
        so: *mut ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_long)>,
        go: *mut ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
    );
}
extern "C" {
    pub fn CRYPTO_malloc_locked(
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_free_locked(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CRYPTO_malloc(
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_strdup(
        str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CRYPTO_realloc(
        addr: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_realloc_clean(
        addr: *mut ::std::os::raw::c_void,
        old_num: ::std::os::raw::c_int,
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_remalloc(
        addr: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn CRYPTO_set_mem_debug_options(bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn CRYPTO_get_mem_debug_options() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn CRYPTO_push_info_(
        info: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_pop_info() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_remove_all_info() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_dbg_malloc(
        addr: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        before_p: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_dbg_realloc(
        addr1: *mut ::std::os::raw::c_void,
        addr2: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        before_p: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_dbg_free(addr: *mut ::std::os::raw::c_void, before_p: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CRYPTO_dbg_set_options(bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn CRYPTO_dbg_get_options() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn CRYPTO_mem_leaks_fp(arg1: *mut FILE);
}
extern "C" {
    pub fn CRYPTO_mem_leaks(bio: *mut bio_st);
}
pub type CRYPTO_MEM_LEAK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_ulong,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn CRYPTO_mem_leaks_cb(cb: CRYPTO_MEM_LEAK_CB);
}
extern "C" {
    pub fn OpenSSLDie(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        assertion: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn OPENSSL_ia32cap_loc() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OPENSSL_isservice() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FIPS_mode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FIPS_mode_set(r: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_init();
}
extern "C" {
    pub fn CRYPTO_memcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_CRYPTO_strings();
}
pub type COMP_CTX = comp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_method_st {
    pub type_: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut COMP_CTX) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(ctx: *mut COMP_CTX)>,
    pub compress: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut COMP_CTX,
            out: *mut ::std::os::raw::c_uchar,
            olen: ::std::os::raw::c_uint,
            in_: *mut ::std::os::raw::c_uchar,
            ilen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub expand: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut COMP_CTX,
            out: *mut ::std::os::raw::c_uchar,
            olen: ::std::os::raw::c_uint,
            in_: *mut ::std::os::raw::c_uchar,
            ilen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub ctrl: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
    pub callback_ctrl: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
}
#[test]
fn bindgen_test_layout_comp_method_st() {
    assert_eq!(
        ::std::mem::size_of::<comp_method_st>(),
        64usize,
        concat!("Size of: ", stringify!(comp_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<comp_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(comp_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).finish as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).compress as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).expand as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(expand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).ctrl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_method_st>())).callback_ctrl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_method_st),
            "::",
            stringify!(callback_ctrl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_ctx_st {
    pub meth: *mut COMP_METHOD,
    pub compress_in: ::std::os::raw::c_ulong,
    pub compress_out: ::std::os::raw::c_ulong,
    pub expand_in: ::std::os::raw::c_ulong,
    pub expand_out: ::std::os::raw::c_ulong,
    pub ex_data: CRYPTO_EX_DATA,
}
#[test]
fn bindgen_test_layout_comp_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<comp_ctx_st>(),
        56usize,
        concat!("Size of: ", stringify!(comp_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<comp_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(comp_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).meth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).compress_in as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(compress_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).compress_out as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(compress_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).expand_in as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(expand_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).expand_out as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(expand_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<comp_ctx_st>())).ex_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(comp_ctx_st),
            "::",
            stringify!(ex_data)
        )
    );
}
extern "C" {
    pub fn COMP_CTX_new(meth: *mut COMP_METHOD) -> *mut COMP_CTX;
}
extern "C" {
    pub fn COMP_CTX_free(ctx: *mut COMP_CTX);
}
extern "C" {
    pub fn COMP_compress_block(
        ctx: *mut COMP_CTX,
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        in_: *mut ::std::os::raw::c_uchar,
        ilen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_expand_block(
        ctx: *mut COMP_CTX,
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        in_: *mut ::std::os::raw::c_uchar,
        ilen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_rle() -> *mut COMP_METHOD;
}
extern "C" {
    pub fn COMP_zlib() -> *mut COMP_METHOD;
}
extern "C" {
    pub fn COMP_zlib_cleanup();
}
extern "C" {
    pub fn ERR_load_COMP_strings();
}
pub type BIO = bio_st;
extern "C" {
    pub fn BIO_set_flags(b: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_test_flags(b: *const BIO, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_clear_flags(b: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_callback(
        b: *const BIO,
    ) -> ::std::option::Option<unsafe extern "C" fn(b: *const BIO) -> ::std::os::raw::c_long>;
}
extern "C" {
    pub fn BIO_set_callback(
        b: *mut BIO,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bio_st,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_long,
                arg6: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long,
        >,
    );
}
extern "C" {
    pub fn BIO_get_callback_arg(b: *const BIO) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_set_callback_arg(b: *mut BIO, arg: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn BIO_method_name(b: *const BIO) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_method_type(b: *const BIO) -> ::std::os::raw::c_int;
}
pub type bio_info_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut bio_st,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_long,
        arg6: ::std::os::raw::c_long,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    pub type_: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub bwrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bread: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bputs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub bgets: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_long,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >,
    pub create:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub callback_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: bio_info_cb,
        ) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout_bio_method_st() {
    assert_eq!(
        ::std::mem::size_of::<bio_method_st>(),
        80usize,
        concat!("Size of: ", stringify!(bio_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bwrite as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bputs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).bgets as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bgets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).ctrl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).create as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).destroy as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_method_st>())).callback_ctrl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(callback_ctrl)
        )
    );
}
pub type BIO_METHOD = bio_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    pub method: *mut BIO_METHOD,
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bio_st,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
            arg5: ::std::os::raw::c_long,
            arg6: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long,
    >,
    pub cb_arg: *mut ::std::os::raw::c_char,
    pub init: ::std::os::raw::c_int,
    pub shutdown: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub retry_reason: ::std::os::raw::c_int,
    pub num: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_void,
    pub next_bio: *mut bio_st,
    pub prev_bio: *mut bio_st,
    pub references: ::std::os::raw::c_int,
    pub num_read: ::std::os::raw::c_ulong,
    pub num_write: ::std::os::raw::c_ulong,
    pub ex_data: CRYPTO_EX_DATA,
}
#[test]
fn bindgen_test_layout_bio_st() {
    assert_eq!(
        ::std::mem::size_of::<bio_st>(),
        112usize,
        concat!("Size of: ", stringify!(bio_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).cb_arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(cb_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).shutdown as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).retry_reason as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(retry_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).ptr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).next_bio as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(next_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).prev_bio as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(prev_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).references as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num_read as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).num_write as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_st>())).ex_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(ex_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIO {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_BIO() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_BIO>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_BIO))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_BIO>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_BIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_BIO>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_BIO),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_f_buffer_ctx_struct {
    pub ibuf_size: ::std::os::raw::c_int,
    pub obuf_size: ::std::os::raw::c_int,
    pub ibuf: *mut ::std::os::raw::c_char,
    pub ibuf_len: ::std::os::raw::c_int,
    pub ibuf_off: ::std::os::raw::c_int,
    pub obuf: *mut ::std::os::raw::c_char,
    pub obuf_len: ::std::os::raw::c_int,
    pub obuf_off: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bio_f_buffer_ctx_struct() {
    assert_eq!(
        ::std::mem::size_of::<bio_f_buffer_ctx_struct>(),
        40usize,
        concat!("Size of: ", stringify!(bio_f_buffer_ctx_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_f_buffer_ctx_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_f_buffer_ctx_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).ibuf_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(ibuf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).obuf_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(obuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).ibuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(ibuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).ibuf_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(ibuf_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).ibuf_off as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(ibuf_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).obuf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(obuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).obuf_len as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(obuf_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bio_f_buffer_ctx_struct>())).obuf_off as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_f_buffer_ctx_struct),
            "::",
            stringify!(obuf_off)
        )
    );
}
pub type BIO_F_BUFFER_CTX = bio_f_buffer_ctx_struct;
pub type asn1_ps_func = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        pbuf: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_int,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn BIO_ctrl_pending(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_wpending(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_reset_read_request(b: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_ex_data(
        bio: *mut BIO,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_ex_data(
        bio: *mut BIO,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_number_read(bio: *mut BIO) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BIO_number_written(bio: *mut BIO) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BIO_asn1_set_prefix(
        b: *mut BIO,
        prefix: asn1_ps_func,
        prefix_free: asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_prefix(
        b: *mut BIO,
        pprefix: *mut asn1_ps_func,
        pprefix_free: *mut asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_set_suffix(
        b: *mut BIO,
        suffix: asn1_ps_func,
        suffix_free: asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_suffix(
        b: *mut BIO,
        psuffix: *mut asn1_ps_func,
        psuffix_free: *mut asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new(type_: *mut BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set(a: *mut BIO, type_: *mut BIO_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_free(a: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vfree(a: *mut BIO);
}
extern "C" {
    pub fn BIO_read(
        b: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bp: *mut BIO,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write(
        b: *mut BIO,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_puts(bp: *mut BIO, buf: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_indent(
        b: *mut BIO,
        indent: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_callback_ctrl(
        b: *mut BIO,
        cmd: ::std::os::raw::c_int,
        fp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bio_st,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_long,
                arg6: ::std::os::raw::c_long,
            ),
        >,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        iarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_push(b: *mut BIO, append: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(a: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(b: *mut BIO, bio_type: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_retry_BIO(bio: *mut BIO, reason: *mut ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dup_chain(in_: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_nread0(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nread(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nwrite0(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nwrite(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_debug_callback(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        argp: *const ::std::os::raw::c_char,
        argi: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        ret: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_s_mem() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_socket() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_connect() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_accept() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_fd() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_log() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_bio() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_null() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_null() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_buffer() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_nbio_test() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_datagram() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_sock_should_retry(i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dgram_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_fd_should_retry(i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_fd_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                data: *const ::std::os::raw::c_void,
                len: usize,
                u: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        u: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                data: *const ::std::os::raw::c_void,
                len: usize,
                u: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        u: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump(
        b: *mut BIO,
        bytes: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent(
        b: *mut BIO,
        bytes: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_fp(
        fp: *mut FILE,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_fp(
        fp: *mut FILE,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_hex_string(
        out: *mut BIO,
        indent: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        datalen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn BIO_gethostbyname(name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn BIO_sock_error(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_socket_ioctl(
        fd: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_long,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_socket_nbio(
        fd: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_port(
        str: *const ::std::os::raw::c_char,
        port_ptr: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_host_ip(
        str: *const ::std::os::raw::c_char,
        ip: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_accept_socket(
        host_port: *mut ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_accept(
        sock: ::std::os::raw::c_int,
        ip_port: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_cleanup();
}
extern "C" {
    pub fn BIO_set_tcp_ndelay(
        sock: ::std::os::raw::c_int,
        turn_on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_new_socket(
        sock: ::std::os::raw::c_int,
        close_flag: ::std::os::raw::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_dgram(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fd(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_connect(host_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_accept(host_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        bio1: *mut *mut BIO,
        writebuf1: usize,
        bio2: *mut *mut BIO,
        writebuf2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_copy_next_retry(b: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vprintf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_BIO_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    pub length: usize,
    pub data: *mut ::std::os::raw::c_char,
    pub max: usize,
}
#[test]
fn bindgen_test_layout_buf_mem_st() {
    assert_eq!(
        ::std::mem::size_of::<buf_mem_st>(),
        24usize,
        concat!("Size of: ", stringify!(buf_mem_st))
    );
    assert_eq!(
        ::std::mem::align_of::<buf_mem_st>(),
        8usize,
        concat!("Alignment of ", stringify!(buf_mem_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(max)
        )
    );
}
extern "C" {
    pub fn BUF_MEM_new() -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_free(a: *mut BUF_MEM);
}
extern "C" {
    pub fn BUF_MEM_grow(str: *mut BUF_MEM, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BUF_MEM_grow_clean(str: *mut BUF_MEM, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BUF_strnlen(str: *const ::std::os::raw::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn BUF_strdup(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BUF_strndup(
        str: *const ::std::os::raw::c_char,
        siz: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BUF_memdup(
        data: *const ::std::os::raw::c_void,
        siz: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BUF_reverse(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        siz: usize,
    );
}
extern "C" {
    pub fn BUF_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: usize,
    ) -> usize;
}
extern "C" {
    pub fn BUF_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: usize,
    ) -> usize;
}
extern "C" {
    pub fn ERR_load_BUF_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    pub d: *mut ::std::os::raw::c_ulong,
    pub top: ::std::os::raw::c_int,
    pub dmax: ::std::os::raw::c_int,
    pub neg: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bignum_st() {
    assert_eq!(
        ::std::mem::size_of::<bignum_st>(),
        24usize,
        concat!("Size of: ", stringify!(bignum_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bignum_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bignum_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).top as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).dmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(dmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).neg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(neg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bignum_st>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    pub ri: ::std::os::raw::c_int,
    pub RR: BIGNUM,
    pub N: BIGNUM,
    pub Ni: BIGNUM,
    pub n0: [::std::os::raw::c_ulong; 2usize],
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bn_mont_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<bn_mont_ctx_st>(),
        104usize,
        concat!("Size of: ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_mont_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).ri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(ri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).RR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(RR)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).N as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).Ni as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(Ni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).n0 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(n0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_mont_ctx_st>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_recp_ctx_st {
    pub N: BIGNUM,
    pub Nr: BIGNUM,
    pub num_bits: ::std::os::raw::c_int,
    pub shift: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bn_recp_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<bn_recp_ctx_st>(),
        64usize,
        concat!("Size of: ", stringify!(bn_recp_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_recp_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_recp_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_recp_ctx_st>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_recp_ctx_st),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_recp_ctx_st>())).Nr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_recp_ctx_st),
            "::",
            stringify!(Nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_recp_ctx_st>())).num_bits as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_recp_ctx_st),
            "::",
            stringify!(num_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_recp_ctx_st>())).shift as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_recp_ctx_st),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_recp_ctx_st>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_recp_ctx_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn_gencb_st {
    pub ver: ::std::os::raw::c_uint,
    pub arg: *mut ::std::os::raw::c_void,
    pub cb: bn_gencb_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bn_gencb_st__bindgen_ty_1 {
    pub cb_1: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    pub cb_2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bn_gencb_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<bn_gencb_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bn_gencb_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_gencb_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_gencb_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st__bindgen_ty_1>())).cb_1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st__bindgen_ty_1),
            "::",
            stringify!(cb_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st__bindgen_ty_1>())).cb_2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st__bindgen_ty_1),
            "::",
            stringify!(cb_2)
        )
    );
}
#[test]
fn bindgen_test_layout_bn_gencb_st() {
    assert_eq!(
        ::std::mem::size_of::<bn_gencb_st>(),
        24usize,
        concat!("Size of: ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_gencb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bn_gencb_st>())).cb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(cb)
        )
    );
}
extern "C" {
    pub fn BN_GENCB_call(
        cb: *mut BN_GENCB,
        a: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_options() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_init(c: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_free(c: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_num_bits(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_num_bits_word(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_init(arg1: *mut BIGNUM);
}
extern "C" {
    pub fn BN_clear_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_copy(a: *mut BIGNUM, b: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_swap(a: *mut BIGNUM, b: *mut BIGNUM);
}
extern "C" {
    pub fn BN_bin2bn(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(a: *const BIGNUM, to: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mpi2bn(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2mpi(a: *const BIGNUM, to: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " BN_set_negative sets sign of a BIGNUM"]
    #[doc = " \\param  b  pointer to the BIGNUM object"]
    #[doc = " \\param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise"]
    pub fn BN_set_negative(b: *mut BIGNUM, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BN_div(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_div_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_mul_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_word(a: *const BIGNUM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        in_mont: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: ::std::os::raw::c_ulong,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_simple(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print(fp: *mut BIO, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_reciprocal(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        len: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(a: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2hex(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_hex2bn(
        a: *mut *mut BIGNUM,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_dec2bn(
        a: *mut *mut BIGNUM,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_asc2bn(
        a: *mut *mut BIGNUM,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_gcd(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_kronecker(
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_sqrt(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_consttime_swap(
        swap: ::std::os::raw::c_ulong,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        nwords: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn BN_generate_prime(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_is_prime(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::std::os::raw::c_void,
        do_trial_division: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_generate_Xpq(
        Xp: *mut BIGNUM,
        Xq: *mut BIGNUM,
        nbits: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_derive_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp: *const BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_generate_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp1: *mut BIGNUM,
        Xp2: *mut BIGNUM,
        Xp: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_init(ctx: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_set(
        mont: *mut BN_MONT_CTX,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *mut BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set_locked(
        pmont: *mut *mut BN_MONT_CTX,
        lock: ::std::os::raw::c_int,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_BLINDING_new(
        A: *const BIGNUM,
        Ai: *const BIGNUM,
        mod_: *mut BIGNUM,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_BLINDING_free(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_update(b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert_ex(
        n: *mut BIGNUM,
        r: *mut BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert_ex(
        n: *mut BIGNUM,
        r: *const BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_get_thread_id(arg1: *const BN_BLINDING) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_BLINDING_set_thread_id(arg1: *mut BN_BLINDING, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn BN_BLINDING_thread_id(arg1: *mut BN_BLINDING) -> *mut CRYPTO_THREADID;
}
extern "C" {
    pub fn BN_BLINDING_get_flags(arg1: *const BN_BLINDING) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_BLINDING_set_flags(arg1: *mut BN_BLINDING, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn BN_BLINDING_create_param(
        b: *mut BN_BLINDING,
        e: *const BIGNUM,
        m: *mut BIGNUM,
        ctx: *mut BN_CTX,
        bn_mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        m_ctx: *mut BN_MONT_CTX,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_set_params(
        mul: ::std::os::raw::c_int,
        high: ::std::os::raw::c_int,
        low: ::std::os::raw::c_int,
        mont: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn BN_get_params(which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_RECP_CTX_init(recp: *mut BN_RECP_CTX);
}
extern "C" {
    pub fn BN_RECP_CTX_new() -> *mut BN_RECP_CTX;
}
extern "C" {
    pub fn BN_RECP_CTX_free(recp: *mut BN_RECP_CTX);
}
extern "C" {
    pub fn BN_RECP_CTX_set(
        recp: *mut BN_RECP_CTX,
        rdiv: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul_reciprocal(
        r: *mut BIGNUM,
        x: *const BIGNUM,
        y: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_recp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div_recp(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod(r: *mut BIGNUM, a: *const BIGNUM, p: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv_arr(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_poly2arr(
        a: *const BIGNUM,
        p: *mut ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_arr2poly(
        p: *const ::std::os::raw::c_int,
        a: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_192(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_224(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_256(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_384(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_521(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get0_nist_prime_192() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_224() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_256() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_384() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_521() -> *const BIGNUM;
}
extern "C" {
    pub fn bn_expand2(a: *mut BIGNUM, words: ::std::os::raw::c_int) -> *mut BIGNUM;
}
extern "C" {
    pub fn bn_dup_expand(a: *const BIGNUM, words: ::std::os::raw::c_int) -> *mut BIGNUM;
}
extern "C" {
    pub fn bn_mul_add_words(
        rp: *mut ::std::os::raw::c_ulong,
        ap: *const ::std::os::raw::c_ulong,
        num: ::std::os::raw::c_int,
        w: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bn_mul_words(
        rp: *mut ::std::os::raw::c_ulong,
        ap: *const ::std::os::raw::c_ulong,
        num: ::std::os::raw::c_int,
        w: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bn_sqr_words(
        rp: *mut ::std::os::raw::c_ulong,
        ap: *const ::std::os::raw::c_ulong,
        num: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bn_div_words(
        h: ::std::os::raw::c_ulong,
        l: ::std::os::raw::c_ulong,
        d: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bn_add_words(
        rp: *mut ::std::os::raw::c_ulong,
        ap: *const ::std::os::raw::c_ulong,
        bp: *const ::std::os::raw::c_ulong,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bn_sub_words(
        rp: *mut ::std::os::raw::c_ulong,
        ap: *const ::std::os::raw::c_ulong,
        bp: *const ::std::os::raw::c_ulong,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_rfc2409_prime_768(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc2409_prime_1024(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_1536(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_2048(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_3072(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_4096(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_6144(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn get_rfc3526_prime_8192(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bntest_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_BN_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ALGOR {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_ALGOR() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_ALGOR>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_ALGOR))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_ALGOR>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_ALGOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_ALGOR>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_ALGOR),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_ctx_st {
    pub p: *mut ::std::os::raw::c_uchar,
    pub eos: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub inf: ::std::os::raw::c_int,
    pub tag: ::std::os::raw::c_int,
    pub xclass: ::std::os::raw::c_int,
    pub slen: ::std::os::raw::c_long,
    pub max: *mut ::std::os::raw::c_uchar,
    pub q: *mut ::std::os::raw::c_uchar,
    pub pp: *mut *mut ::std::os::raw::c_uchar,
    pub line: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn1_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_ctx_st>(),
        72usize,
        concat!("Size of: ", stringify!(asn1_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).eos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(eos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).error as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).inf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).tag as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).xclass as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(xclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).slen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(slen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).q as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).pp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(pp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_ctx_st>())).line as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_ctx_st),
            "::",
            stringify!(line)
        )
    );
}
pub type ASN1_CTX = asn1_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_const_ctx_st {
    pub p: *const ::std::os::raw::c_uchar,
    pub eos: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub inf: ::std::os::raw::c_int,
    pub tag: ::std::os::raw::c_int,
    pub xclass: ::std::os::raw::c_int,
    pub slen: ::std::os::raw::c_long,
    pub max: *const ::std::os::raw::c_uchar,
    pub q: *const ::std::os::raw::c_uchar,
    pub pp: *mut *const ::std::os::raw::c_uchar,
    pub line: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn1_const_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_const_ctx_st>(),
        72usize,
        concat!("Size of: ", stringify!(asn1_const_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_const_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_const_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).eos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(eos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).error as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).inf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).tag as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).xclass as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(xclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).slen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(slen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).q as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).pp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(pp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_const_ctx_st>())).line as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_const_ctx_st),
            "::",
            stringify!(line)
        )
    );
}
pub type ASN1_const_CTX = asn1_const_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    pub sn: *const ::std::os::raw::c_char,
    pub ln: *const ::std::os::raw::c_char,
    pub nid: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub data: *const ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn1_object_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_object_st>(),
        40usize,
        concat!("Size of: ", stringify!(asn1_object_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_object_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_object_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).sn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(sn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).ln as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(ln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).nid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_object_st>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_object_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_asn1_string_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_string_st>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_string_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ENCODING_st {
    pub enc: *mut ::std::os::raw::c_uchar,
    pub len: ::std::os::raw::c_long,
    pub modified: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_ENCODING_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_ENCODING_st>(),
        24usize,
        concat!("Size of: ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ENCODING_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).modified as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(modified)
        )
    );
}
pub type ASN1_ENCODING = ASN1_ENCODING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_table_st {
    pub nid: ::std::os::raw::c_int,
    pub minsize: ::std::os::raw::c_long,
    pub maxsize: ::std::os::raw::c_long,
    pub mask: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_asn1_string_table_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_string_table_st>(),
        40usize,
        concat!("Size of: ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_table_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).minsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(minsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).maxsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type ASN1_STRING_TABLE = asn1_string_table_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_STRING_TABLE {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_ASN1_STRING_TABLE() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_ASN1_STRING_TABLE>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_ASN1_STRING_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_ASN1_STRING_TABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_ASN1_STRING_TABLE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_ASN1_STRING_TABLE>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_ASN1_STRING_TABLE),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    _unused: [u8; 0],
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    _unused: [u8; 0],
}
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
pub type d2i_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type i2d_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ITEM_EXP = ASN1_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_INTEGER {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_ASN1_INTEGER() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_ASN1_INTEGER>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_ASN1_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_ASN1_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_ASN1_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_ASN1_INTEGER>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_ASN1_INTEGER),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_GENERALSTRING {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_ASN1_GENERALSTRING() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_ASN1_GENERALSTRING>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_ASN1_GENERALSTRING))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_ASN1_GENERALSTRING>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_ASN1_GENERALSTRING))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_ASN1_GENERALSTRING>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_ASN1_GENERALSTRING),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: ::std::os::raw::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_asn1_type_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).enumerated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(enumerated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bit_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bit_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).octet_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(octet_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).printablestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(printablestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).t61string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(t61string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ia5string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ia5string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bmpstring as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bmpstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).universalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(universalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utctime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utctime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalizedtime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalizedtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).visiblestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(visiblestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utf8string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utf8string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_value)
        )
    );
}
#[test]
fn bindgen_test_layout_asn1_type_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_type_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(value)
        )
    );
}
pub type ASN1_TYPE = asn1_type_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_ASN1_TYPE() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_ASN1_TYPE>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_ASN1_TYPE))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_ASN1_TYPE>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_ASN1_TYPE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_ASN1_TYPE>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_ASN1_TYPE),
            "::",
            stringify!(stack)
        )
    );
}
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn d2i_ASN1_SEQUENCE_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SEQUENCE_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_SEQUENCE_ANY_it"]
    pub static ASN1_SEQUENCE_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_SET_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SET_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_SET_ANY_it"]
    pub static ASN1_SET_ANY_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NETSCAPE_X509_st {
    pub header: *mut ASN1_OCTET_STRING,
    pub cert: *mut X509,
}
#[test]
fn bindgen_test_layout_NETSCAPE_X509_st() {
    assert_eq!(
        ::std::mem::size_of::<NETSCAPE_X509_st>(),
        16usize,
        concat!("Size of: ", stringify!(NETSCAPE_X509_st))
    );
    assert_eq!(
        ::std::mem::align_of::<NETSCAPE_X509_st>(),
        8usize,
        concat!("Alignment of ", stringify!(NETSCAPE_X509_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NETSCAPE_X509_st>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NETSCAPE_X509_st),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NETSCAPE_X509_st>())).cert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NETSCAPE_X509_st),
            "::",
            stringify!(cert)
        )
    );
}
pub type NETSCAPE_X509 = NETSCAPE_X509_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BIT_STRING_BITNAME_st {
    pub bitnum: ::std::os::raw::c_int,
    pub lname: *const ::std::os::raw::c_char,
    pub sname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BIT_STRING_BITNAME_st() {
    assert_eq!(
        ::std::mem::size_of::<BIT_STRING_BITNAME_st>(),
        24usize,
        concat!("Size of: ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        ::std::mem::align_of::<BIT_STRING_BITNAME_st>(),
        8usize,
        concat!("Alignment of ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).bitnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(bitnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).lname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(lname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).sname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(sname)
        )
    );
}
pub type BIT_STRING_BITNAME = BIT_STRING_BITNAME_st;
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub fn d2i_ASN1_TYPE(
        a: *mut *mut ASN1_TYPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn i2d_ASN1_TYPE(
        a: *mut ASN1_TYPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_ANY_it"]
    pub static ASN1_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *mut ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_new() -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn i2d_ASN1_OBJECT(
        a: *mut ASN1_OBJECT,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_OBJECT(
        a: *mut *mut ASN1_OBJECT,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn d2i_ASN1_OBJECT(
        a: *mut *mut ASN1_OBJECT,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    #[link_name = "\u{1}ASN1_OBJECT_it"]
    pub static ASN1_OBJECT_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_OBJECT {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_ASN1_OBJECT() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_ASN1_OBJECT>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_ASN1_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_ASN1_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_ASN1_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_ASN1_OBJECT>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_ASN1_OBJECT),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_clear_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(
        dst: *mut ASN1_STRING,
        str: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(a: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: ::std::os::raw::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str: *mut ASN1_STRING,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(
        str: *mut ASN1_STRING,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_STRING_length(x: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_length_set(x: *mut ASN1_STRING, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ASN1_STRING_type(x: *mut ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_data(x: *mut ASN1_STRING) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(a: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn d2i_ASN1_BIT_STRING(
        a: *mut *mut ASN1_BIT_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2d_ASN1_BIT_STRING(
        a: *mut ASN1_BIT_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_BIT_STRING_it"]
    pub static ASN1_BIT_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn i2c_ASN1_BIT_STRING(
        a: *mut ASN1_BIT_STRING,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_BIT_STRING(
        a: *mut *mut ASN1_BIT_STRING,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        a: *mut ASN1_BIT_STRING,
        d: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        a: *mut ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(
        a: *mut ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        a: *mut ASN1_BIT_STRING,
        flags: *mut ::std::os::raw::c_uchar,
        flags_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_name_print(
        out: *mut BIO,
        bs: *mut ASN1_BIT_STRING,
        tbl: *mut BIT_STRING_BITNAME,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_asc(
        name: *mut ::std::os::raw::c_char,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_asc(
        bs: *mut ASN1_BIT_STRING,
        name: *mut ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_BOOLEAN(
        a: ::std::os::raw::c_int,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ASN1_BOOLEAN(
        a: *mut ::std::os::raw::c_int,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(a: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn d2i_ASN1_INTEGER(
        a: *mut *mut ASN1_INTEGER,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2d_ASN1_INTEGER(
        a: *mut ASN1_INTEGER,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_INTEGER_it"]
    pub static ASN1_INTEGER_it: ASN1_ITEM;
}
extern "C" {
    pub fn i2c_ASN1_INTEGER(
        a: *mut ASN1_INTEGER,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_INTEGER(
        a: *mut *mut ASN1_INTEGER,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn d2i_ASN1_UINTEGER(
        a: *mut *mut ASN1_INTEGER,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_dup(x: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(
        x: *const ASN1_INTEGER,
        y: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(a: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub fn d2i_ASN1_ENUMERATED(
        a: *mut *mut ASN1_ENUMERATED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn i2d_ASN1_ENUMERATED(
        a: *mut ASN1_ENUMERATED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_ENUMERATED_it"]
    pub static ASN1_ENUMERATED_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, t: time_t) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(
        s: *mut ASN1_UTCTIME,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        pday: *mut ::std::os::raw::c_int,
        psec: *mut ::std::os::raw::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(a: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn d2i_ASN1_OCTET_STRING(
        a: *mut *mut ASN1_OCTET_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn i2d_ASN1_OCTET_STRING(
        a: *mut ASN1_OCTET_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_OCTET_STRING_it"]
    pub static ASN1_OCTET_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(
        a: *const ASN1_OCTET_STRING,
        b: *const ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str: *mut ASN1_OCTET_STRING,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(a: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_VISIBLESTRING(
        a: *mut *mut ASN1_VISIBLESTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_VISIBLESTRING(
        a: *mut ASN1_VISIBLESTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_VISIBLESTRING_it"]
    pub static ASN1_VISIBLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(a: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_UNIVERSALSTRING(
        a: *mut *mut ASN1_UNIVERSALSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_UNIVERSALSTRING(
        a: *mut ASN1_UNIVERSALSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_UNIVERSALSTRING_it"]
    pub static ASN1_UNIVERSALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(a: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn d2i_ASN1_UTF8STRING(
        a: *mut *mut ASN1_UTF8STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn i2d_ASN1_UTF8STRING(
        a: *mut ASN1_UTF8STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_UTF8STRING_it"]
    pub static ASN1_UTF8STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(a: *mut ASN1_NULL);
}
extern "C" {
    pub fn d2i_ASN1_NULL(
        a: *mut *mut ASN1_NULL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_NULL;
}
extern "C" {
    pub fn i2d_ASN1_NULL(
        a: *mut ASN1_NULL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_NULL_it"]
    pub static ASN1_NULL_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(a: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn d2i_ASN1_BMPSTRING(
        a: *mut *mut ASN1_BMPSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn i2d_ASN1_BMPSTRING(
        a: *mut ASN1_BMPSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_BMPSTRING_it"]
    pub static ASN1_BMPSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn UTF8_getc(
        str: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UTF8_putc(
        str: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLE(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLE(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_PRINTABLE_it"]
    pub static ASN1_PRINTABLE_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIRECTORYSTRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DIRECTORYSTRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DIRECTORYSTRING(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DIRECTORYSTRING(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}DIRECTORYSTRING_it"]
    pub static DIRECTORYSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn DISPLAYTEXT_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DISPLAYTEXT_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DISPLAYTEXT(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DISPLAYTEXT(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}DISPLAYTEXT_it"]
    pub static DISPLAYTEXT_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(a: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLESTRING(
        a: *mut *mut ASN1_PRINTABLESTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLESTRING(
        a: *mut ASN1_PRINTABLESTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_PRINTABLESTRING_it"]
    pub static ASN1_PRINTABLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_T61STRING_free(a: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn d2i_ASN1_T61STRING(
        a: *mut *mut ASN1_T61STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn i2d_ASN1_T61STRING(
        a: *mut ASN1_T61STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_T61STRING_it"]
    pub static ASN1_T61STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_free(a: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn d2i_ASN1_IA5STRING(
        a: *mut *mut ASN1_IA5STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn i2d_ASN1_IA5STRING(
        a: *mut ASN1_IA5STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_IA5STRING_it"]
    pub static ASN1_IA5STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(a: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_GENERALSTRING(
        a: *mut *mut ASN1_GENERALSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_GENERALSTRING(
        a: *mut ASN1_GENERALSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_GENERALSTRING_it"]
    pub static ASN1_GENERALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(a: *mut ASN1_UTCTIME);
}
extern "C" {
    pub fn d2i_ASN1_UTCTIME(
        a: *mut *mut ASN1_UTCTIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn i2d_ASN1_UTCTIME(
        a: *mut ASN1_UTCTIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_UTCTIME_it"]
    pub static ASN1_UTCTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(a: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub fn d2i_ASN1_GENERALIZEDTIME(
        a: *mut *mut ASN1_GENERALIZEDTIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn i2d_ASN1_GENERALIZEDTIME(
        a: *mut ASN1_GENERALIZEDTIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_GENERALIZEDTIME_it"]
    pub static ASN1_GENERALIZEDTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(a: *mut ASN1_TIME);
}
extern "C" {
    pub fn d2i_ASN1_TIME(
        a: *mut *mut ASN1_TIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn i2d_ASN1_TIME(
        a: *mut ASN1_TIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ASN1_TIME_it"]
    pub static ASN1_TIME_it: ASN1_ITEM;
}
extern "C" {
    #[link_name = "\u{1}ASN1_OCTET_STRING_NDEF_it"]
    pub static ASN1_OCTET_STRING_NDEF_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, t: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *mut ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *mut ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(
        s: *mut ASN1_TIME,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_SET(
        a: *mut stack_st_OPENSSL_BLOCK,
        pp: *mut *mut ::std::os::raw::c_uchar,
        i2d: i2d_of_void,
        ex_tag: ::std::os::raw::c_int,
        ex_class: ::std::os::raw::c_int,
        is_set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ASN1_SET(
        a: *mut *mut stack_st_OPENSSL_BLOCK,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
        d2i: d2i_of_void,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: OPENSSL_BLOCK)>,
        ex_tag: ::std::os::raw::c_int,
        ex_class: ::std::os::raw::c_int,
    ) -> *mut stack_st_OPENSSL_BLOCK;
}
extern "C" {
    pub fn i2a_ASN1_INTEGER(bp: *mut BIO, a: *mut ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_INTEGER(
        bp: *mut BIO,
        bs: *mut ASN1_INTEGER,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_ENUMERATED(bp: *mut BIO, a: *mut ASN1_ENUMERATED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_ENUMERATED(
        bp: *mut BIO,
        bs: *mut ASN1_ENUMERATED,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_OBJECT(bp: *mut BIO, a: *mut ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_STRING(
        bp: *mut BIO,
        bs: *mut ASN1_STRING,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_STRING(
        bp: *mut BIO,
        a: *mut ASN1_STRING,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2t_ASN1_OBJECT(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        a: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2d_ASN1_OBJECT(
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_INTEGER_set(
        a: *mut ASN1_INTEGER,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(
        a: *mut ASN1_ENUMERATED,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *mut ASN1_ENUMERATED) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(bn: *mut BIGNUM, ai: *mut ASN1_ENUMERATED)
        -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *mut ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_PRINTABLE_type(
        s: *const ::std::os::raw::c_uchar,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_bytes(
        a: *mut ASN1_STRING,
        pp: *mut *mut ::std::os::raw::c_uchar,
        tag: ::std::os::raw::c_int,
        xclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ASN1_bytes(
        a: *mut *mut ASN1_STRING,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
        Ptag: ::std::os::raw::c_int,
        Pclass: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn d2i_ASN1_type_bytes(
        a: *mut *mut ASN1_STRING,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
        type_: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn asn1_Finish(c: *mut ASN1_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asn1_const_Finish(c: *mut ASN1_const_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_get_object(
        pp: *mut *const ::std::os::raw::c_uchar,
        plength: *mut ::std::os::raw::c_long,
        ptag: *mut ::std::os::raw::c_int,
        pclass: *mut ::std::os::raw::c_int,
        omax: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_check_infinite_end(
        p: *mut *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_const_check_infinite_end(
        p: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        pp: *mut *mut ::std::os::raw::c_uchar,
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
        xclass: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(pp: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_dup(
        i2d: i2d_of_void,
        d2i: d2i_of_void,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_dup(
        it: *const ASN1_ITEM,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_d2i_fp(
        xnew: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
        d2i: d2i_of_void,
        in_: *mut FILE,
        x: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_i2d_fp(
        i2d: i2d_of_void,
        out: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str: *mut ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut ::std::os::raw::c_uchar,
        in_: *mut ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_d2i_bio(
        xnew: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
        d2i: d2i_of_void,
        in_: *mut BIO,
        x: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_i2d_bio(
        i2d: i2d_of_void,
        out: *mut BIO,
        x: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_print(fp: *mut BIO, a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(
        fp: *mut BIO,
        a: *const ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(fp: *mut BIO, a: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(bp: *mut BIO, v: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str: *mut ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_bn_print(
        bp: *mut BIO,
        number: *const ::std::os::raw::c_char,
        num: *const BIGNUM,
        buf: *mut ::std::os::raw::c_uchar,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_parse(
        bp: *mut BIO,
        pp: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_parse_dump(
        bp: *mut BIO,
        pp: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        indent: ::std::os::raw::c_int,
        dump: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_tag2str(tag: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NETSCAPE_X509_new() -> *mut NETSCAPE_X509;
}
extern "C" {
    pub fn NETSCAPE_X509_free(a: *mut NETSCAPE_X509);
}
extern "C" {
    pub fn d2i_NETSCAPE_X509(
        a: *mut *mut NETSCAPE_X509,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_X509;
}
extern "C" {
    pub fn i2d_NETSCAPE_X509(
        a: *mut NETSCAPE_X509,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}NETSCAPE_X509_it"]
    pub static NETSCAPE_X509_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_to_string(s: *mut ASN1_UNIVERSALSTRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_octetstring(
        a: *mut ASN1_TYPE,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_octetstring(
        a: *mut ASN1_TYPE,
        data: *mut ::std::os::raw::c_uchar,
        max_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_int_octetstring(
        a: *mut ASN1_TYPE,
        num: ::std::os::raw::c_long,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_int_octetstring(
        a: *mut ASN1_TYPE,
        num: *mut ::std::os::raw::c_long,
        data: *mut ::std::os::raw::c_uchar,
        max_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_seq_unpack(
        buf: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        d2i: d2i_of_void,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: OPENSSL_BLOCK)>,
    ) -> *mut stack_st_OPENSSL_BLOCK;
}
extern "C" {
    pub fn ASN1_seq_pack(
        safes: *mut stack_st_OPENSSL_BLOCK,
        i2d: i2d_of_void,
        buf: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_unpack_string(
        oct: *mut ASN1_STRING,
        d2i: d2i_of_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_unpack(
        oct: *mut ASN1_STRING,
        it: *const ASN1_ITEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_pack_string(
        obj: *mut ::std::os::raw::c_void,
        i2d: i2d_of_void,
        oct: *mut *mut ASN1_OCTET_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut ::std::os::raw::c_void,
        it: *const ASN1_ITEM,
        oct: *mut *mut ASN1_OCTET_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
        minsize: ::std::os::raw::c_long,
        maxsize: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_get(nid: ::std::os::raw::c_int) -> *mut ASN1_STRING_TABLE;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i(
        val: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_ndef_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_add_oid_module();
}
extern "C" {
    pub fn ASN1_generate_nconf(
        str: *mut ::std::os::raw::c_char,
        nconf: *mut CONF,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_generate_v3(
        str: *mut ::std::os::raw::c_char,
        cnf: *mut X509V3_CTX,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_item_print(
        out: *mut BIO,
        ifld: *mut ASN1_VALUE,
        indent: ::std::os::raw::c_int,
        it: *const ASN1_ITEM,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PCTX_new() -> *mut ASN1_PCTX;
}
extern "C" {
    pub fn ASN1_PCTX_free(p: *mut ASN1_PCTX);
}
extern "C" {
    pub fn ASN1_PCTX_get_flags(p: *mut ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_nm_flags(p: *mut ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_nm_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_cert_flags(p: *mut ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_cert_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_oid_flags(p: *mut ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_oid_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_str_flags(p: *mut ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_str_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn BIO_f_asn1() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_NDEF(out: *mut BIO, val: *mut ASN1_VALUE, it: *const ASN1_ITEM) -> *mut BIO;
}
extern "C" {
    pub fn i2d_ASN1_bio_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_ASN1_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
        hdr: *const ::std::os::raw::c_char,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_write_ASN1(
        bio: *mut BIO,
        val: *mut ASN1_VALUE,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
        ctype_nid: ::std::os::raw::c_int,
        econt_nid: ::std::os::raw::c_int,
        mdalgs: *mut stack_st_X509_ALGOR,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_read_ASN1(
        bio: *mut BIO,
        bcont: *mut *mut BIO,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn SMIME_crlf_copy(
        in_: *mut BIO,
        out: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_text(in_: *mut BIO, out: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_ASN1_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_name_st {
    pub type_: ::std::os::raw::c_int,
    pub alias: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obj_name_st() {
    assert_eq!(
        ::std::mem::size_of::<obj_name_st>(),
        24usize,
        concat!("Size of: ", stringify!(obj_name_st))
    );
    assert_eq!(
        ::std::mem::align_of::<obj_name_st>(),
        8usize,
        concat!("Alignment of ", stringify!(obj_name_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).alias as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(data)
        )
    );
}
pub type OBJ_NAME = obj_name_st;
extern "C" {
    pub fn OBJ_NAME_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_new_index(
        hash_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong,
        >,
        cmp_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        free_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_get(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_NAME_add(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_remove(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_cleanup(type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn OBJ_NAME_do_all(
        type_: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OBJ_NAME_do_all_sorted(
        type_: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OBJ_dup(o: *const ASN1_OBJECT) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2obj(n: ::std::os::raw::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2ln(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_nid2sn(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_obj2nid(o: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2obj(
        s: *const ::std::os::raw::c_char,
        no_name: ::std::os::raw::c_int,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_obj2txt(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        a: *const ASN1_OBJECT,
        no_name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_ln2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_sn2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_cmp(a: *const ASN1_OBJECT, b: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_bsearch_(
        key: *const ::std::os::raw::c_void,
        base: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn OBJ_bsearch_ex_(
        key: *const ::std::os::raw::c_void,
        base: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn OBJ_new_nid(num: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_add_object(obj: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_create(
        oid: *const ::std::os::raw::c_char,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_cleanup();
}
extern "C" {
    pub fn OBJ_create_objects(in_: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_algs(
        signid: ::std::os::raw::c_int,
        pdig_nid: *mut ::std::os::raw::c_int,
        ppkey_nid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_by_algs(
        psignid: *mut ::std::os::raw::c_int,
        dig_nid: ::std::os::raw::c_int,
        pkey_nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_add_sigid(
        signid: ::std::os::raw::c_int,
        dig_id: ::std::os::raw::c_int,
        pkey_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_sigid_free();
}
extern "C" {
    #[link_name = "\u{1}obj_cleanup_defer"]
    pub static mut obj_cleanup_defer: ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_defer(nid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ERR_load_OBJ_strings();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_pkey_st {
    pub type_: ::std::os::raw::c_int,
    pub save_type: ::std::os::raw::c_int,
    pub references: ::std::os::raw::c_int,
    pub ameth: *const EVP_PKEY_ASN1_METHOD,
    pub engine: *mut ENGINE,
    pub pkey: evp_pkey_st__bindgen_ty_1,
    pub save_parameters: ::std::os::raw::c_int,
    pub attributes: *mut stack_st_X509_ATTRIBUTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evp_pkey_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub rsa: *mut rsa_st,
    pub dsa: *mut dsa_st,
    pub dh: *mut dh_st,
    pub ec: *mut ec_key_st,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_evp_pkey_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(dsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(ec)
        )
    );
}
#[test]
fn bindgen_test_layout_evp_pkey_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st>(),
        56usize,
        concat!("Size of: ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).save_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(save_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).references as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).ameth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(ameth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).engine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).pkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).save_parameters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(save_parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).attributes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_st {
    pub type_: ::std::os::raw::c_int,
    pub pkey_type: ::std::os::raw::c_int,
    pub md_size: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_ulong,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int>,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            data: *const ::std::os::raw::c_void,
            count: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub final_: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            md: *mut ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(to: *mut EVP_MD_CTX, from: *const EVP_MD_CTX) -> ::std::os::raw::c_int,
    >,
    pub cleanup:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int>,
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            m: *const ::std::os::raw::c_uchar,
            m_length: ::std::os::raw::c_uint,
            sigret: *mut ::std::os::raw::c_uchar,
            siglen: *mut ::std::os::raw::c_uint,
            key: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            m: *const ::std::os::raw::c_uchar,
            m_length: ::std::os::raw::c_uint,
            sigbuf: *const ::std::os::raw::c_uchar,
            siglen: ::std::os::raw::c_uint,
            key: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub required_pkey_type: [::std::os::raw::c_int; 5usize],
    pub block_size: ::std::os::raw::c_int,
    pub ctx_size: ::std::os::raw::c_int,
    pub md_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            cmd: ::std::os::raw::c_int,
            p1: ::std::os::raw::c_int,
            p2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_env_md_st() {
    assert_eq!(
        ::std::mem::size_of::<env_md_st>(),
        120usize,
        concat!("Size of: ", stringify!(env_md_st))
    );
    assert_eq!(
        ::std::mem::align_of::<env_md_st>(),
        8usize,
        concat!("Alignment of ", stringify!(env_md_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).pkey_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(pkey_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).md_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(md_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).update as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).final_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(final_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).copy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).cleanup as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).sign as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).verify as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).required_pkey_type as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(required_pkey_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).block_size as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).ctx_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(ctx_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_st>())).md_ctrl as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_st),
            "::",
            stringify!(md_ctrl)
        )
    );
}
pub type evp_sign_method = ::std::option::Option<
    unsafe extern "C" fn(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type evp_verify_method = ::std::option::Option<
    unsafe extern "C" fn(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_ctx_st {
    pub digest: *const EVP_MD,
    pub engine: *mut ENGINE,
    pub flags: ::std::os::raw::c_ulong,
    pub md_data: *mut ::std::os::raw::c_void,
    pub pctx: *mut EVP_PKEY_CTX,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            data: *const ::std::os::raw::c_void,
            count: usize,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_env_md_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<env_md_ctx_st>(),
        48usize,
        concat!("Size of: ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<env_md_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).engine as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).md_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(pctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).update as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(update)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    pub nid: ::std::os::raw::c_int,
    pub block_size: ::std::os::raw::c_int,
    pub key_len: ::std::os::raw::c_int,
    pub iv_len: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_ulong,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_CIPHER_CTX,
            key: *const ::std::os::raw::c_uchar,
            iv: *const ::std::os::raw::c_uchar,
            enc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub do_cipher: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_CIPHER_CTX,
            out: *mut ::std::os::raw::c_uchar,
            in_: *const ::std::os::raw::c_uchar,
            inl: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int,
    >,
    pub ctx_size: ::std::os::raw::c_int,
    pub set_asn1_parameters: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut EVP_CIPHER_CTX,
            arg2: *mut ASN1_TYPE,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_asn1_parameters: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut EVP_CIPHER_CTX,
            arg2: *mut ASN1_TYPE,
        ) -> ::std::os::raw::c_int,
    >,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut EVP_CIPHER_CTX,
            type_: ::std::os::raw::c_int,
            arg: ::std::os::raw::c_int,
            ptr: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub app_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_evp_cipher_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_st>(),
        88usize,
        concat!("Size of: ", stringify!(evp_cipher_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).block_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).iv_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(iv_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).do_cipher as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(do_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).cleanup as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).ctx_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(ctx_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evp_cipher_st>())).set_asn1_parameters as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(set_asn1_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<evp_cipher_st>())).get_asn1_parameters as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(get_asn1_parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).ctrl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_st>())).app_data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_st),
            "::",
            stringify!(app_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM {
    pub out: *mut ::std::os::raw::c_uchar,
    pub inp: *const ::std::os::raw::c_uchar,
    pub len: usize,
    pub interleave: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        32usize,
        concat!("Size of: ", stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).out as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).inp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(inp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).interleave as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(interleave)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_info_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_info_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).iv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(iv)
        )
    );
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    pub cipher: *const EVP_CIPHER,
    pub engine: *mut ENGINE,
    pub encrypt: ::std::os::raw::c_int,
    pub buf_len: ::std::os::raw::c_int,
    pub oiv: [::std::os::raw::c_uchar; 16usize],
    pub iv: [::std::os::raw::c_uchar; 16usize],
    pub buf: [::std::os::raw::c_uchar; 32usize],
    pub num: ::std::os::raw::c_int,
    pub app_data: *mut ::std::os::raw::c_void,
    pub key_len: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_ulong,
    pub cipher_data: *mut ::std::os::raw::c_void,
    pub final_used: ::std::os::raw::c_int,
    pub block_mask: ::std::os::raw::c_int,
    pub final_: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_ctx_st>(),
        168usize,
        concat!("Size of: ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).engine as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).encrypt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).buf_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).oiv as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(oiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).iv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).buf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).num as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).app_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).key_len as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).cipher_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(cipher_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).final_used as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(final_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).block_mask as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(block_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_ctx_st>())).final_ as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(final_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_Encode_Ctx_st {
    pub num: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub enc_data: [::std::os::raw::c_uchar; 80usize],
    pub line_num: ::std::os::raw::c_int,
    pub expect_nl: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_evp_Encode_Ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_Encode_Ctx_st>(),
        96usize,
        concat!("Size of: ", stringify!(evp_Encode_Ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_Encode_Ctx_st>(),
        4usize,
        concat!("Alignment of ", stringify!(evp_Encode_Ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_Encode_Ctx_st>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_Encode_Ctx_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_Encode_Ctx_st>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_Encode_Ctx_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_Encode_Ctx_st>())).enc_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_Encode_Ctx_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_Encode_Ctx_st>())).line_num as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_Encode_Ctx_st),
            "::",
            stringify!(line_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_Encode_Ctx_st>())).expect_nl as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_Encode_Ctx_st),
            "::",
            stringify!(expect_nl)
        )
    );
}
pub type EVP_ENCODE_CTX = evp_Encode_Ctx_st;
pub type EVP_PBE_KEYGEN = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn EVP_MD_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_pkey_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_size(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_block_size(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_flags(md: *const EVP_MD) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_flags(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_nid(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(
        out: *mut EVP_CIPHER_CTX,
        in_: *const EVP_CIPHER_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_flags(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_Cipher(
        c: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_init(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_cleanup(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_create() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_destroy(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(
        out: *mut EVP_MD_CTX,
        in_: *const EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_clear_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_test_flags(
        ctx: *const EVP_MD_CTX,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *const ::std::os::raw::c_void,
        cnt: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const ::std::os::raw::c_void,
        count: usize,
        md: *mut ::std::os::raw::c_uchar,
        size: *mut ::std::os::raw::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string(
        buf: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        prompt: *const ::std::os::raw::c_char,
        verify: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string_min(
        buf: *mut ::std::os::raw::c_char,
        minlen: ::std::os::raw::c_int,
        maxlen: ::std::os::raw::c_int,
        prompt: *const ::std::os::raw::c_char,
        verify: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_set_pw_prompt(prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn EVP_get_pw_prompt() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        datal: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_uchar,
        iv: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_clear_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_test_flags(
        ctx: *const EVP_CIPHER_CTX,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const ::std::os::raw::c_uchar,
        siglen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_OpenInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *const ::std::os::raw::c_uchar,
        ekl: ::std::os::raw::c_int,
        iv: *const ::std::os::raw::c_uchar,
        priv_: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_OpenFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SealInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *mut *mut ::std::os::raw::c_uchar,
        ekl: *mut ::std::os::raw::c_int,
        iv: *mut ::std::os::raw::c_uchar,
        pubk: *mut *mut EVP_PKEY,
        npubk: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SealFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_EncodeBlock(
        t: *mut ::std::os::raw::c_uchar,
        f: *const ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(
        t: *mut ::std::os::raw::c_uchar,
        f: *const ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_init(a: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cleanup(a: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(a: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        x: *mut EVP_CIPHER_CTX,
        keylen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(
        c: *mut EVP_CIPHER_CTX,
        pad: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        type_: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_rand_key(
        ctx: *mut EVP_CIPHER_CTX,
        key: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_md() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_base64() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_cipher() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_reliable() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_cipher(
        b: *mut BIO,
        c: *const EVP_CIPHER,
        k: *const ::std::os::raw::c_uchar,
        i: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_md_null() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_dss() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_dss1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ecdsa() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_mdc2() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ripemd160() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_whirlpool() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_desx_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_40() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_hmac_md5() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_64_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn OPENSSL_add_all_algorithms_noconf();
}
extern "C" {
    pub fn OPENSSL_add_all_algorithms_conf();
}
extern "C" {
    pub fn OpenSSL_add_all_ciphers();
}
extern "C" {
    pub fn OpenSSL_add_all_digests();
}
extern "C" {
    pub fn EVP_add_cipher(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const ::std::os::raw::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_digestbyname(name: *const ::std::os::raw::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_cleanup();
}
extern "C" {
    pub fn EVP_CIPHER_do_all(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_PKEY_decrypt_old(
        dec_key: *mut ::std::os::raw::c_uchar,
        enc_key: *const ::std::os::raw::c_uchar,
        enc_key_len: ::std::os::raw::c_int,
        private_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_old(
        enc_key: *mut ::std::os::raw::c_uchar,
        key: *const ::std::os::raw::c_uchar,
        key_len: ::std::os::raw::c_int,
        pub_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(type_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_base_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_bits(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_size(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type_str(
        pkey: *mut EVP_PKEY,
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *mut EVP_PKEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut rsa_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut dsa_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DH(pkey: *mut EVP_PKEY, key: *mut dh_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut ec_key_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn d2i_PublicKey(
        type_: ::std::os::raw::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PublicKey(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey(
        type_: ::std::os::raw::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PrivateKey(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(
        to: *mut EVP_PKEY,
        from: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_save_parameters(
        pkey: *mut EVP_PKEY,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_default_digest_nid(
        pkey: *mut EVP_PKEY,
        pnid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_type(ctx: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_param_to_asn1(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_asn1_to_param(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_set_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        keylen: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        digest: *const EVP_MD,
        keylen: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_v2_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_add();
}
extern "C" {
    pub fn EVP_PBE_CipherInit(
        pbe_obj: *mut ASN1_OBJECT,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        ctx: *mut EVP_CIPHER_CTX,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add_type(
        pbe_type: ::std::os::raw::c_int,
        pbe_nid: ::std::os::raw::c_int,
        cipher_nid: ::std::os::raw::c_int,
        md_nid: ::std::os::raw::c_int,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add(
        nid: ::std::os::raw::c_int,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_find(
        type_: ::std::os::raw::c_int,
        pbe_nid: ::std::os::raw::c_int,
        pcnid: *mut ::std::os::raw::c_int,
        pmnid: *mut ::std::os::raw::c_int,
        pkeygen: *mut EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_cleanup();
}
extern "C" {
    pub fn EVP_PKEY_asn1_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0(idx: ::std::os::raw::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find(
        pe: *mut *mut ENGINE,
        type_: ::std::os::raw::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find_str(
        pe: *mut *mut ENGINE,
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add0(ameth: *const EVP_PKEY_ASN1_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add_alias(
        to: ::std::os::raw::c_int,
        from: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0_info(
        ppkey_id: *mut ::std::os::raw::c_int,
        pkey_base_id: *mut ::std::os::raw::c_int,
        ppkey_flags: *mut ::std::os::raw::c_int,
        pinfo: *mut *const ::std::os::raw::c_char,
        ppem_str: *mut *const ::std::os::raw::c_char,
        ameth: *const EVP_PKEY_ASN1_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_asn1(pkey: *mut EVP_PKEY) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_new(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        pem_str: *const ::std::os::raw::c_char,
        info: *const ::std::os::raw::c_char,
    ) -> *mut EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_copy(dst: *mut EVP_PKEY_ASN1_METHOD, src: *const EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_free(ameth: *mut EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pub_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                pub_: *mut X509_PUBKEY,
            ) -> ::std::os::raw::c_int,
        >,
        pub_encode: ::std::option::Option<
            unsafe extern "C" fn(
                pub_: *mut X509_PUBKEY,
                pk: *const EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        pub_cmp: ::std::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        pub_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
        pkey_size: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        pkey_bits: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_private(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        priv_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                p8inf: *mut PKCS8_PRIV_KEY_INFO,
            ) -> ::std::os::raw::c_int,
        >,
        priv_encode: ::std::option::Option<
            unsafe extern "C" fn(
                p8: *mut PKCS8_PRIV_KEY_INFO,
                pk: *const EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        priv_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        param_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                pder: *mut *const ::std::os::raw::c_uchar,
                derlen: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        param_encode: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *const EVP_PKEY,
                pder: *mut *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_int,
        >,
        param_missing: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_copy: ::std::option::Option<
            unsafe extern "C" fn(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_cmp: ::std::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_free(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_free: ::std::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_ctrl(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                op: ::std::os::raw::c_int,
                arg1: ::std::os::raw::c_long,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_item(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        item_verify: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut ::std::os::raw::c_void,
                a: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        item_sign: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut ::std::os::raw::c_void,
                alg1: *mut X509_ALGOR,
                alg2: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_find(type_: ::std::os::raw::c_int) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_new(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0_info(
        ppkey_id: *mut ::std::os::raw::c_int,
        pflags: *mut ::std::os::raw::c_int,
        meth: *const EVP_PKEY_METHOD,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_copy(dst: *mut EVP_PKEY_METHOD, src: *const EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_free(pmeth: *mut EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_add0(pmeth: *const EVP_PKEY_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: ::std::os::raw::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        keytype: ::std::os::raw::c_int,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_str(
        ctx: *mut EVP_PKEY_CTX,
        type_: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_operation(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        dat: *mut ::std::os::raw::c_int,
        datlen: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_PKEY_new_mac_key(
        type_: ::std::os::raw::c_int,
        e: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        keylen: ::std::os::raw::c_int,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_data(ctx: *mut EVP_PKEY_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_peerkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_app_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_app_data(ctx: *mut EVP_PKEY_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut usize,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const ::std::os::raw::c_uchar,
        siglen: usize,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        rout: *mut ::std::os::raw::c_uchar,
        routlen: *mut usize,
        sig: *const ::std::os::raw::c_uchar,
        siglen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut usize,
        in_: *const ::std::os::raw::c_uchar,
        inlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut usize,
        in_: *const ::std::os::raw::c_uchar,
        inlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut ::std::os::raw::c_uchar,
        keylen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub type EVP_PKEY_gen_cb =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_cb(ctx: *mut EVP_PKEY_CTX, cb: EVP_PKEY_gen_cb);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_cb(ctx: *mut EVP_PKEY_CTX) -> EVP_PKEY_gen_cb;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_set_init(
        pmeth: *mut EVP_PKEY_METHOD,
        init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_copy(
        pmeth: *mut EVP_PKEY_METHOD,
        copy: ::std::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_cleanup(
        pmeth: *mut EVP_PKEY_METHOD,
        cleanup: ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_paramgen(
        pmeth: *mut EVP_PKEY_METHOD,
        paramgen_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        paramgen: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_keygen(
        pmeth: *mut EVP_PKEY_METHOD,
        keygen_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_sign(
        pmeth: *mut EVP_PKEY_METHOD,
        sign_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        sign: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        verify: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify_recover(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_recover_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        verify_recover: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_signctx(
        pmeth: *mut EVP_PKEY_METHOD,
        signctx_init: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        signctx: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verifyctx(
        pmeth: *mut EVP_PKEY_METHOD,
        verifyctx_init: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        verifyctx: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: ::std::os::raw::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_encrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        encrypt_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        encryptfn: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut usize,
                in_: *const ::std::os::raw::c_uchar,
                inlen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_decrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        decrypt_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        decrypt: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut usize,
                in_: *const ::std::os::raw::c_uchar,
                inlen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_derive(
        pmeth: *mut EVP_PKEY_METHOD,
        derive_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        derive: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::std::os::raw::c_uchar,
                keylen: *mut usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_ctrl(
        pmeth: *mut EVP_PKEY_METHOD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::std::os::raw::c_int,
                p1: ::std::os::raw::c_int,
                p2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        ctrl_str: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_init(
        pmeth: *mut EVP_PKEY_METHOD,
        pinit: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_copy(
        pmeth: *mut EVP_PKEY_METHOD,
        pcopy: *mut ::std::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_cleanup(
        pmeth: *mut EVP_PKEY_METHOD,
        pcleanup: *mut ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_paramgen(
        pmeth: *mut EVP_PKEY_METHOD,
        pparamgen_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pparamgen: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_keygen(
        pmeth: *mut EVP_PKEY_METHOD,
        pkeygen_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pkeygen: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_sign(
        pmeth: *mut EVP_PKEY_METHOD,
        psign_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        psign: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify(
        pmeth: *mut EVP_PKEY_METHOD,
        pverify_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pverify: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify_recover(
        pmeth: *mut EVP_PKEY_METHOD,
        pverify_recover_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pverify_recover: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_signctx(
        pmeth: *mut EVP_PKEY_METHOD,
        psignctx_init: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        psignctx: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut usize,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verifyctx(
        pmeth: *mut EVP_PKEY_METHOD,
        pverifyctx_init: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        pverifyctx: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: ::std::os::raw::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_encrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        pencrypt_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pencryptfn: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut usize,
                in_: *const ::std::os::raw::c_uchar,
                inlen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_decrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        pdecrypt_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pdecrypt: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut usize,
                in_: *const ::std::os::raw::c_uchar,
                inlen: usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_derive(
        pmeth: *mut EVP_PKEY_METHOD,
        pderive_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pderive: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::std::os::raw::c_uchar,
                keylen: *mut usize,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_ctrl(
        pmeth: *mut EVP_PKEY_METHOD,
        pctrl: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::std::os::raw::c_int,
                p1: ::std::os::raw::c_int,
                p2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pctrl_str: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_add_alg_module();
}
extern "C" {
    pub fn ERR_load_EVP_strings();
}
#[doc = " the point is encoded as z||x, where the octet z specifies"]
#[doc = "  which solution of the quadratic equation y is"]
pub const point_conversion_form_t_POINT_CONVERSION_COMPRESSED: point_conversion_form_t = 2;
#[doc = " the point is encoded as z||x||y, where z is the octet 0x04"]
pub const point_conversion_form_t_POINT_CONVERSION_UNCOMPRESSED: point_conversion_form_t = 4;
#[doc = " the point is encoded as z||x||y, where the octet z specifies"]
#[doc = "  which solution of the quadratic equation y is"]
pub const point_conversion_form_t_POINT_CONVERSION_HYBRID: point_conversion_form_t = 6;
#[doc = " Enum for the point conversion form as defined in X9.62 (ECDSA)"]
#[doc = "  for the encoding of a elliptic curve point (x,y)"]
pub type point_conversion_form_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
extern "C" {
    #[doc = " Returns the basic GFp ec methods which provides the basis for the"]
    #[doc = "  optimized methods."]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_simple_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns GFp methods using montgomery multiplication."]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_mont_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns GFp methods using optimized methods for NIST recommended curves"]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_nist_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns the basic GF2m ec method"]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GF2m_simple_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object"]
    #[doc = "  \\param   meth  EC_METHOD to use"]
    #[doc = "  \\return  newly created EC_GROUP object or NULL in case of an error."]
    pub fn EC_GROUP_new(meth: *const EC_METHOD) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Frees a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object to be freed."]
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    #[doc = " Clears and frees a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object to be cleared and freed."]
    pub fn EC_GROUP_clear_free(group: *mut EC_GROUP);
}
extern "C" {
    #[doc = " Copies EC_GROUP objects. Note: both EC_GROUPs must use the same EC_METHOD."]
    #[doc = "  \\param  dst  destination EC_GROUP object"]
    #[doc = "  \\param  src  source EC_GROUP object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_GROUP_copy(dst: *mut EC_GROUP, src: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object and copies the copies the content"]
    #[doc = "  form src to the newly created EC_KEY object"]
    #[doc = "  \\param  src  source EC_GROUP object"]
    #[doc = "  \\return newly created EC_GROUP object or NULL in case of an error."]
    pub fn EC_GROUP_dup(src: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Returns the EC_METHOD of the EC_GROUP object."]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return EC_METHOD used in this EC_GROUP object."]
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns the field type of the EC_METHOD."]
    #[doc = "  \\param  meth  EC_METHOD object"]
    #[doc = "  \\return NID of the underlying field type OID."]
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the generator and it\'s order/cofactor of a EC_GROUP object."]
    #[doc = "  \\param  group      EC_GROUP object"]
    #[doc = "  \\param  generator  EC_POINT object with the generator."]
    #[doc = "  \\param  order      the order of the group generated by the generator."]
    #[doc = "  \\param  cofactor   the index of the sub-group generated by the generator"]
    #[doc = "                     in the group of all points on the elliptic curve."]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the generator of a EC_GROUP object."]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the currently used generator (possibly NULL)."]
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    #[doc = " Returns the montgomery data for order(Generator)"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the currently used generator (possibly NULL)."]
    pub fn EC_GROUP_get_mont_data(group: *const EC_GROUP) -> *mut BN_MONT_CTX;
}
extern "C" {
    #[doc = " Gets the order of a EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  order  BIGNUM to which the order is copied"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_get_order(
        group: *const EC_GROUP,
        order: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the cofactor of a EC_GROUP"]
    #[doc = "  \\param  group     EC_GROUP object"]
    #[doc = "  \\param  cofactor  BIGNUM to which the cofactor is copied"]
    #[doc = "  \\param  ctx       BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the name of a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  nid    NID of the curve name OID"]
    pub fn EC_GROUP_set_curve_name(group: *mut EC_GROUP, nid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns the curve name of a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return NID of the curve name OID or 0 if not set."]
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
extern "C" {
    pub fn EC_GROUP_get_point_conversion_form(arg1: *const EC_GROUP) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_GROUP_get0_seed(x: *const EC_GROUP) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EC_GROUP_get_seed_len(arg1: *const EC_GROUP) -> usize;
}
extern "C" {
    pub fn EC_GROUP_set_seed(
        arg1: *mut EC_GROUP,
        arg2: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Sets the parameter of a ec over GFp defined by y^2 = x^3 + a*x + b"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM with the prime number"]
    #[doc = "  \\param  a      BIGNUM with parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM with parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_set_curve_GFp(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the parameter of the ec over GFp defined by y^2 = x^3 + a*x + b"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM for the prime number"]
    #[doc = "  \\param  a      BIGNUM for parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM for parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the parameter of a ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM with the polynomial defining the underlying field"]
    #[doc = "  \\param  a      BIGNUM with parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM with parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_set_curve_GF2m(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the parameter of the ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM for the polynomial defining the underlying field"]
    #[doc = "  \\param  a      BIGNUM for parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM for parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_get_curve_GF2m(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of bits needed to represent a field element"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return number of bits needed to represent a field element"]
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the parameter in the EC_GROUP define a valid ec group"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if group is a valid ec group and 0 otherwise"]
    pub fn EC_GROUP_check(group: *const EC_GROUP, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the discriminant of the elliptic curve is zero or not"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if the discriminant is not zero and 0 otherwise"]
    pub fn EC_GROUP_check_discriminant(
        group: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two EC_GROUP objects"]
    #[doc = "  \\param  a    first EC_GROUP object"]
    #[doc = "  \\param  b    second EC_GROUP object"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return 0 if both groups are equal and 1 otherwise"]
    pub fn EC_GROUP_cmp(
        a: *const EC_GROUP,
        b: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object with the specified parameters defined"]
    #[doc = "  over GFp (defined by the equation y^2 = x^3 + a*x + b)"]
    #[doc = "  \\param  p    BIGNUM with the prime number"]
    #[doc = "  \\param  a    BIGNUM with the parameter a of the equation"]
    #[doc = "  \\param  b    BIGNUM with the parameter b of the equation"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return newly created EC_GROUP object with the specified parameters"]
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object with the specified parameters defined"]
    #[doc = "  over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)"]
    #[doc = "  \\param  p    BIGNUM with the polynomial defining the underlying field"]
    #[doc = "  \\param  a    BIGNUM with the parameter a of the equation"]
    #[doc = "  \\param  b    BIGNUM with the parameter b of the equation"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return newly created EC_GROUP object with the specified parameters"]
    pub fn EC_GROUP_new_curve_GF2m(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates a EC_GROUP object with a curve specified by a NID"]
    #[doc = "  \\param  nid  NID of the OID of the curve name"]
    #[doc = "  \\return newly created EC_GROUP object with specified curve or NULL"]
    #[doc = "          if an error occurred"]
    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: ::std::os::raw::c_int,
    pub comment: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EC_builtin_curve() {
    assert_eq!(
        ::std::mem::size_of::<EC_builtin_curve>(),
        16usize,
        concat!("Size of: ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        ::std::mem::align_of::<EC_builtin_curve>(),
        8usize,
        concat!("Alignment of ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).comment as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(comment)
        )
    );
}
extern "C" {
    pub fn EC_get_builtin_curves(r: *mut EC_builtin_curve, nitems: usize) -> usize;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_POINT object for the specified EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP the underlying EC_GROUP object"]
    #[doc = "  \\return newly created EC_POINT object or NULL if an error occurred"]
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Frees a EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object to be freed"]
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    #[doc = " Clears and frees a EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object to be cleared and freed"]
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    #[doc = " Copies EC_POINT object"]
    #[doc = "  \\param  dst  destination EC_POINT object"]
    #[doc = "  \\param  src  source EC_POINT object"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_copy(dst: *mut EC_POINT, src: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_POINT object and copies the content of the supplied"]
    #[doc = "  EC_POINT"]
    #[doc = "  \\param  src    source EC_POINT object"]
    #[doc = "  \\param  group  underlying the EC_GROUP object"]
    #[doc = "  \\return newly created EC_POINT object or NULL if an error occurred"]
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Returns the EC_METHOD used in EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object"]
    #[doc = "  \\return the EC_METHOD used"]
    pub fn EC_POINT_method_of(point: *const EC_POINT) -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Sets a point to infinity (neutral element)"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  point  EC_POINT to set to infinity"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_to_infinity(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the jacobian projective coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM with the y-coordinate"]
    #[doc = "  \\param  z      BIGNUM with the z-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        z: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the jacobian projective coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM for the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM for the y-coordinate"]
    #[doc = "  \\param  z      BIGNUM for the z-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_get_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        z: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the affine coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM with the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the affine coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM for the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM for the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the x9.62 compressed coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with x-coordinate"]
    #[doc = "  \\param  y_bit  integer with the y-Bit (either 0 or 1)"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the affine coordinates of a EC_POINT over GF2m"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM with the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the affine coordinates of a EC_POINT over GF2m"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM for the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM for the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_get_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the x9.62 compressed coordinates of a EC_POINT over GF2m"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with x-coordinate"]
    #[doc = "  \\param  y_bit  integer with the y-Bit (either 0 or 1)"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_set_compressed_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a EC_POINT object to a octet string"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  form   point conversion form"]
    #[doc = "  \\param  buf    memory buffer for the result. If NULL the function returns"]
    #[doc = "                 required buffer size."]
    #[doc = "  \\param  len    length of the memory buffer"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut ::std::os::raw::c_uchar,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    #[doc = " Decodes a EC_POINT from a octet string"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  buf    memory buffer with the encoded ec point"]
    #[doc = "  \\param  len    length of the encoded ec point"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        buf: *const ::std::os::raw::c_uchar,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_point2bn(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BIGNUM,
        arg4: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn EC_POINT_bn2point(
        arg1: *const EC_GROUP,
        arg2: *const BIGNUM,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_point2hex(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BN_CTX,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_POINT_hex2point(
        arg1: *const EC_GROUP,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Computes the sum of two EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result (r = a + b)"]
    #[doc = "  \\param  a      EC_POINT object with the first summand"]
    #[doc = "  \\param  b      EC_POINT object with the second summand"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the double of a EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result (r = 2 * a)"]
    #[doc = "  \\param  a      EC_POINT object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the inverse of a EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  a      EC_POINT object to be inverted (it\'s used for the result as well)"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_invert(
        group: *const EC_GROUP,
        a: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the point is the neutral element of the group"]
    #[doc = "  \\param  group  the underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\return 1 if the point is the neutral element and 0 otherwise"]
    pub fn EC_POINT_is_at_infinity(
        group: *const EC_GROUP,
        p: *const EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the point is on the curve"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  point  EC_POINT object to check"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if point if on the curve and 0 otherwise"]
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two EC_POINTs"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  a      first EC_POINT object"]
    #[doc = "  \\param  b      second EC_POINT object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 0 if both points are equal and a value != 0 otherwise"]
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_make_affine(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINTs_make_affine(
        group: *const EC_GROUP,
        num: usize,
        points: *mut *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes r = generator * n sum_{i=0}^{num-1} p[i] * m[i]"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result"]
    #[doc = "  \\param  n      BIGNUM with the multiplier for the group generator (optional)"]
    #[doc = "  \\param  num    number futher summands"]
    #[doc = "  \\param  p      array of size num of EC_POINT objects"]
    #[doc = "  \\param  m      array of size num of BIGNUM objects"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINTs_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        num: usize,
        p: *mut *const EC_POINT,
        m: *mut *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes r = generator * n + q * m"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result"]
    #[doc = "  \\param  n      BIGNUM with the multiplier for the group generator (optional)"]
    #[doc = "  \\param  q      EC_POINT object with the first factor of the second summand"]
    #[doc = "  \\param  m      BIGNUM with the second factor of the second summand"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stores multiples of generator for faster point multiplication"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occured"]
    pub fn EC_GROUP_precompute_mult(
        group: *mut EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reports whether a precomputation has been done"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return 1 if a pre-computation has been done and 0 otherwise"]
    pub fn EC_GROUP_have_precompute_mult(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_basis_type(arg1: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_trinomial_basis(
        arg1: *const EC_GROUP,
        k: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_pentanomial_basis(
        arg1: *const EC_GROUP,
        k1: *mut ::std::os::raw::c_uint,
        k2: *mut ::std::os::raw::c_uint,
        k3: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecpk_parameters_st {
    _unused: [u8; 0],
}
pub type ECPKPARAMETERS = ecpk_parameters_st;
extern "C" {
    pub fn d2i_ECPKParameters(
        arg1: *mut *mut EC_GROUP,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn i2d_ECPKParameters(
        arg1: *const EC_GROUP,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECPKParameters_print(
        bp: *mut BIO,
        x: *const EC_GROUP,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECPKParameters_print_fp(
        fp: *mut FILE,
        x: *const EC_GROUP,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type EC_KEY = ec_key_st;
extern "C" {
    #[doc = " Creates a new EC_KEY object."]
    #[doc = "  \\return EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_get_flags(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_KEY_clear_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Creates a new EC_KEY object using a named curve as underlying"]
    #[doc = "  EC_GROUP object."]
    #[doc = "  \\param  nid  NID of the named curve."]
    #[doc = "  \\return EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Frees a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object to be freed."]
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    #[doc = " Copies a EC_KEY object."]
    #[doc = "  \\param  dst  destination EC_KEY object"]
    #[doc = "  \\param  src  src EC_KEY object"]
    #[doc = "  \\return dst or NULL if an error occurred."]
    pub fn EC_KEY_copy(dst: *mut EC_KEY, src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Creates a new EC_KEY object and copies the content from src to it."]
    #[doc = "  \\param  src  the source EC_KEY object"]
    #[doc = "  \\return newly created EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Increases the internal reference count of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the EC_GROUP object of a EC_KEY object"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return the EC_GROUP object (possibly NULL)."]
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    #[doc = " Sets the EC_GROUP of a EC_KEY object."]
    #[doc = "  \\param  key    EC_KEY object"]
    #[doc = "  \\param  group  EC_GROUP to use in the EC_KEY object (note: the EC_KEY"]
    #[doc = "                 object will use an own copy of the EC_GROUP)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the private key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return a BIGNUM with the private key (possibly NULL)."]
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Sets the private key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  prv  BIGNUM with the private key (note: the EC_KEY object"]
    #[doc = "               will use an own copy of the BIGNUM)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, prv: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the public key of a EC_KEY object."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\return a EC_POINT object with the public key (possibly NULL)"]
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    #[doc = " Sets the public key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  pub  EC_POINT object with the public key (note: the EC_KEY object"]
    #[doc = "               will use an own copy of the EC_POINT object)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(eckey: *mut EC_KEY, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(eckey: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_get_key_method_data(
        key: *mut EC_KEY,
        dup_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        clear_free_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the key method data of an EC_KEY object, if none has yet been set."]
    #[doc = "  \\param  key              EC_KEY object"]
    #[doc = "  \\param  data             opaque data to install."]
    #[doc = "  \\param  dup_func         a function that duplicates |data|."]
    #[doc = "  \\param  free_func        a function that frees |data|."]
    #[doc = "  \\param  clear_free_func  a function that wipes and frees |data|."]
    #[doc = "  \\return the previously set data pointer, or NULL if |data| was inserted."]
    pub fn EC_KEY_insert_key_method_data(
        key: *mut EC_KEY,
        data: *mut ::std::os::raw::c_void,
        dup_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        free_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        clear_free_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(eckey: *mut EC_KEY, asn1_flag: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Creates a table of pre-computed multiples of the generator to"]
    #[doc = "  accelerate further EC_KEY operations."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_precompute_mult(key: *mut EC_KEY, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new ec private (and optional a new public) key."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies that a private and/or public key is valid."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 otherwise."]
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets a public key from affine coordindates performing"]
    #[doc = "  neccessary NIST PKV tests."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\param  x    public key x coordinate"]
    #[doc = "  \\param  y    public key y coordinate"]
    #[doc = "  \\return 1 on success and 0 otherwise."]
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a private key from a memory buffer."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)"]
    #[doc = "  \\param  in   pointer to memory with the DER encoded private key"]
    #[doc = "  \\param  len  length of the DER encoded private key"]
    #[doc = "  \\return the decoded private key or NULL if an error occurred."]
    pub fn d2i_ECPrivateKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes a private key object and stores the result in a buffer."]
    #[doc = "  \\param  key  the EC_KEY object to encode"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn i2d_ECPrivateKey(
        key: *mut EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes ec parameter from a memory buffer."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)"]
    #[doc = "  \\param  in   pointer to memory with the DER encoded ec parameters"]
    #[doc = "  \\param  len  length of the DER encoded ec parameters"]
    #[doc = "  \\return a EC_KEY object with the decoded parameters or NULL if an error"]
    #[doc = "          occurred."]
    pub fn d2i_ECParameters(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes ec parameter and stores the result in a buffer."]
    #[doc = "  \\param  key  the EC_KEY object with ec paramters to encode"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn i2d_ECParameters(
        key: *mut EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a ec public key from a octet string."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used"]
    #[doc = "  \\param  in   memory buffer with the encoded public key"]
    #[doc = "  \\param  len  length of the encoded public key"]
    #[doc = "  \\return EC_KEY object with decoded public key or NULL if an error"]
    #[doc = "          occurred."]
    pub fn o2i_ECPublicKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes a ec public key in an octet string."]
    #[doc = "  \\param  key  the EC_KEY object with the public key"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn i2o_ECPublicKey(
        key: *mut EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the ec parameters on human readable form."]
    #[doc = "  \\param  bp   BIO object to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn ECParameters_print(bp: *mut BIO, key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the contents of a EC_KEY object"]
    #[doc = "  \\param  bp   BIO object to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  off  line offset"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_print(
        bp: *mut BIO,
        key: *const EC_KEY,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the ec parameters on human readable form."]
    #[doc = "  \\param  fp   file descriptor to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn ECParameters_print_fp(fp: *mut FILE, key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the contents of a EC_KEY object"]
    #[doc = "  \\param  fp   file descriptor to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  off  line offset"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_print_fp(
        fp: *mut FILE,
        key: *const EC_KEY,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_EC_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ECDSA_SIG_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_ECDSA_SIG_st() {
    assert_eq!(
        ::std::mem::size_of::<ECDSA_SIG_st>(),
        16usize,
        concat!("Size of: ", stringify!(ECDSA_SIG_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ECDSA_SIG_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ECDSA_SIG_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ECDSA_SIG_st>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ECDSA_SIG_st),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ECDSA_SIG_st>())).s as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ECDSA_SIG_st),
            "::",
            stringify!(s)
        )
    );
}
pub type ECDSA_SIG = ECDSA_SIG_st;
extern "C" {
    #[doc = " Allocates and initialize a ECDSA_SIG structure"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " frees a ECDSA_SIG structure"]
    #[doc = "  \\param  sig  pointer to the ECDSA_SIG structure"]
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    #[doc = " DER encode content of ECDSA_SIG object (note: this function modifies *pp"]
    #[doc = "  (*pp += length of the DER encoded signature))."]
    #[doc = "  \\param  sig  pointer to the ECDSA_SIG object"]
    #[doc = "  \\param  pp   pointer to a unsigned char pointer for the output or NULL"]
    #[doc = "  \\return the length of the DER encoded ECDSA_SIG object or 0"]
    pub fn i2d_ECDSA_SIG(
        sig: *const ECDSA_SIG,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a DER encoded ECDSA signature (note: this function changes *pp"]
    #[doc = "  (*pp += len))."]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG pointer (may be NULL)"]
    #[doc = "  \\param  pp   memory buffer with the DER encoded signature"]
    #[doc = "  \\param  len  length of the buffer"]
    #[doc = "  \\return pointer to the decoded ECDSA_SIG structure (or NULL)"]
    pub fn d2i_ECDSA_SIG(
        sig: *mut *mut ECDSA_SIG,
        pp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Computes the ECDSA signature of the given hash value using"]
    #[doc = "  the supplied private key and returns the created signature."]
    #[doc = "  \\param  dgst      pointer to the hash value"]
    #[doc = "  \\param  dgst_len  length of the hash value"]
    #[doc = "  \\param  eckey     EC_KEY object containing a private EC key"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_do_sign(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)"]
    #[doc = "  \\param  rp       BIGNUM with a pre-computed rp value (optioanl),"]
    #[doc = "                   see ECDSA_sign_setup"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_do_sign_ex(
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Verifies that the supplied signature is a valid ECDSA"]
    #[doc = "  signature of the supplied hash value using the supplied public key."]
    #[doc = "  \\param  dgst      pointer to the hash value"]
    #[doc = "  \\param  dgst_len  length of the hash value"]
    #[doc = "  \\param  sig       ECDSA_SIG structure"]
    #[doc = "  \\param  eckey     EC_KEY object containing a public EC key"]
    #[doc = "  \\return 1 if the signature is valid, 0 if the signature is invalid"]
    #[doc = "          and -1 on error"]
    pub fn ECDSA_do_verify(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sig: *const ECDSA_SIG,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_OpenSSL() -> *const ECDSA_METHOD;
}
extern "C" {
    #[doc = " Sets the default ECDSA method"]
    #[doc = "  \\param  meth  new default ECDSA_METHOD"]
    pub fn ECDSA_set_default_method(meth: *const ECDSA_METHOD);
}
extern "C" {
    #[doc = " Returns the default ECDSA method"]
    #[doc = "  \\return pointer to ECDSA_METHOD structure containing the default method"]
    pub fn ECDSA_get_default_method() -> *const ECDSA_METHOD;
}
extern "C" {
    #[doc = " Sets method to be used for the ECDSA operations"]
    #[doc = "  \\param  eckey  EC_KEY object"]
    #[doc = "  \\param  meth   new method"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_set_method(eckey: *mut EC_KEY, meth: *const ECDSA_METHOD)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the maximum length of the DER encoded signature"]
    #[doc = "  \\param  eckey  EC_KEY object"]
    #[doc = "  \\return numbers of bytes required for the DER encoded signature"]
    pub fn ECDSA_size(eckey: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Precompute parts of the signing operation"]
    #[doc = "  \\param  eckey  EC_KEY object containing a private EC key"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\param  kinv   BIGNUM pointer for the inverse of k"]
    #[doc = "  \\param  rp     BIGNUM pointer for x coordinate of k * generator"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign_setup(
        eckey: *mut EC_KEY,
        ctx: *mut BN_CTX,
        kinv: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      memory for the DER encoded created signature"]
    #[doc = "  \\param  siglen   pointer to the length of the returned signature"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      buffer to hold the DER encoded signature"]
    #[doc = "  \\param  siglen   pointer to the length of the returned signature"]
    #[doc = "  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)"]
    #[doc = "  \\param  rp       BIGNUM with a pre-computed rp value (optioanl),"]
    #[doc = "                   see ECDSA_sign_setup"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign_ex(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies that the given signature is valid ECDSA signature"]
    #[doc = "  of the supplied hash value using the specified public key."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      pointer to the DER encoded signature"]
    #[doc = "  \\param  siglen   length of the DER encoded signature"]
    #[doc = "  \\param  eckey    EC_KEY object containing a public EC key"]
    #[doc = "  \\return 1 if the signature is valid, 0 if the signature is invalid"]
    #[doc = "          and -1 on error"]
    pub fn ECDSA_verify(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_int,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_set_ex_data(
        d: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_get_ex_data(
        d: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocates and initialize a ECDSA_METHOD structure"]
    #[doc = "  \\param ecdsa_method pointer to ECDSA_METHOD to copy.  (May be NULL)"]
    #[doc = "  \\return pointer to a ECDSA_METHOD structure or NULL if an error occurred"]
    pub fn ECDSA_METHOD_new(ecdsa_method: *const ECDSA_METHOD) -> *mut ECDSA_METHOD;
}
extern "C" {
    #[doc = " frees a ECDSA_METHOD structure"]
    #[doc = "  \\param  ecdsa_method  pointer to the ECDSA_METHOD structure"]
    pub fn ECDSA_METHOD_free(ecdsa_method: *mut ECDSA_METHOD);
}
extern "C" {
    #[doc = "  Sets application specific data in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  app application specific data to set"]
    pub fn ECDSA_METHOD_set_app_data(
        ecdsa_method: *mut ECDSA_METHOD,
        app: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns application specific data from a ECDSA_METHOD structure"]
    #[doc = "  \\param ecdsa_method pointer to ECDSA_METHOD structure"]
    #[doc = "  \\return pointer to application specific data."]
    pub fn ECDSA_METHOD_get_app_data(
        ecdsa_method: *mut ECDSA_METHOD,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Set the ECDSA_do_sign function in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method  pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_do_sign a funtion of type ECDSA_do_sign"]
    pub fn ECDSA_METHOD_set_sign(
        ecdsa_method: *mut ECDSA_METHOD,
        ecdsa_do_sign: ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                inv: *const BIGNUM,
                rp: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    #[doc = "  Set the  ECDSA_sign_setup function in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method  pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_sign_setup a funtion of type ECDSA_sign_setup"]
    pub fn ECDSA_METHOD_set_sign_setup(
        ecdsa_method: *mut ECDSA_METHOD,
        ecdsa_sign_setup: ::std::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx: *mut BN_CTX,
                kinv: *mut *mut BIGNUM,
                r: *mut *mut BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = "  Set the ECDSA_do_verify function in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method  pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_do_verify a funtion of type ECDSA_do_verify"]
    pub fn ECDSA_METHOD_set_verify(
        ecdsa_method: *mut ECDSA_METHOD,
        ecdsa_do_verify: ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn ECDSA_METHOD_set_flags(ecdsa_method: *mut ECDSA_METHOD, flags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  Set the flags field in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method  pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  flags flags value to set"]
    pub fn ECDSA_METHOD_set_name(
        ecdsa_method: *mut ECDSA_METHOD,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  Set the name field in the ECDSA_METHOD"]
    #[doc = "   \\param  ecdsa_method  pointer to existing ECDSA_METHOD"]
    #[doc = "   \\param  name name to set"]
    pub fn ERR_load_ECDSA_strings();
}
extern "C" {
    pub fn ECDH_OpenSSL() -> *const ECDH_METHOD;
}
extern "C" {
    pub fn ECDH_set_default_method(arg1: *const ECDH_METHOD);
}
extern "C" {
    pub fn ECDH_get_default_method() -> *const ECDH_METHOD;
}
extern "C" {
    pub fn ECDH_set_method(arg1: *mut EC_KEY, arg2: *const ECDH_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut ::std::os::raw::c_void,
        outlen: usize,
        pub_key: *const EC_POINT,
        ecdh: *mut EC_KEY,
        KDF: ::std::option::Option<
            unsafe extern "C" fn(
                in_: *const ::std::os::raw::c_void,
                inlen: usize,
                out: *mut ::std::os::raw::c_void,
                outlen: *mut usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_set_ex_data(
        d: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_get_ex_data(
        d: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ECDH_KDF_X9_62(
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
        Z: *const ::std::os::raw::c_uchar,
        Zlen: usize,
        sinfo: *const ::std::os::raw::c_uchar,
        sinfolen: usize,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_ECDH_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    pub name: *const ::std::os::raw::c_char,
    pub rsa_pub_enc: ::std::option::Option<
        unsafe extern "C" fn(
            flen: ::std::os::raw::c_int,
            from: *const ::std::os::raw::c_uchar,
            to: *mut ::std::os::raw::c_uchar,
            rsa: *mut RSA,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_pub_dec: ::std::option::Option<
        unsafe extern "C" fn(
            flen: ::std::os::raw::c_int,
            from: *const ::std::os::raw::c_uchar,
            to: *mut ::std::os::raw::c_uchar,
            rsa: *mut RSA,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_priv_enc: ::std::option::Option<
        unsafe extern "C" fn(
            flen: ::std::os::raw::c_int,
            from: *const ::std::os::raw::c_uchar,
            to: *mut ::std::os::raw::c_uchar,
            rsa: *mut RSA,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_priv_dec: ::std::option::Option<
        unsafe extern "C" fn(
            flen: ::std::os::raw::c_int,
            from: *const ::std::os::raw::c_uchar,
            to: *mut ::std::os::raw::c_uchar,
            rsa: *mut RSA,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_mod_exp: ::std::option::Option<
        unsafe extern "C" fn(
            r0: *mut BIGNUM,
            I: *const BIGNUM,
            rsa: *mut RSA,
            ctx: *mut BN_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub bn_mod_exp: ::std::option::Option<
        unsafe extern "C" fn(
            r: *mut BIGNUM,
            a: *const BIGNUM,
            p: *const BIGNUM,
            m: *const BIGNUM,
            ctx: *mut BN_CTX,
            m_ctx: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub init: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub flags: ::std::os::raw::c_int,
    pub app_data: *mut ::std::os::raw::c_char,
    pub rsa_sign: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            m: *const ::std::os::raw::c_uchar,
            m_length: ::std::os::raw::c_uint,
            sigret: *mut ::std::os::raw::c_uchar,
            siglen: *mut ::std::os::raw::c_uint,
            rsa: *const RSA,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_verify: ::std::option::Option<
        unsafe extern "C" fn(
            dtype: ::std::os::raw::c_int,
            m: *const ::std::os::raw::c_uchar,
            m_length: ::std::os::raw::c_uint,
            sigbuf: *const ::std::os::raw::c_uchar,
            siglen: ::std::os::raw::c_uint,
            rsa: *const RSA,
        ) -> ::std::os::raw::c_int,
    >,
    pub rsa_keygen: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            bits: ::std::os::raw::c_int,
            e: *mut BIGNUM,
            cb: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rsa_meth_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_meth_st>(),
        112usize,
        concat!("Size of: ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_meth_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_pub_enc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_pub_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_pub_dec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_pub_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_priv_enc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_priv_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_priv_dec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_priv_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_mod_exp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_mod_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).bn_mod_exp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(bn_mod_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).finish as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).app_data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_sign as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_verify as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_meth_st>())).rsa_keygen as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(rsa_keygen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    pub pad: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_long,
    pub meth: *const RSA_METHOD,
    pub engine: *mut ENGINE,
    pub n: *mut BIGNUM,
    pub e: *mut BIGNUM,
    pub d: *mut BIGNUM,
    pub p: *mut BIGNUM,
    pub q: *mut BIGNUM,
    pub dmp1: *mut BIGNUM,
    pub dmq1: *mut BIGNUM,
    pub iqmp: *mut BIGNUM,
    pub ex_data: CRYPTO_EX_DATA,
    pub references: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub _method_mod_n: *mut BN_MONT_CTX,
    pub _method_mod_p: *mut BN_MONT_CTX,
    pub _method_mod_q: *mut BN_MONT_CTX,
    pub bignum_data: *mut ::std::os::raw::c_char,
    pub blinding: *mut BN_BLINDING,
    pub mt_blinding: *mut BN_BLINDING,
}
#[test]
fn bindgen_test_layout_rsa_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_st>(),
        168usize,
        concat!("Size of: ", stringify!(rsa_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).meth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).engine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).n as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).e as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(e))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).d as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).p as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).q as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(rsa_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmp1 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(dmp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).dmq1 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(dmq1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).iqmp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(iqmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).ex_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).references as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>()))._method_mod_n as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(_method_mod_n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>()))._method_mod_p as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(_method_mod_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>()))._method_mod_q as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(_method_mod_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).bignum_data as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(bignum_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).blinding as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(blinding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_st>())).mt_blinding as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_st),
            "::",
            stringify!(mt_blinding)
        )
    );
}
extern "C" {
    pub fn RSA_new() -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_method(engine: *mut ENGINE) -> *mut RSA;
}
extern "C" {
    pub fn RSA_size(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key(
        bits: ::std::os::raw::c_int,
        e: ::std::os::raw::c_ulong,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_generate_key_ex(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        e: *mut BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_key(arg1: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_encrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_encrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_decrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_decrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_free(r: *mut RSA);
}
extern "C" {
    pub fn RSA_up_ref(r: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_flags(r: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_default_method(meth: *const RSA_METHOD);
}
extern "C" {
    pub fn RSA_get_default_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_get_method(rsa: *const RSA) -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_set_method(rsa: *mut RSA, meth: *const RSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_memory_lock(r: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_PKCS1_SSLeay() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_null_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn d2i_RSAPublicKey(
        a: *mut *mut RSA,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey(
        a: *const RSA,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}RSAPublicKey_it"]
    pub static RSAPublicKey_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_RSAPrivateKey(
        a: *mut *mut RSA,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey(
        a: *const RSA,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}RSAPrivateKey_it"]
    pub static RSAPrivateKey_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_pss_params_st {
    pub hashAlgorithm: *mut X509_ALGOR,
    pub maskGenAlgorithm: *mut X509_ALGOR,
    pub saltLength: *mut ASN1_INTEGER,
    pub trailerField: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_rsa_pss_params_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_pss_params_st>(),
        32usize,
        concat!("Size of: ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_pss_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).hashAlgorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(hashAlgorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rsa_pss_params_st>())).maskGenAlgorithm as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskGenAlgorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).saltLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(saltLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).trailerField as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(trailerField)
        )
    );
}
pub type RSA_PSS_PARAMS = rsa_pss_params_st;
extern "C" {
    pub fn RSA_PSS_PARAMS_new() -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_free(a: *mut RSA_PSS_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_PSS_PARAMS(
        a: *mut *mut RSA_PSS_PARAMS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_PSS_PARAMS(
        a: *mut RSA_PSS_PARAMS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}RSA_PSS_PARAMS_it"]
    pub static RSA_PSS_PARAMS_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_oaep_params_st {
    pub hashFunc: *mut X509_ALGOR,
    pub maskGenFunc: *mut X509_ALGOR,
    pub pSourceFunc: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_rsa_oaep_params_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_oaep_params_st>(),
        24usize,
        concat!("Size of: ", stringify!(rsa_oaep_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_oaep_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_oaep_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).hashFunc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(hashFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).maskGenFunc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(maskGenFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).pSourceFunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(pSourceFunc)
        )
    );
}
pub type RSA_OAEP_PARAMS = rsa_oaep_params_st;
extern "C" {
    pub fn RSA_OAEP_PARAMS_new() -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn RSA_OAEP_PARAMS_free(a: *mut RSA_OAEP_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_OAEP_PARAMS(
        a: *mut *mut RSA_OAEP_PARAMS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_OAEP_PARAMS(
        a: *mut RSA_OAEP_PARAMS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}RSA_OAEP_PARAMS_it"]
    pub static RSA_OAEP_PARAMS_it: ASN1_ITEM;
}
extern "C" {
    pub fn RSA_print_fp(
        fp: *mut FILE,
        r: *const RSA,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_print(
        bp: *mut BIO,
        r: *const RSA,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSA_NET(
        a: *const RSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *mut ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
                prompt: *const ::std::os::raw::c_char,
                verify: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        sgckey: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_NET(
        a: *mut *mut RSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *mut ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
                prompt: *const ::std::os::raw::c_char,
                verify: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        sgckey: ::std::os::raw::c_int,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_Netscape_RSA(
        a: *const RSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *mut ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
                prompt: *const ::std::os::raw::c_char,
                verify: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_Netscape_RSA(
        a: *mut *mut RSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                buf: *mut ::std::os::raw::c_char,
                len: ::std::os::raw::c_int,
                prompt: *const ::std::os::raw::c_char,
                verify: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_sign(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_ASN1_OCTET_STRING(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_ASN1_OCTET_STRING(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigbuf: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_on(rsa: *mut RSA, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_off(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_setup_blinding(rsa: *mut RSA, ctx: *mut BN_CTX) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_2(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_2(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS1_MGF1(
        mask: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        seed: *const ::std::os::raw::c_uchar,
        seedlen: ::std::os::raw::c_long,
        dgst: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_uchar,
        pl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_uchar,
        pl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP_mgf1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        flen: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_uchar,
        plen: ::std::os::raw::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP_mgf1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        flen: ::std::os::raw::c_int,
        num: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_uchar,
        plen: ::std::os::raw::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_SSLv23(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_SSLv23(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_none(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_none(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_X931(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_X931(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_X931_hash_id(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS(
        rsa: *mut RSA,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        EM: *const ::std::os::raw::c_uchar,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS(
        rsa: *mut RSA,
        EM: *mut ::std::os::raw::c_uchar,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        EM: *const ::std::os::raw::c_uchar,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        EM: *mut ::std::os::raw::c_uchar,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_ex_data(
        r: *mut RSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_data(
        r: *const RSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RSAPublicKey_dup(rsa: *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSAPrivateKey_dup(rsa: *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn ERR_load_RSA_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_method {
    pub name: *const ::std::os::raw::c_char,
    pub generate_key:
        ::std::option::Option<unsafe extern "C" fn(dh: *mut DH) -> ::std::os::raw::c_int>,
    pub compute_key: ::std::option::Option<
        unsafe extern "C" fn(
            key: *mut ::std::os::raw::c_uchar,
            pub_key: *const BIGNUM,
            dh: *mut DH,
        ) -> ::std::os::raw::c_int,
    >,
    pub bn_mod_exp: ::std::option::Option<
        unsafe extern "C" fn(
            dh: *const DH,
            r: *mut BIGNUM,
            a: *const BIGNUM,
            p: *const BIGNUM,
            m: *const BIGNUM,
            ctx: *mut BN_CTX,
            m_ctx: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub init: ::std::option::Option<unsafe extern "C" fn(dh: *mut DH) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(dh: *mut DH) -> ::std::os::raw::c_int>,
    pub flags: ::std::os::raw::c_int,
    pub app_data: *mut ::std::os::raw::c_char,
    pub generate_params: ::std::option::Option<
        unsafe extern "C" fn(
            dh: *mut DH,
            prime_len: ::std::os::raw::c_int,
            generator: ::std::os::raw::c_int,
            cb: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dh_method() {
    assert_eq!(
        ::std::mem::size_of::<dh_method>(),
        72usize,
        concat!("Size of: ", stringify!(dh_method))
    );
    assert_eq!(
        ::std::mem::align_of::<dh_method>(),
        8usize,
        concat!("Alignment of ", stringify!(dh_method))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).generate_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(generate_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).compute_key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(compute_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).bn_mod_exp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(bn_mod_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).finish as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).app_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_method>())).generate_params as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_method),
            "::",
            stringify!(generate_params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    pub pad: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub p: *mut BIGNUM,
    pub g: *mut BIGNUM,
    pub length: ::std::os::raw::c_long,
    pub pub_key: *mut BIGNUM,
    pub priv_key: *mut BIGNUM,
    pub flags: ::std::os::raw::c_int,
    pub method_mont_p: *mut BN_MONT_CTX,
    pub q: *mut BIGNUM,
    pub j: *mut BIGNUM,
    pub seed: *mut ::std::os::raw::c_uchar,
    pub seedlen: ::std::os::raw::c_int,
    pub counter: *mut BIGNUM,
    pub references: ::std::os::raw::c_int,
    pub ex_data: CRYPTO_EX_DATA,
    pub meth: *const DH_METHOD,
    pub engine: *mut ENGINE,
}
#[test]
fn bindgen_test_layout_dh_st() {
    assert_eq!(
        ::std::mem::size_of::<dh_st>(),
        144usize,
        concat!("Size of: ", stringify!(dh_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dh_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dh_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).p as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).g as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).pub_key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(pub_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).priv_key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(priv_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).method_mont_p as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(method_mont_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).q as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).j as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(dh_st), "::", stringify!(j))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).seed as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).seedlen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(seedlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).counter as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).references as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).ex_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).meth as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dh_st>())).engine as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dh_st),
            "::",
            stringify!(engine)
        )
    );
}
extern "C" {
    pub fn DHparams_dup(arg1: *mut DH) -> *mut DH;
}
extern "C" {
    pub fn DH_OpenSSL() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_default_method(meth: *const DH_METHOD);
}
extern "C" {
    pub fn DH_get_default_method() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_method(dh: *mut DH, meth: *const DH_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_new_method(engine: *mut ENGINE) -> *mut DH;
}
extern "C" {
    pub fn DH_new() -> *mut DH;
}
extern "C" {
    pub fn DH_free(dh: *mut DH);
}
extern "C" {
    pub fn DH_up_ref(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_size(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_set_ex_data(
        d: *mut DH,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_ex_data(d: *mut DH, idx: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DH_generate_parameters(
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn DH_generate_parameters_ex(
        dh: *mut DH,
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check(dh: *const DH, codes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_pub_key(
        dh: *const DH,
        pub_key: *const BIGNUM,
        codes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_key(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key(
        key: *mut ::std::os::raw::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_padded(
        key: *mut ::std::os::raw::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DHparams(
        a: *mut *mut DH,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHparams(
        a: *const DH,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DHxparams(
        a: *mut *mut DH,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHxparams(
        a: *const DH,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DHparams_print_fp(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DHparams_print(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_1024_160() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_224() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_256() -> *mut DH;
}
extern "C" {
    pub fn DH_KDF_X9_42(
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
        Z: *const ::std::os::raw::c_uchar,
        Zlen: usize,
        key_oid: *mut ASN1_OBJECT,
        ukm: *const ::std::os::raw::c_uchar,
        ukmlen: usize,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_DH_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DSA_SIG_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_DSA_SIG_st() {
    assert_eq!(
        ::std::mem::size_of::<DSA_SIG_st>(),
        16usize,
        concat!("Size of: ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DSA_SIG_st>(),
        8usize,
        concat!("Alignment of ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSA_SIG_st>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSA_SIG_st),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DSA_SIG_st>())).s as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DSA_SIG_st),
            "::",
            stringify!(s)
        )
    );
}
pub type DSA_SIG = DSA_SIG_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_method {
    pub name: *const ::std::os::raw::c_char,
    pub dsa_do_sign: ::std::option::Option<
        unsafe extern "C" fn(
            dgst: *const ::std::os::raw::c_uchar,
            dlen: ::std::os::raw::c_int,
            dsa: *mut DSA,
        ) -> *mut DSA_SIG,
    >,
    pub dsa_sign_setup: ::std::option::Option<
        unsafe extern "C" fn(
            dsa: *mut DSA,
            ctx_in: *mut BN_CTX,
            kinvp: *mut *mut BIGNUM,
            rp: *mut *mut BIGNUM,
        ) -> ::std::os::raw::c_int,
    >,
    pub dsa_do_verify: ::std::option::Option<
        unsafe extern "C" fn(
            dgst: *const ::std::os::raw::c_uchar,
            dgst_len: ::std::os::raw::c_int,
            sig: *mut DSA_SIG,
            dsa: *mut DSA,
        ) -> ::std::os::raw::c_int,
    >,
    pub dsa_mod_exp: ::std::option::Option<
        unsafe extern "C" fn(
            dsa: *mut DSA,
            rr: *mut BIGNUM,
            a1: *mut BIGNUM,
            p1: *mut BIGNUM,
            a2: *mut BIGNUM,
            p2: *mut BIGNUM,
            m: *mut BIGNUM,
            ctx: *mut BN_CTX,
            in_mont: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub bn_mod_exp: ::std::option::Option<
        unsafe extern "C" fn(
            dsa: *mut DSA,
            r: *mut BIGNUM,
            a: *mut BIGNUM,
            p: *const BIGNUM,
            m: *const BIGNUM,
            ctx: *mut BN_CTX,
            m_ctx: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub init: ::std::option::Option<unsafe extern "C" fn(dsa: *mut DSA) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(dsa: *mut DSA) -> ::std::os::raw::c_int>,
    pub flags: ::std::os::raw::c_int,
    pub app_data: *mut ::std::os::raw::c_char,
    pub dsa_paramgen: ::std::option::Option<
        unsafe extern "C" fn(
            dsa: *mut DSA,
            bits: ::std::os::raw::c_int,
            seed: *const ::std::os::raw::c_uchar,
            seed_len: ::std::os::raw::c_int,
            counter_ret: *mut ::std::os::raw::c_int,
            h_ret: *mut ::std::os::raw::c_ulong,
            cb: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >,
    pub dsa_keygen:
        ::std::option::Option<unsafe extern "C" fn(dsa: *mut DSA) -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_dsa_method() {
    assert_eq!(
        ::std::mem::size_of::<dsa_method>(),
        96usize,
        concat!("Size of: ", stringify!(dsa_method))
    );
    assert_eq!(
        ::std::mem::align_of::<dsa_method>(),
        8usize,
        concat!("Alignment of ", stringify!(dsa_method))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_do_sign as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_do_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_sign_setup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_sign_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_do_verify as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_do_verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_mod_exp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_mod_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).bn_mod_exp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(bn_mod_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).init as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).finish as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).app_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_paramgen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_paramgen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_method>())).dsa_keygen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_method),
            "::",
            stringify!(dsa_keygen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    pub pad: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_long,
    pub write_params: ::std::os::raw::c_int,
    pub p: *mut BIGNUM,
    pub q: *mut BIGNUM,
    pub g: *mut BIGNUM,
    pub pub_key: *mut BIGNUM,
    pub priv_key: *mut BIGNUM,
    pub kinv: *mut BIGNUM,
    pub r: *mut BIGNUM,
    pub flags: ::std::os::raw::c_int,
    pub method_mont_p: *mut BN_MONT_CTX,
    pub references: ::std::os::raw::c_int,
    pub ex_data: CRYPTO_EX_DATA,
    pub meth: *const DSA_METHOD,
    pub engine: *mut ENGINE,
}
#[test]
fn bindgen_test_layout_dsa_st() {
    assert_eq!(
        ::std::mem::size_of::<dsa_st>(),
        136usize,
        concat!("Size of: ", stringify!(dsa_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dsa_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dsa_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).write_params as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(write_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).p as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).q as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).g as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).pub_key as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(pub_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).priv_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(priv_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).kinv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(kinv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).r as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(dsa_st), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).method_mont_p as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(method_mont_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).references as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).ex_data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).meth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsa_st>())).engine as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dsa_st),
            "::",
            stringify!(engine)
        )
    );
}
extern "C" {
    pub fn DSAparams_dup(x: *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn DSA_SIG_new() -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_free(a: *mut DSA_SIG);
}
extern "C" {
    pub fn i2d_DSA_SIG(
        a: *const DSA_SIG,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_SIG(
        v: *mut *mut DSA_SIG,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_sign(
        dgst: *const ::std::os::raw::c_uchar,
        dlen: ::std::os::raw::c_int,
        dsa: *mut DSA,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_verify(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sig: *mut DSA_SIG,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_OpenSSL() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_default_method(arg1: *const DSA_METHOD);
}
extern "C" {
    pub fn DSA_get_default_method() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_method(dsa: *mut DSA, arg1: *const DSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_new() -> *mut DSA;
}
extern "C" {
    pub fn DSA_new_method(engine: *mut ENGINE) -> *mut DSA;
}
extern "C" {
    pub fn DSA_free(r: *mut DSA);
}
extern "C" {
    pub fn DSA_up_ref(r: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_size(arg1: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign_setup(
        dsa: *mut DSA,
        ctx_in: *mut BN_CTX,
        kinvp: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_verify(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_int,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set_ex_data(
        d: *mut DSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_ex_data(d: *mut DSA, idx: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn d2i_DSAPublicKey(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAPrivateKey(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAparams(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_parameters(
        bits: ::std::os::raw::c_int,
        seed: *mut ::std::os::raw::c_uchar,
        seed_len: ::std::os::raw::c_int,
        counter_ret: *mut ::std::os::raw::c_int,
        h_ret: *mut ::std::os::raw::c_ulong,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_parameters_ex(
        dsa: *mut DSA,
        bits: ::std::os::raw::c_int,
        seed: *const ::std::os::raw::c_uchar,
        seed_len: ::std::os::raw::c_int,
        counter_ret: *mut ::std::os::raw::c_int,
        h_ret: *mut ::std::os::raw::c_ulong,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_generate_key(a: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPublicKey(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPrivateKey(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAparams(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSAparams_print(bp: *mut BIO, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print(
        bp: *mut BIO,
        x: *const DSA,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSAparams_print_fp(fp: *mut FILE, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print_fp(
        bp: *mut FILE,
        x: *const DSA,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_dup_DH(r: *const DSA) -> *mut DH;
}
extern "C" {
    pub fn ERR_load_DSA_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAstate_st {
    pub h0: ::std::os::raw::c_uint,
    pub h1: ::std::os::raw::c_uint,
    pub h2: ::std::os::raw::c_uint,
    pub h3: ::std::os::raw::c_uint,
    pub h4: ::std::os::raw::c_uint,
    pub Nl: ::std::os::raw::c_uint,
    pub Nh: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_uint; 16usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SHAstate_st() {
    assert_eq!(
        ::std::mem::size_of::<SHAstate_st>(),
        96usize,
        concat!("Size of: ", stringify!(SHAstate_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHAstate_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHAstate_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).Nl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).Nh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).num as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(num)
        )
    );
}
pub type SHA_CTX = SHAstate_st;
extern "C" {
    pub fn SHA_Init(c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA_Update(
        c: *mut SHA_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA_Final(md: *mut ::std::os::raw::c_uchar, c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA_Transform(c: *mut SHA_CTX, data: *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn SHA1_Init(c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Update(
        c: *mut SHA_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Final(md: *mut ::std::os::raw::c_uchar, c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA1_Transform(c: *mut SHA_CTX, data: *const ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256state_st {
    pub h: [::std::os::raw::c_uint; 8usize],
    pub Nl: ::std::os::raw::c_uint,
    pub Nh: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_uint; 16usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SHA256state_st() {
    assert_eq!(
        ::std::mem::size_of::<SHA256state_st>(),
        112usize,
        concat!("Size of: ", stringify!(SHA256state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA256state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHA256state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).Nl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).Nh as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).num as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).md_len as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA256_CTX = SHA256state_st;
extern "C" {
    pub fn SHA224_Init(c: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Update(
        c: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA256_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA256_Init(c: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Update(
        c: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA256_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA256_Transform(c: *mut SHA256_CTX, data: *const ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512state_st {
    pub h: [::std::os::raw::c_ulonglong; 8usize],
    pub Nl: ::std::os::raw::c_ulonglong,
    pub Nh: ::std::os::raw::c_ulonglong,
    pub u: SHA512state_st__bindgen_ty_1,
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512state_st__bindgen_ty_1 {
    pub d: [::std::os::raw::c_ulonglong; 16usize],
    pub p: [::std::os::raw::c_uchar; 128usize],
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_SHA512state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SHA512state_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA512state_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_SHA512state_st() {
    assert_eq!(
        ::std::mem::size_of::<SHA512state_st>(),
        216usize,
        concat!("Size of: ", stringify!(SHA512state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA512state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).Nl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).Nh as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).u as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).num as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).md_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA512_CTX = SHA512state_st;
extern "C" {
    pub fn SHA384_Init(c: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Update(
        c: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA512_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA512_Init(c: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Update(
        c: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA512_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512(
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA512_Transform(c: *mut SHA512_CTX, data: *const ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_objects_st {
    pub nid: ::std::os::raw::c_int,
    pub a2i: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub i2a: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_X509_objects_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_objects_st>(),
        24usize,
        concat!("Size of: ", stringify!(X509_objects_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_objects_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_objects_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_objects_st>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_objects_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_objects_st>())).a2i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_objects_st),
            "::",
            stringify!(a2i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_objects_st>())).i2a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_objects_st),
            "::",
            stringify!(i2a)
        )
    );
}
pub type X509_OBJECTS = X509_objects_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    pub algorithm: *mut ASN1_OBJECT,
    pub parameter: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_X509_algor_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_algor_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_algor_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_algor_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_algor_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).parameter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(parameter)
        )
    );
}
pub type X509_ALGORS = stack_st_X509_ALGOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_val_st {
    pub notBefore: *mut ASN1_TIME,
    pub notAfter: *mut ASN1_TIME,
}
#[test]
fn bindgen_test_layout_X509_val_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_val_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_val_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_val_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_val_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_val_st>())).notBefore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_val_st),
            "::",
            stringify!(notBefore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_val_st>())).notAfter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_val_st),
            "::",
            stringify!(notAfter)
        )
    );
}
pub type X509_VAL = X509_val_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_pubkey_st {
    pub algor: *mut X509_ALGOR,
    pub public_key: *mut ASN1_BIT_STRING,
    pub pkey: *mut EVP_PKEY,
}
#[test]
fn bindgen_test_layout_X509_pubkey_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_pubkey_st>(),
        24usize,
        concat!("Size of: ", stringify!(X509_pubkey_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_pubkey_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_pubkey_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_pubkey_st>())).algor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_pubkey_st),
            "::",
            stringify!(algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_pubkey_st>())).public_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_pubkey_st),
            "::",
            stringify!(public_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_pubkey_st>())).pkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_pubkey_st),
            "::",
            stringify!(pkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_sig_st {
    pub algor: *mut X509_ALGOR,
    pub digest: *mut ASN1_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_X509_sig_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_sig_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_sig_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_sig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_sig_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_sig_st>())).algor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_sig_st),
            "::",
            stringify!(algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_sig_st>())).digest as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_sig_st),
            "::",
            stringify!(digest)
        )
    );
}
pub type X509_SIG = X509_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_entry_st {
    pub object: *mut ASN1_OBJECT,
    pub value: *mut ASN1_STRING,
    pub set: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_X509_name_entry_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_name_entry_st>(),
        24usize,
        concat!("Size of: ", stringify!(X509_name_entry_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_name_entry_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_name_entry_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_entry_st>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_entry_st),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_entry_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_entry_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_entry_st>())).set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_entry_st),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_entry_st>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_entry_st),
            "::",
            stringify!(size)
        )
    );
}
pub type X509_NAME_ENTRY = X509_name_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME_ENTRY {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_NAME_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_NAME_ENTRY>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_NAME_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_NAME_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_NAME_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_NAME_ENTRY>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_NAME_ENTRY),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_st {
    pub entries: *mut stack_st_X509_NAME_ENTRY,
    pub modified: ::std::os::raw::c_int,
    pub bytes: *mut BUF_MEM,
    pub canon_enc: *mut ::std::os::raw::c_uchar,
    pub canon_enclen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_X509_name_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_name_st>(),
        40usize,
        concat!("Size of: ", stringify!(X509_name_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_name_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_name_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_st>())).entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_st),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_st>())).modified as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_st),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_st>())).bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_st),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_st>())).canon_enc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_st),
            "::",
            stringify!(canon_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_name_st>())).canon_enclen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_name_st),
            "::",
            stringify!(canon_enclen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_NAME() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_NAME>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_NAME>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_NAME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_NAME>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_NAME),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_extension_st {
    pub object: *mut ASN1_OBJECT,
    pub critical: ASN1_BOOLEAN,
    pub value: *mut ASN1_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_X509_extension_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_extension_st>(),
        24usize,
        concat!("Size of: ", stringify!(X509_extension_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_extension_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_extension_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_extension_st>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_extension_st),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_extension_st>())).critical as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_extension_st),
            "::",
            stringify!(critical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_extension_st>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_extension_st),
            "::",
            stringify!(value)
        )
    );
}
pub type X509_EXTENSION = X509_extension_st;
pub type X509_EXTENSIONS = stack_st_X509_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_EXTENSION {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_EXTENSION() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_EXTENSION>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_EXTENSION))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_EXTENSION>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_EXTENSION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_EXTENSION>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_EXTENSION),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_attributes_st {
    pub object: *mut ASN1_OBJECT,
    pub single: ::std::os::raw::c_int,
    pub value: x509_attributes_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_attributes_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub set: *mut stack_st_ASN1_TYPE,
    pub single: *mut ASN1_TYPE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_x509_attributes_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<x509_attributes_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(x509_attributes_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_attributes_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x509_attributes_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_attributes_st__bindgen_ty_1>())).ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_attributes_st__bindgen_ty_1>())).set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_attributes_st__bindgen_ty_1>())).single as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st__bindgen_ty_1),
            "::",
            stringify!(single)
        )
    );
}
#[test]
fn bindgen_test_layout_x509_attributes_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_attributes_st>(),
        24usize,
        concat!("Size of: ", stringify!(x509_attributes_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_attributes_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_attributes_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_attributes_st>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_attributes_st>())).single as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st),
            "::",
            stringify!(single)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_attributes_st>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_attributes_st),
            "::",
            stringify!(value)
        )
    );
}
pub type X509_ATTRIBUTE = x509_attributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ATTRIBUTE {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_ATTRIBUTE() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_ATTRIBUTE>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_ATTRIBUTE))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_ATTRIBUTE>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_ATTRIBUTE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_ATTRIBUTE>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_ATTRIBUTE),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_info_st {
    pub enc: ASN1_ENCODING,
    pub version: *mut ASN1_INTEGER,
    pub subject: *mut X509_NAME,
    pub pubkey: *mut X509_PUBKEY,
    pub attributes: *mut stack_st_X509_ATTRIBUTE,
}
#[test]
fn bindgen_test_layout_X509_req_info_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_req_info_st>(),
        56usize,
        concat!("Size of: ", stringify!(X509_req_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_req_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_req_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_info_st>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_info_st),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_info_st>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_info_st>())).subject as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_info_st),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_info_st>())).pubkey as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_info_st),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_info_st>())).attributes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_info_st),
            "::",
            stringify!(attributes)
        )
    );
}
pub type X509_REQ_INFO = X509_req_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_st {
    pub req_info: *mut X509_REQ_INFO,
    pub sig_alg: *mut X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
    pub references: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_X509_req_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_req_st>(),
        32usize,
        concat!("Size of: ", stringify!(X509_req_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_req_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_req_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_st>())).req_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_st),
            "::",
            stringify!(req_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_st>())).sig_alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_st),
            "::",
            stringify!(sig_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_st>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_st),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_req_st>())).references as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_req_st),
            "::",
            stringify!(references)
        )
    );
}
pub type X509_REQ = X509_req_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cinf_st {
    pub version: *mut ASN1_INTEGER,
    pub serialNumber: *mut ASN1_INTEGER,
    pub signature: *mut X509_ALGOR,
    pub issuer: *mut X509_NAME,
    pub validity: *mut X509_VAL,
    pub subject: *mut X509_NAME,
    pub key: *mut X509_PUBKEY,
    pub issuerUID: *mut ASN1_BIT_STRING,
    pub subjectUID: *mut ASN1_BIT_STRING,
    pub extensions: *mut stack_st_X509_EXTENSION,
    pub enc: ASN1_ENCODING,
}
#[test]
fn bindgen_test_layout_x509_cinf_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_cinf_st>(),
        104usize,
        concat!("Size of: ", stringify!(x509_cinf_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_cinf_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_cinf_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).serialNumber as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).issuer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).validity as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(validity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).subject as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).key as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).issuerUID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(issuerUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).subjectUID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(subjectUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).extensions as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cinf_st>())).enc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cinf_st),
            "::",
            stringify!(enc)
        )
    );
}
pub type X509_CINF = x509_cinf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cert_aux_st {
    pub trust: *mut stack_st_ASN1_OBJECT,
    pub reject: *mut stack_st_ASN1_OBJECT,
    pub alias: *mut ASN1_UTF8STRING,
    pub keyid: *mut ASN1_OCTET_STRING,
    pub other: *mut stack_st_X509_ALGOR,
}
#[test]
fn bindgen_test_layout_x509_cert_aux_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_cert_aux_st>(),
        40usize,
        concat!("Size of: ", stringify!(x509_cert_aux_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_cert_aux_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_cert_aux_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_aux_st>())).trust as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_aux_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_aux_st>())).reject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_aux_st),
            "::",
            stringify!(reject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_aux_st>())).alias as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_aux_st),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_aux_st>())).keyid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_aux_st),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_aux_st>())).other as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_aux_st),
            "::",
            stringify!(other)
        )
    );
}
pub type X509_CERT_AUX = x509_cert_aux_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    pub cert_info: *mut X509_CINF,
    pub sig_alg: *mut X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
    pub valid: ::std::os::raw::c_int,
    pub references: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub ex_data: CRYPTO_EX_DATA,
    pub ex_pathlen: ::std::os::raw::c_long,
    pub ex_pcpathlen: ::std::os::raw::c_long,
    pub ex_flags: ::std::os::raw::c_ulong,
    pub ex_kusage: ::std::os::raw::c_ulong,
    pub ex_xkusage: ::std::os::raw::c_ulong,
    pub ex_nscert: ::std::os::raw::c_ulong,
    pub skid: *mut ASN1_OCTET_STRING,
    pub akid: *mut AUTHORITY_KEYID,
    pub policy_cache: *mut X509_POLICY_CACHE,
    pub crldp: *mut stack_st_DIST_POINT,
    pub altname: *mut stack_st_GENERAL_NAME,
    pub nc: *mut NAME_CONSTRAINTS,
    pub sha1_hash: [::std::os::raw::c_uchar; 20usize],
    pub aux: *mut X509_CERT_AUX,
}
#[test]
fn bindgen_test_layout_x509_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_st>(),
        184usize,
        concat!("Size of: ", stringify!(x509_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).cert_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(cert_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).sig_alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(sig_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).valid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).references as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_pathlen as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_pathlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_pcpathlen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_pcpathlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_kusage as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_kusage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_xkusage as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_xkusage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).ex_nscert as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(ex_nscert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).skid as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(skid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).akid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(akid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).policy_cache as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(policy_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).crldp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(crldp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).altname as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(altname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).nc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(nc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).sha1_hash as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(sha1_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_st>())).aux as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_st),
            "::",
            stringify!(aux)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509 {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_trust_st {
    pub trust: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub check_trust: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut x509_trust_st,
            arg2: *mut X509,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_int,
    pub arg2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_x509_trust_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_trust_st>(),
        40usize,
        concat!("Size of: ", stringify!(x509_trust_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_trust_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_trust_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).trust as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).check_trust as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(check_trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).arg1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).arg2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg2)
        )
    );
}
pub type X509_TRUST = x509_trust_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_TRUST {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_TRUST() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_TRUST>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_TRUST))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_TRUST>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_TRUST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_TRUST>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_TRUST),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cert_pair_st {
    pub forward: *mut X509,
    pub reverse: *mut X509,
}
#[test]
fn bindgen_test_layout_x509_cert_pair_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_cert_pair_st>(),
        16usize,
        concat!("Size of: ", stringify!(x509_cert_pair_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_cert_pair_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_cert_pair_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_pair_st>())).forward as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_pair_st),
            "::",
            stringify!(forward)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_cert_pair_st>())).reverse as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_cert_pair_st),
            "::",
            stringify!(reverse)
        )
    );
}
pub type X509_CERT_PAIR = x509_cert_pair_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_revoked_st {
    pub serialNumber: *mut ASN1_INTEGER,
    pub revocationDate: *mut ASN1_TIME,
    pub extensions: *mut stack_st_X509_EXTENSION,
    pub issuer: *mut stack_st_GENERAL_NAME,
    pub reason: ::std::os::raw::c_int,
    pub sequence: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x509_revoked_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_revoked_st>(),
        40usize,
        concat!("Size of: ", stringify!(x509_revoked_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_revoked_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_revoked_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).serialNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).revocationDate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(revocationDate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).extensions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).issuer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).reason as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_revoked_st>())).sequence as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_revoked_st),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_REVOKED {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_REVOKED() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_REVOKED>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_REVOKED))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_REVOKED>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_REVOKED))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_REVOKED>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_REVOKED),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_info_st {
    pub version: *mut ASN1_INTEGER,
    pub sig_alg: *mut X509_ALGOR,
    pub issuer: *mut X509_NAME,
    pub lastUpdate: *mut ASN1_TIME,
    pub nextUpdate: *mut ASN1_TIME,
    pub revoked: *mut stack_st_X509_REVOKED,
    pub extensions: *mut stack_st_X509_EXTENSION,
    pub enc: ASN1_ENCODING,
}
#[test]
fn bindgen_test_layout_X509_crl_info_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_crl_info_st>(),
        80usize,
        concat!("Size of: ", stringify!(X509_crl_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_crl_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_crl_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).sig_alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(sig_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).issuer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).lastUpdate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(lastUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).nextUpdate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(nextUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).revoked as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(revoked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).extensions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_info_st>())).enc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_info_st),
            "::",
            stringify!(enc)
        )
    );
}
pub type X509_CRL_INFO = X509_crl_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_st {
    pub crl: *mut X509_CRL_INFO,
    pub sig_alg: *mut X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
    pub references: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub akid: *mut AUTHORITY_KEYID,
    pub idp: *mut ISSUING_DIST_POINT,
    pub idp_flags: ::std::os::raw::c_int,
    pub idp_reasons: ::std::os::raw::c_int,
    pub crl_number: *mut ASN1_INTEGER,
    pub base_crl_number: *mut ASN1_INTEGER,
    pub sha1_hash: [::std::os::raw::c_uchar; 20usize],
    pub issuers: *mut stack_st_GENERAL_NAMES,
    pub meth: *const X509_CRL_METHOD,
    pub meth_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_X509_crl_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_crl_st>(),
        120usize,
        concat!("Size of: ", stringify!(X509_crl_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_crl_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_crl_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).crl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).sig_alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(sig_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).references as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).akid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(akid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).idp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(idp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).idp_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(idp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).idp_reasons as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(idp_reasons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).crl_number as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(crl_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).base_crl_number as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(base_crl_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).sha1_hash as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(sha1_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).issuers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(issuers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).meth as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_crl_st>())).meth_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_crl_st),
            "::",
            stringify!(meth_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_CRL {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_CRL() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_CRL>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_CRL))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_CRL>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_CRL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_CRL>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_CRL),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct private_key_st {
    pub version: ::std::os::raw::c_int,
    pub enc_algor: *mut X509_ALGOR,
    pub enc_pkey: *mut ASN1_OCTET_STRING,
    pub dec_pkey: *mut EVP_PKEY,
    pub key_length: ::std::os::raw::c_int,
    pub key_data: *mut ::std::os::raw::c_char,
    pub key_free: ::std::os::raw::c_int,
    pub cipher: EVP_CIPHER_INFO,
    pub references: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_private_key_st() {
    assert_eq!(
        ::std::mem::size_of::<private_key_st>(),
        88usize,
        concat!("Size of: ", stringify!(private_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<private_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(private_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).enc_algor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(enc_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).enc_pkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(enc_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).dec_pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(dec_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_length as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).cipher as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).references as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(references)
        )
    );
}
pub type X509_PKEY = private_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_info_st {
    pub x509: *mut X509,
    pub crl: *mut X509_CRL,
    pub x_pkey: *mut X509_PKEY,
    pub enc_cipher: EVP_CIPHER_INFO,
    pub enc_len: ::std::os::raw::c_int,
    pub enc_data: *mut ::std::os::raw::c_char,
    pub references: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_X509_info_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_info_st>(),
        72usize,
        concat!("Size of: ", stringify!(X509_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).x509 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).crl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).x_pkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_cipher as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).references as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(references)
        )
    );
}
pub type X509_INFO = X509_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_INFO {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_INFO() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_INFO>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_INFO),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spkac_st {
    pub pubkey: *mut X509_PUBKEY,
    pub challenge: *mut ASN1_IA5STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spkac_st() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_spkac_st>(),
        16usize,
        concat!("Size of: ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spkac_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spkac_st>())).pubkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spkac_st>())).challenge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(challenge)
        )
    );
}
pub type NETSCAPE_SPKAC = Netscape_spkac_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spki_st {
    pub spkac: *mut NETSCAPE_SPKAC,
    pub sig_algor: *mut X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spki_st() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_spki_st>(),
        24usize,
        concat!("Size of: ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spki_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).spkac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(spkac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).sig_algor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(sig_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(signature)
        )
    );
}
pub type NETSCAPE_SPKI = Netscape_spki_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_certificate_sequence {
    pub type_: *mut ASN1_OBJECT,
    pub certs: *mut stack_st_X509,
}
#[test]
fn bindgen_test_layout_Netscape_certificate_sequence() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_certificate_sequence>(),
        16usize,
        concat!("Size of: ", stringify!(Netscape_certificate_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_certificate_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_certificate_sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Netscape_certificate_sequence>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_certificate_sequence),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Netscape_certificate_sequence>())).certs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_certificate_sequence),
            "::",
            stringify!(certs)
        )
    );
}
pub type NETSCAPE_CERT_SEQUENCE = Netscape_certificate_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBEPARAM_st {
    pub salt: *mut ASN1_OCTET_STRING,
    pub iter: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_PBEPARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBEPARAM_st>(),
        16usize,
        concat!("Size of: ", stringify!(PBEPARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBEPARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBEPARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBEPARAM_st>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBEPARAM_st),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBEPARAM_st>())).iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBEPARAM_st),
            "::",
            stringify!(iter)
        )
    );
}
pub type PBEPARAM = PBEPARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBE2PARAM_st {
    pub keyfunc: *mut X509_ALGOR,
    pub encryption: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_PBE2PARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBE2PARAM_st>(),
        16usize,
        concat!("Size of: ", stringify!(PBE2PARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBE2PARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBE2PARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBE2PARAM_st>())).keyfunc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBE2PARAM_st),
            "::",
            stringify!(keyfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBE2PARAM_st>())).encryption as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBE2PARAM_st),
            "::",
            stringify!(encryption)
        )
    );
}
pub type PBE2PARAM = PBE2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBKDF2PARAM_st {
    pub salt: *mut ASN1_TYPE,
    pub iter: *mut ASN1_INTEGER,
    pub keylength: *mut ASN1_INTEGER,
    pub prf: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_PBKDF2PARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBKDF2PARAM_st>(),
        32usize,
        concat!("Size of: ", stringify!(PBKDF2PARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBKDF2PARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBKDF2PARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).keylength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(keylength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).prf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(prf)
        )
    );
}
pub type PBKDF2PARAM = PBKDF2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    pub broken: ::std::os::raw::c_int,
    pub version: *mut ASN1_INTEGER,
    pub pkeyalg: *mut X509_ALGOR,
    pub pkey: *mut ASN1_TYPE,
    pub attributes: *mut stack_st_X509_ATTRIBUTE,
}
#[test]
fn bindgen_test_layout_pkcs8_priv_key_info_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs8_priv_key_info_st>(),
        40usize,
        concat!("Size of: ", stringify!(pkcs8_priv_key_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs8_priv_key_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs8_priv_key_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs8_priv_key_info_st>())).broken as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs8_priv_key_info_st),
            "::",
            stringify!(broken)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs8_priv_key_info_st>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs8_priv_key_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs8_priv_key_info_st>())).pkeyalg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs8_priv_key_info_st),
            "::",
            stringify!(pkeyalg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs8_priv_key_info_st>())).pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs8_priv_key_info_st),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs8_priv_key_info_st>())).attributes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs8_priv_key_info_st),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_node_st {
    pub data: *mut ::std::os::raw::c_void,
    pub next: *mut lhash_node_st,
    pub hash: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lhash_node_st() {
    assert_eq!(
        ::std::mem::size_of::<lhash_node_st>(),
        24usize,
        concat!("Size of: ", stringify!(lhash_node_st))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_node_st>(),
        8usize,
        concat!("Alignment of ", stringify!(lhash_node_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_node_st>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_node_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_node_st>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_node_st),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_node_st>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_node_st),
            "::",
            stringify!(hash)
        )
    );
}
pub type LHASH_NODE = lhash_node_st;
pub type LHASH_COMP_FN_TYPE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type LHASH_HASH_FN_TYPE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ulong,
>;
pub type LHASH_DOALL_FN_TYPE =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type LHASH_DOALL_ARG_FN_TYPE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st {
    pub b: *mut *mut LHASH_NODE,
    pub comp: LHASH_COMP_FN_TYPE,
    pub hash: LHASH_HASH_FN_TYPE,
    pub num_nodes: ::std::os::raw::c_uint,
    pub num_alloc_nodes: ::std::os::raw::c_uint,
    pub p: ::std::os::raw::c_uint,
    pub pmax: ::std::os::raw::c_uint,
    pub up_load: ::std::os::raw::c_ulong,
    pub down_load: ::std::os::raw::c_ulong,
    pub num_items: ::std::os::raw::c_ulong,
    pub num_expands: ::std::os::raw::c_ulong,
    pub num_expand_reallocs: ::std::os::raw::c_ulong,
    pub num_contracts: ::std::os::raw::c_ulong,
    pub num_contract_reallocs: ::std::os::raw::c_ulong,
    pub num_hash_calls: ::std::os::raw::c_ulong,
    pub num_comp_calls: ::std::os::raw::c_ulong,
    pub num_insert: ::std::os::raw::c_ulong,
    pub num_replace: ::std::os::raw::c_ulong,
    pub num_delete: ::std::os::raw::c_ulong,
    pub num_no_delete: ::std::os::raw::c_ulong,
    pub num_retrieve: ::std::os::raw::c_ulong,
    pub num_retrieve_miss: ::std::os::raw::c_ulong,
    pub num_hash_comps: ::std::os::raw::c_ulong,
    pub error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st>(),
        176usize,
        concat!("Size of: ", stringify!(lhash_st))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st>(),
        8usize,
        concat!("Alignment of ", stringify!(lhash_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).comp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_nodes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_alloc_nodes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_alloc_nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).p as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).pmax as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(pmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).up_load as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(up_load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).down_load as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(down_load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_items as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_expands as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_expands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_expand_reallocs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_expand_reallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_contracts as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_contracts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_contract_reallocs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_contract_reallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_hash_calls as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_hash_calls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_comp_calls as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_comp_calls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_insert as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_replace as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_delete as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_no_delete as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_no_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_retrieve as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_retrieve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_retrieve_miss as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_retrieve_miss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).num_hash_comps as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(num_hash_comps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st>())).error as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st),
            "::",
            stringify!(error)
        )
    );
}
pub type _LHASH = lhash_st;
extern "C" {
    pub fn lh_new(h: LHASH_HASH_FN_TYPE, c: LHASH_COMP_FN_TYPE) -> *mut _LHASH;
}
extern "C" {
    pub fn lh_free(lh: *mut _LHASH);
}
extern "C" {
    pub fn lh_insert(
        lh: *mut _LHASH,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lh_delete(
        lh: *mut _LHASH,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lh_retrieve(
        lh: *mut _LHASH,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lh_doall(lh: *mut _LHASH, func: LHASH_DOALL_FN_TYPE);
}
extern "C" {
    pub fn lh_doall_arg(
        lh: *mut _LHASH,
        func: LHASH_DOALL_ARG_FN_TYPE,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn lh_strhash(c: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lh_num_items(lh: *const _LHASH) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lh_stats(lh: *const _LHASH, out: *mut FILE);
}
extern "C" {
    pub fn lh_node_stats(lh: *const _LHASH, out: *mut FILE);
}
extern "C" {
    pub fn lh_node_usage_stats(lh: *const _LHASH, out: *mut FILE);
}
extern "C" {
    pub fn lh_stats_bio(lh: *const _LHASH, out: *mut BIO);
}
extern "C" {
    pub fn lh_node_stats_bio(lh: *const _LHASH, out: *mut BIO);
}
extern "C" {
    pub fn lh_node_usage_stats_bio(lh: *const _LHASH, out: *mut BIO);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_OPENSSL_STRING {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_STRING() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_STRING>(),
        4usize,
        concat!("Size of: ", stringify!(lhash_st_OPENSSL_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(lhash_st_OPENSSL_STRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_OPENSSL_STRING>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_STRING),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_OPENSSL_CSTRING {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_CSTRING() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_CSTRING>(),
        4usize,
        concat!("Size of: ", stringify!(lhash_st_OPENSSL_CSTRING))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_CSTRING>(),
        4usize,
        concat!("Alignment of ", stringify!(lhash_st_OPENSSL_CSTRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_OPENSSL_CSTRING>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_CSTRING),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_file_st {
    pub num_paths: ::std::os::raw::c_int,
    pub num_alloced: ::std::os::raw::c_int,
    pub paths: *mut *mut ::std::os::raw::c_char,
    pub path_type: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x509_file_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_file_st>(),
        24usize,
        concat!("Size of: ", stringify!(x509_file_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_file_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_file_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_file_st>())).num_paths as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_file_st),
            "::",
            stringify!(num_paths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_file_st>())).num_alloced as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_file_st),
            "::",
            stringify!(num_alloced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_file_st>())).paths as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_file_st),
            "::",
            stringify!(paths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_file_st>())).path_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_file_st),
            "::",
            stringify!(path_type)
        )
    );
}
pub type X509_CERT_FILE_CTX = x509_file_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_object_st {
    pub type_: ::std::os::raw::c_int,
    pub data: x509_object_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_object_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub x509: *mut X509,
    pub crl: *mut X509_CRL,
    pub pkey: *mut EVP_PKEY,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_x509_object_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<x509_object_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(x509_object_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_object_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_object_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_object_st__bindgen_ty_1>())).ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_object_st__bindgen_ty_1>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st__bindgen_ty_1),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_object_st__bindgen_ty_1>())).crl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st__bindgen_ty_1),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_object_st__bindgen_ty_1>())).pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st__bindgen_ty_1),
            "::",
            stringify!(pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_x509_object_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_object_st>(),
        16usize,
        concat!("Size of: ", stringify!(x509_object_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_object_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_object_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_object_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_object_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_object_st),
            "::",
            stringify!(data)
        )
    );
}
pub type X509_OBJECT = x509_object_st;
pub type X509_LOOKUP = x509_lookup_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_LOOKUP {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_LOOKUP() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_LOOKUP>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_LOOKUP))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_LOOKUP>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_LOOKUP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_LOOKUP>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_LOOKUP),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_OBJECT {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_OBJECT() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_OBJECT>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_X509_OBJECT>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_OBJECT),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_method_st {
    pub name: *const ::std::os::raw::c_char,
    pub new_item:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int>,
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP)>,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int>,
    pub shutdown:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int>,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_LOOKUP,
            cmd: ::std::os::raw::c_int,
            argc: *const ::std::os::raw::c_char,
            argl: ::std::os::raw::c_long,
            ret: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_by_subject: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_LOOKUP,
            type_: ::std::os::raw::c_int,
            name: *mut X509_NAME,
            ret: *mut X509_OBJECT,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_by_issuer_serial: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_LOOKUP,
            type_: ::std::os::raw::c_int,
            name: *mut X509_NAME,
            serial: *mut ASN1_INTEGER,
            ret: *mut X509_OBJECT,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_by_fingerprint: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_LOOKUP,
            type_: ::std::os::raw::c_int,
            bytes: *mut ::std::os::raw::c_uchar,
            len: ::std::os::raw::c_int,
            ret: *mut X509_OBJECT,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_by_alias: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_LOOKUP,
            type_: ::std::os::raw::c_int,
            str: *mut ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
            ret: *mut X509_OBJECT,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_x509_lookup_method_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_lookup_method_st>(),
        80usize,
        concat!("Size of: ", stringify!(x509_lookup_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_lookup_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_lookup_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).new_item as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(new_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).shutdown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_method_st>())).ctrl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_lookup_method_st>())).get_by_subject as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(get_by_subject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_lookup_method_st>())).get_by_issuer_serial as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(get_by_issuer_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_lookup_method_st>())).get_by_fingerprint as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(get_by_fingerprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_lookup_method_st>())).get_by_alias as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_method_st),
            "::",
            stringify!(get_by_alias)
        )
    );
}
pub type X509_LOOKUP_METHOD = x509_lookup_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_ID_st {
    _unused: [u8; 0],
}
pub type X509_VERIFY_PARAM_ID = X509_VERIFY_PARAM_ID_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_st {
    pub name: *mut ::std::os::raw::c_char,
    pub check_time: time_t,
    pub inh_flags: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub purpose: ::std::os::raw::c_int,
    pub trust: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub policies: *mut stack_st_ASN1_OBJECT,
    pub id: *mut X509_VERIFY_PARAM_ID,
}
#[test]
fn bindgen_test_layout_X509_VERIFY_PARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_VERIFY_PARAM_st>(),
        64usize,
        concat!("Size of: ", stringify!(X509_VERIFY_PARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_VERIFY_PARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_VERIFY_PARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).check_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(check_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).inh_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(inh_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).purpose as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).trust as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).depth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).policies as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(policies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_VERIFY_PARAM_st>())).id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_VERIFY_PARAM_st),
            "::",
            stringify!(id)
        )
    );
}
pub type X509_VERIFY_PARAM = X509_VERIFY_PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_VERIFY_PARAM {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_X509_VERIFY_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_X509_VERIFY_PARAM>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_X509_VERIFY_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_X509_VERIFY_PARAM>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_X509_VERIFY_PARAM))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_X509_VERIFY_PARAM>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_X509_VERIFY_PARAM),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    pub cache: ::std::os::raw::c_int,
    pub objs: *mut stack_st_X509_OBJECT,
    pub get_cert_methods: *mut stack_st_X509_LOOKUP,
    pub param: *mut X509_VERIFY_PARAM,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub verify_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ok: ::std::os::raw::c_int,
            ctx: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            issuer: *mut *mut X509,
            ctx: *mut X509_STORE_CTX,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_issued: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            x: *mut X509,
            issuer: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_revocation: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub get_crl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            crl: *mut *mut X509_CRL,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_crl: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL) -> ::std::os::raw::c_int,
    >,
    pub cert_crl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            crl: *mut X509_CRL,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub lookup_certs: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, nm: *mut X509_NAME) -> *mut stack_st_X509,
    >,
    pub lookup_crls: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            nm: *mut X509_NAME,
        ) -> *mut stack_st_X509_CRL,
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub ex_data: CRYPTO_EX_DATA,
    pub references: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x509_store_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_store_st>(),
        144usize,
        concat!("Size of: ", stringify!(x509_store_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_store_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_store_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).objs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).get_cert_methods as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(get_cert_methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).param as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).verify as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).verify_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(verify_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).get_issuer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(get_issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).check_issued as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(check_issued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).check_revocation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(check_revocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).get_crl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(get_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).check_crl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(check_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).cert_crl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(cert_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).lookup_certs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(lookup_certs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).lookup_crls as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(lookup_crls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).cleanup as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).ex_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_st>())).references as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_st),
            "::",
            stringify!(references)
        )
    );
}
extern "C" {
    pub fn X509_STORE_set_depth(
        store: *mut X509_STORE,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_st {
    pub init: ::std::os::raw::c_int,
    pub skip: ::std::os::raw::c_int,
    pub method: *mut X509_LOOKUP_METHOD,
    pub method_data: *mut ::std::os::raw::c_char,
    pub store_ctx: *mut X509_STORE,
}
#[test]
fn bindgen_test_layout_x509_lookup_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_lookup_st>(),
        32usize,
        concat!("Size of: ", stringify!(x509_lookup_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_lookup_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_lookup_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_st>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_st>())).skip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_st),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_st>())).method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_st>())).method_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_st),
            "::",
            stringify!(method_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_lookup_st>())).store_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_lookup_st),
            "::",
            stringify!(store_ctx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    pub ctx: *mut X509_STORE,
    pub current_method: ::std::os::raw::c_int,
    pub cert: *mut X509,
    pub untrusted: *mut stack_st_X509,
    pub crls: *mut stack_st_X509_CRL,
    pub param: *mut X509_VERIFY_PARAM,
    pub other_ctx: *mut ::std::os::raw::c_void,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub verify_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ok: ::std::os::raw::c_int,
            ctx: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            issuer: *mut *mut X509,
            ctx: *mut X509_STORE_CTX,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_issued: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            x: *mut X509,
            issuer: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_revocation: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub get_crl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            crl: *mut *mut X509_CRL,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_crl: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL) -> ::std::os::raw::c_int,
    >,
    pub cert_crl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            crl: *mut X509_CRL,
            x: *mut X509,
        ) -> ::std::os::raw::c_int,
    >,
    pub check_policy: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub lookup_certs: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, nm: *mut X509_NAME) -> *mut stack_st_X509,
    >,
    pub lookup_crls: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut X509_STORE_CTX,
            nm: *mut X509_NAME,
        ) -> *mut stack_st_X509_CRL,
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int,
    >,
    pub valid: ::std::os::raw::c_int,
    pub last_untrusted: ::std::os::raw::c_int,
    pub chain: *mut stack_st_X509,
    pub tree: *mut X509_POLICY_TREE,
    pub explicit_policy: ::std::os::raw::c_int,
    pub error_depth: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub current_cert: *mut X509,
    pub current_issuer: *mut X509,
    pub current_crl: *mut X509_CRL,
    pub current_crl_score: ::std::os::raw::c_int,
    pub current_reasons: ::std::os::raw::c_uint,
    pub parent: *mut X509_STORE_CTX,
    pub ex_data: CRYPTO_EX_DATA,
}
#[test]
fn bindgen_test_layout_x509_store_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_store_ctx_st>(),
        248usize,
        concat!("Size of: ", stringify!(x509_store_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_store_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_store_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).current_method as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).cert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).untrusted as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(untrusted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).crls as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(crls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).param as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).other_ctx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(other_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).verify as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).verify_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(verify_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).get_issuer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(get_issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).check_issued as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(check_issued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).check_revocation as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(check_revocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).get_crl as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(get_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).check_crl as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(check_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).cert_crl as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(cert_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).check_policy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(check_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).lookup_certs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(lookup_certs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).lookup_crls as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(lookup_crls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).cleanup as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).valid as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).last_untrusted as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(last_untrusted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).chain as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).tree as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).explicit_policy as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(explicit_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).error_depth as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(error_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).error as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).current_cert as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).current_issuer as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).current_crl as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).current_crl_score as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_crl_score)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x509_store_ctx_st>())).current_reasons as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(current_reasons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).parent as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_store_ctx_st>())).ex_data as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_store_ctx_st),
            "::",
            stringify!(ex_data)
        )
    );
}
extern "C" {
    pub fn X509_STORE_CTX_set_depth(ctx: *mut X509_STORE_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_OBJECT_idx_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_match(
        h: *mut stack_st_X509_OBJECT,
        x: *mut X509_OBJECT,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_up_ref_count(a: *mut X509_OBJECT);
}
extern "C" {
    pub fn X509_OBJECT_free_contents(a: *mut X509_OBJECT);
}
extern "C" {
    pub fn X509_STORE_new() -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_free(v: *mut X509_STORE);
}
extern "C" {
    pub fn X509_STORE_get1_certs(st: *mut X509_STORE_CTX, nm: *mut X509_NAME)
        -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_get1_crls(
        st: *mut X509_STORE_CTX,
        nm: *mut X509_NAME,
    ) -> *mut stack_st_X509_CRL;
}
extern "C" {
    pub fn X509_STORE_set_flags(
        ctx: *mut X509_STORE,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_purpose(
        ctx: *mut X509_STORE,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_trust(
        ctx: *mut X509_STORE,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set1_param(
        ctx: *mut X509_STORE,
        pm: *mut X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_verify_cb(
        ctx: *mut X509_STORE,
        verify_cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn X509_STORE_set_lookup_crls_cb(
        ctx: *mut X509_STORE,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut X509_STORE_CTX,
                nm: *mut X509_NAME,
            ) -> *mut stack_st_X509_CRL,
        >,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_new() -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_issuer(
        issuer: *mut *mut X509,
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_free(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_init(
        ctx: *mut X509_STORE_CTX,
        store: *mut X509_STORE,
        x509: *mut X509,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_trusted_stack(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_cleanup(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_store(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_add_lookup(
        v: *mut X509_STORE,
        m: *mut X509_LOOKUP_METHOD,
    ) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_hash_dir() -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_file() -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_STORE_add_cert(ctx: *mut X509_STORE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_add_crl(ctx: *mut X509_STORE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get_by_subject(
        vs: *mut X509_STORE_CTX,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_ctrl(
        ctx: *mut X509_LOOKUP,
        cmd: ::std::os::raw::c_int,
        argc: *const ::std::os::raw::c_char,
        argl: ::std::os::raw::c_long,
        ret: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_new(method: *mut X509_LOOKUP_METHOD) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_free(ctx: *mut X509_LOOKUP);
}
extern "C" {
    pub fn X509_LOOKUP_init(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_subject(
        ctx: *mut X509_LOOKUP,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_issuer_serial(
        ctx: *mut X509_LOOKUP,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
        serial: *mut ASN1_INTEGER,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_fingerprint(
        ctx: *mut X509_LOOKUP,
        type_: ::std::os::raw::c_int,
        bytes: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_alias(
        ctx: *mut X509_LOOKUP,
        type_: ::std::os::raw::c_int,
        str: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_shutdown(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_load_locations(
        ctx: *mut X509_STORE,
        file: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_default_paths(ctx: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_get_error(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error(ctx: *mut X509_STORE_CTX, s: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_error_depth(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_current_cert(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_issuer(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_crl(ctx: *mut X509_STORE_CTX) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_parent_ctx(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_cert(c: *mut X509_STORE_CTX, x: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set_chain(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set0_crls(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509_CRL);
}
extern "C" {
    pub fn X509_STORE_CTX_set_purpose(
        ctx: *mut X509_STORE_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_trust(
        ctx: *mut X509_STORE_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_purpose_inherit(
        ctx: *mut X509_STORE_CTX,
        def_purpose: ::std::os::raw::c_int,
        purpose: ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_flags(ctx: *mut X509_STORE_CTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn X509_STORE_CTX_set_time(
        ctx: *mut X509_STORE_CTX,
        flags: ::std::os::raw::c_ulong,
        t: time_t,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_set_verify_cb(
        ctx: *mut X509_STORE_CTX,
        verify_cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_get0_policy_tree(ctx: *mut X509_STORE_CTX) -> *mut X509_POLICY_TREE;
}
extern "C" {
    pub fn X509_STORE_CTX_get_explicit_policy(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_param(ctx: *mut X509_STORE_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_param(ctx: *mut X509_STORE_CTX, param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_STORE_CTX_set_default(
        ctx: *mut X509_STORE_CTX,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_new() -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_free(param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_inherit(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_name(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_clear_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_flags(param: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_purpose(
        param: *mut X509_VERIFY_PARAM,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_trust(
        param: *mut X509_VERIFY_PARAM,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_depth(param: *mut X509_VERIFY_PARAM, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_time(param: *mut X509_VERIFY_PARAM, t: time_t);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_policy(
        param: *mut X509_VERIFY_PARAM,
        policy: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_policies(
        param: *mut X509_VERIFY_PARAM,
        policies: *mut stack_st_ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        namelen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        namelen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_hostflags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_peername(
        arg1: *mut X509_VERIFY_PARAM,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_email(
        param: *mut X509_VERIFY_PARAM,
        email: *const ::std::os::raw::c_char,
        emaillen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip(
        param: *mut X509_VERIFY_PARAM,
        ip: *const ::std::os::raw::c_uchar,
        iplen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip_asc(
        param: *mut X509_VERIFY_PARAM,
        ipasc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_depth(param: *const X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_name(
        param: *const X509_VERIFY_PARAM,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_table(param: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0(id: ::std::os::raw::c_int) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_table_cleanup();
}
extern "C" {
    pub fn X509_policy_check(
        ptree: *mut *mut X509_POLICY_TREE,
        pexplicit_policy: *mut ::std::os::raw::c_int,
        certs: *mut stack_st_X509,
        policy_oids: *mut stack_st_ASN1_OBJECT,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_tree_free(tree: *mut X509_POLICY_TREE);
}
extern "C" {
    pub fn X509_policy_tree_level_count(tree: *const X509_POLICY_TREE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_tree_get0_level(
        tree: *const X509_POLICY_TREE,
        i: ::std::os::raw::c_int,
    ) -> *mut X509_POLICY_LEVEL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_POLICY_NODE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_tree_get0_policies(
        tree: *const X509_POLICY_TREE,
    ) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_tree_get0_user_policies(
        tree: *const X509_POLICY_TREE,
    ) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_level_node_count(level: *mut X509_POLICY_LEVEL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_level_get0_node(
        level: *mut X509_POLICY_LEVEL,
        i: ::std::os::raw::c_int,
    ) -> *mut X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_node_get0_policy(node: *const X509_POLICY_NODE) -> *const ASN1_OBJECT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYQUALINFO {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_node_get0_qualifiers(
        node: *const X509_POLICY_NODE,
    ) -> *mut stack_st_POLICYQUALINFO;
}
extern "C" {
    pub fn X509_policy_node_get0_parent(node: *const X509_POLICY_NODE) -> *const X509_POLICY_NODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_issuer_and_serial_st {
    pub issuer: *mut X509_NAME,
    pub serial: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_pkcs7_issuer_and_serial_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_issuer_and_serial_st>(),
        16usize,
        concat!("Size of: ", stringify!(pkcs7_issuer_and_serial_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_issuer_and_serial_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_issuer_and_serial_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_issuer_and_serial_st>())).issuer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_issuer_and_serial_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_issuer_and_serial_st>())).serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_issuer_and_serial_st),
            "::",
            stringify!(serial)
        )
    );
}
pub type PKCS7_ISSUER_AND_SERIAL = pkcs7_issuer_and_serial_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signer_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub digest_alg: *mut X509_ALGOR,
    pub auth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub digest_enc_alg: *mut X509_ALGOR,
    pub enc_digest: *mut ASN1_OCTET_STRING,
    pub unauth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub pkey: *mut EVP_PKEY,
}
#[test]
fn bindgen_test_layout_pkcs7_signer_info_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signer_info_st>(),
        64usize,
        concat!("Size of: ", stringify!(pkcs7_signer_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signer_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signer_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).issuer_and_serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(issuer_and_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).digest_alg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(digest_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).auth_attr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(auth_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).digest_enc_alg as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(digest_enc_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).enc_digest as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(enc_digest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).unauth_attr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(unauth_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).pkey as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(pkey)
        )
    );
}
pub type PKCS7_SIGNER_INFO = pkcs7_signer_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_SIGNER_INFO {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_PKCS7_SIGNER_INFO() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_PKCS7_SIGNER_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_PKCS7_SIGNER_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_PKCS7_SIGNER_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_PKCS7_SIGNER_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_PKCS7_SIGNER_INFO>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_PKCS7_SIGNER_INFO),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_recip_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub key_enc_algor: *mut X509_ALGOR,
    pub enc_key: *mut ASN1_OCTET_STRING,
    pub cert: *mut X509,
}
#[test]
fn bindgen_test_layout_pkcs7_recip_info_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_recip_info_st>(),
        40usize,
        concat!("Size of: ", stringify!(pkcs7_recip_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_recip_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_recip_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_recip_info_st>())).issuer_and_serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(issuer_and_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_recip_info_st>())).key_enc_algor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(key_enc_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).enc_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(enc_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).cert as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(cert)
        )
    );
}
pub type PKCS7_RECIP_INFO = pkcs7_recip_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_RECIP_INFO {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_PKCS7_RECIP_INFO() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_PKCS7_RECIP_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_PKCS7_RECIP_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_PKCS7_RECIP_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_PKCS7_RECIP_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_PKCS7_RECIP_INFO>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_PKCS7_RECIP_INFO),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signed_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub contents: *mut pkcs7_st,
}
#[test]
fn bindgen_test_layout_pkcs7_signed_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signed_st>(),
        48usize,
        concat!("Size of: ", stringify!(pkcs7_signed_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signed_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signed_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).md_algs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(md_algs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).cert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).crl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).signer_info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(signer_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).contents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(contents)
        )
    );
}
pub type PKCS7_SIGNED = pkcs7_signed_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enc_content_st {
    pub content_type: *mut ASN1_OBJECT,
    pub algorithm: *mut X509_ALGOR,
    pub enc_data: *mut ASN1_OCTET_STRING,
    pub cipher: *const EVP_CIPHER,
}
#[test]
fn bindgen_test_layout_pkcs7_enc_content_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_enc_content_st>(),
        32usize,
        concat!("Size of: ", stringify!(pkcs7_enc_content_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_enc_content_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_enc_content_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_enc_content_st>())).content_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).algorithm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).enc_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).cipher as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(cipher)
        )
    );
}
pub type PKCS7_ENC_CONTENT = pkcs7_enc_content_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
#[test]
fn bindgen_test_layout_pkcs7_enveloped_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_enveloped_st>(),
        24usize,
        concat!("Size of: ", stringify!(pkcs7_enveloped_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_enveloped_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_enveloped_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enveloped_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_enveloped_st>())).recipientinfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(recipientinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enveloped_st>())).enc_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(enc_data)
        )
    );
}
pub type PKCS7_ENVELOPE = pkcs7_enveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signedandenveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
}
#[test]
fn bindgen_test_layout_pkcs7_signedandenveloped_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signedandenveloped_st>(),
        56usize,
        concat!("Size of: ", stringify!(pkcs7_signedandenveloped_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signedandenveloped_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signedandenveloped_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).md_algs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(md_algs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).cert as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).crl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).signer_info as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(signer_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).enc_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).recipientinfo as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(recipientinfo)
        )
    );
}
pub type PKCS7_SIGN_ENVELOPE = pkcs7_signedandenveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_digest_st {
    pub version: *mut ASN1_INTEGER,
    pub md: *mut X509_ALGOR,
    pub contents: *mut pkcs7_st,
    pub digest: *mut ASN1_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_pkcs7_digest_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_digest_st>(),
        32usize,
        concat!("Size of: ", stringify!(pkcs7_digest_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_digest_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_digest_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).md as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).contents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).digest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(digest)
        )
    );
}
pub type PKCS7_DIGEST = pkcs7_digest_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_encrypted_st {
    pub version: *mut ASN1_INTEGER,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
#[test]
fn bindgen_test_layout_pkcs7_encrypted_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_encrypted_st>(),
        16usize,
        concat!("Size of: ", stringify!(pkcs7_encrypted_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_encrypted_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_encrypted_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_encrypted_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_encrypted_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_encrypted_st>())).enc_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_encrypted_st),
            "::",
            stringify!(enc_data)
        )
    );
}
pub type PKCS7_ENCRYPT = pkcs7_encrypted_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pkcs7_st {
    pub asn1: *mut ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_long,
    pub state: ::std::os::raw::c_int,
    pub detached: ::std::os::raw::c_int,
    pub type_: *mut ASN1_OBJECT,
    pub d: pkcs7_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pkcs7_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub data: *mut ASN1_OCTET_STRING,
    pub sign: *mut PKCS7_SIGNED,
    pub enveloped: *mut PKCS7_ENVELOPE,
    pub signed_and_enveloped: *mut PKCS7_SIGN_ENVELOPE,
    pub digest: *mut PKCS7_DIGEST,
    pub encrypted: *mut PKCS7_ENCRYPT,
    pub other: *mut ASN1_TYPE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkcs7_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pkcs7_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).sign as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).enveloped as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(enveloped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).signed_and_enveloped as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(signed_and_enveloped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).encrypted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(encrypted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).other as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(other)
        )
    );
}
#[test]
fn bindgen_test_layout_pkcs7_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_st>(),
        40usize,
        concat!("Size of: ", stringify!(pkcs7_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).asn1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(asn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).detached as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(detached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).d as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(d)
        )
    );
}
pub type PKCS7 = pkcs7_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7 {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_PKCS7() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_PKCS7>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_PKCS7))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_PKCS7>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_PKCS7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_PKCS7>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_PKCS7),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_new() -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_free(a: *mut PKCS7_ISSUER_AND_SERIAL);
}
extern "C" {
    pub fn d2i_PKCS7_ISSUER_AND_SERIAL(
        a: *mut *mut PKCS7_ISSUER_AND_SERIAL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn i2d_PKCS7_ISSUER_AND_SERIAL(
        a: *mut PKCS7_ISSUER_AND_SERIAL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ISSUER_AND_SERIAL_it"]
    pub static PKCS7_ISSUER_AND_SERIAL_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_digest(
        data: *mut PKCS7_ISSUER_AND_SERIAL,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS7_fp(fp: *mut FILE, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_fp(fp: *mut FILE, p7: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dup(p7: *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn d2i_PKCS7_bio(bp: *mut BIO, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_bio(bp: *mut BIO, p7: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS7_bio_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_new() -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_free(a: *mut PKCS7_SIGNER_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNER_INFO(
        a: *mut *mut PKCS7_SIGNER_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNER_INFO(
        a: *mut PKCS7_SIGNER_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_SIGNER_INFO_it"]
    pub static PKCS7_SIGNER_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_new() -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_free(a: *mut PKCS7_RECIP_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_RECIP_INFO(
        a: *mut *mut PKCS7_RECIP_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_RECIP_INFO(
        a: *mut PKCS7_RECIP_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_RECIP_INFO_it"]
    pub static PKCS7_RECIP_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGNED_new() -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn PKCS7_SIGNED_free(a: *mut PKCS7_SIGNED);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNED(
        a: *mut *mut PKCS7_SIGNED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNED(
        a: *mut PKCS7_SIGNED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_SIGNED_it"]
    pub static PKCS7_SIGNED_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_new() -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_free(a: *mut PKCS7_ENC_CONTENT);
}
extern "C" {
    pub fn d2i_PKCS7_ENC_CONTENT(
        a: *mut *mut PKCS7_ENC_CONTENT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn i2d_PKCS7_ENC_CONTENT(
        a: *mut PKCS7_ENC_CONTENT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ENC_CONTENT_it"]
    pub static PKCS7_ENC_CONTENT_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_new() -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_free(a: *mut PKCS7_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_ENVELOPE(
        a: *mut *mut PKCS7_ENVELOPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_ENVELOPE(
        a: *mut PKCS7_ENVELOPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ENVELOPE_it"]
    pub static PKCS7_ENVELOPE_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_new() -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_free(a: *mut PKCS7_SIGN_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_SIGN_ENVELOPE(
        a: *mut *mut PKCS7_SIGN_ENVELOPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_SIGN_ENVELOPE(
        a: *mut PKCS7_SIGN_ENVELOPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_SIGN_ENVELOPE_it"]
    pub static PKCS7_SIGN_ENVELOPE_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_DIGEST_new() -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn PKCS7_DIGEST_free(a: *mut PKCS7_DIGEST);
}
extern "C" {
    pub fn d2i_PKCS7_DIGEST(
        a: *mut *mut PKCS7_DIGEST,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn i2d_PKCS7_DIGEST(
        a: *mut PKCS7_DIGEST,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_DIGEST_it"]
    pub static PKCS7_DIGEST_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_new() -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_free(a: *mut PKCS7_ENCRYPT);
}
extern "C" {
    pub fn d2i_PKCS7_ENCRYPT(
        a: *mut *mut PKCS7_ENCRYPT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn i2d_PKCS7_ENCRYPT(
        a: *mut PKCS7_ENCRYPT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ENCRYPT_it"]
    pub static PKCS7_ENCRYPT_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_new() -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_free(a: *mut PKCS7);
}
extern "C" {
    pub fn d2i_PKCS7(
        a: *mut *mut PKCS7,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7(
        a: *mut PKCS7,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_it"]
    pub static PKCS7_it: ASN1_ITEM;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ATTR_SIGN_it"]
    pub static PKCS7_ATTR_SIGN_it: ASN1_ITEM;
}
extern "C" {
    #[link_name = "\u{1}PKCS7_ATTR_VERIFY_it"]
    pub static PKCS7_ATTR_VERIFY_it: ASN1_ITEM;
}
extern "C" {
    pub fn i2d_PKCS7_NDEF(
        a: *mut PKCS7,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_print_ctx(
        out: *mut BIO,
        x: *mut PKCS7,
        indent: ::std::os::raw::c_int,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_ctrl(
        p7: *mut PKCS7,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PKCS7_set_type(p7: *mut PKCS7, type_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set0_type_other(
        p7: *mut PKCS7,
        type_: ::std::os::raw::c_int,
        other: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_content(p7: *mut PKCS7, p7_data: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_set(
        p7i: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_sign(si: *mut PKCS7_SIGNER_INFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_signer(p7: *mut PKCS7, p7i: *mut PKCS7_SIGNER_INFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_certificate(p7: *mut PKCS7, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_crl(p7: *mut PKCS7, x509: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_content_new(p7: *mut PKCS7, nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataVerify(
        cert_store: *mut X509_STORE,
        ctx: *mut X509_STORE_CTX,
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_signatureVerify(
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataInit(p7: *mut PKCS7, bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_dataFinal(p7: *mut PKCS7, bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataDecode(
        p7: *mut PKCS7,
        pkey: *mut EVP_PKEY,
        in_bio: *mut BIO,
        pcert: *mut X509,
    ) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_add_signature(
        p7: *mut PKCS7,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_cert_from_signer_info(p7: *mut PKCS7, si: *mut PKCS7_SIGNER_INFO) -> *mut X509;
}
extern "C" {
    pub fn PKCS7_set_digest(p7: *mut PKCS7, md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_signer_info(p7: *mut PKCS7) -> *mut stack_st_PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_add_recipient(p7: *mut PKCS7, x509: *mut X509) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_get0_algs(
        si: *mut PKCS7_SIGNER_INFO,
        pk: *mut *mut EVP_PKEY,
        pdig: *mut *mut X509_ALGOR,
        psig: *mut *mut X509_ALGOR,
    );
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_get0_alg(ri: *mut PKCS7_RECIP_INFO, penc: *mut *mut X509_ALGOR);
}
extern "C" {
    pub fn PKCS7_add_recipient_info(
        p7: *mut PKCS7,
        ri: *mut PKCS7_RECIP_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_set(
        p7i: *mut PKCS7_RECIP_INFO,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_cipher(p7: *mut PKCS7, cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_stream(
        boundary: *mut *mut *mut ::std::os::raw::c_uchar,
        p7: *mut PKCS7,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_issuer_and_serial(
        p7: *mut PKCS7,
        idx: ::std::os::raw::c_int,
    ) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_digest_from_attributes(sk: *mut stack_st_X509_ATTRIBUTE)
        -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn PKCS7_add_signed_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_attribute(
        si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_get_signed_attribute(
        si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_set_signed_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_sign(
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        certs: *mut stack_st_X509,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_sign_add_signer(
        p7: *mut PKCS7,
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_final(
        p7: *mut PKCS7,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_verify(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        store: *mut X509_STORE,
        indata: *mut BIO,
        out: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get0_signers(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        flags: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn PKCS7_encrypt(
        certs: *mut stack_st_X509,
        in_: *mut BIO,
        cipher: *const EVP_CIPHER,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_decrypt(
        p7: *mut PKCS7,
        pkey: *mut EVP_PKEY,
        cert: *mut X509,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_smimecap(
        si: *mut PKCS7_SIGNER_INFO,
        cap: *mut stack_st_X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_smimecap(si: *mut PKCS7_SIGNER_INFO) -> *mut stack_st_X509_ALGOR;
}
extern "C" {
    pub fn PKCS7_simple_smimecap(
        sk: *mut stack_st_X509_ALGOR,
        nid: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_content_type(
        si: *mut PKCS7_SIGNER_INFO,
        coid: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add0_attrib_signing_time(
        si: *mut PKCS7_SIGNER_INFO,
        t: *mut ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add1_attrib_digest(
        si: *mut PKCS7_SIGNER_INFO,
        md: *const ::std::os::raw::c_uchar,
        mdlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_write_PKCS7(
        bio: *mut BIO,
        p7: *mut PKCS7,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_read_PKCS7(bio: *mut BIO, bcont: *mut *mut BIO) -> *mut PKCS7;
}
extern "C" {
    pub fn BIO_new_PKCS7(out: *mut BIO, p7: *mut PKCS7) -> *mut BIO;
}
extern "C" {
    pub fn ERR_load_PKCS7_strings();
}
extern "C" {
    pub fn X509_CRL_set_default_method(meth: *const X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_METHOD_new(
        crl_init: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL) -> ::std::os::raw::c_int,
        >,
        crl_free: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL) -> ::std::os::raw::c_int,
        >,
        crl_lookup: ::std::option::Option<
            unsafe extern "C" fn(
                crl: *mut X509_CRL,
                ret: *mut *mut X509_REVOKED,
                ser: *mut ASN1_INTEGER,
                issuer: *mut X509_NAME,
            ) -> ::std::os::raw::c_int,
        >,
        crl_verify: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    ) -> *mut X509_CRL_METHOD;
}
extern "C" {
    pub fn X509_CRL_METHOD_free(m: *mut X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_set_meth_data(crl: *mut X509_CRL, dat: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn X509_CRL_get_meth_data(crl: *mut X509_CRL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_verify_cert_error_string(
        n: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_verify(a: *mut X509, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_verify(a: *mut X509_REQ, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_verify(a: *mut X509_CRL, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_verify(a: *mut NETSCAPE_SPKI, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_decode(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_encode(x: *mut NETSCAPE_SPKI) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn NETSCAPE_SPKI_get_pubkey(x: *mut NETSCAPE_SPKI) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn NETSCAPE_SPKI_set_pubkey(
        x: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_print(out: *mut BIO, spki: *mut NETSCAPE_SPKI) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_dump(
        bp: *mut BIO,
        sig: *const ASN1_STRING,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_print(
        bp: *mut BIO,
        alg: *mut X509_ALGOR,
        sig: *mut ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign_ctx(x: *mut X509, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_http_nbio(rctx: *mut OCSP_REQ_CTX, pcert: *mut *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign(
        x: *mut X509_REQ,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign_ctx(x: *mut X509_REQ, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign(
        x: *mut X509_CRL,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign_ctx(x: *mut X509_CRL, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_http_nbio(
        rctx: *mut OCSP_REQ_CTX,
        pcrl: *mut *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_sign(
        x: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_pubkey_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_digest(
        data: *const X509_CRL,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_digest(
        data: *const X509_REQ,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_digest(
        data: *const X509_NAME,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_fp(fp: *mut FILE, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_fp(fp: *mut FILE, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_fp(fp: *mut FILE, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_fp(fp: *mut FILE, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_fp(fp: *mut FILE, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_fp(fp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_fp(fp: *mut FILE, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_fp(fp: *mut FILE, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_fp(fp: *mut FILE, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_X509_bio(bp: *mut BIO, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_bio(bp: *mut BIO, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_bio(bp: *mut BIO, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_bio(bp: *mut BIO, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_bio(bp: *mut BIO, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_bio(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_bio(bp: *mut BIO, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_bio(bp: *mut BIO, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_bio(bp: *mut BIO, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_dup(x509: *mut X509) -> *mut X509;
}
extern "C" {
    pub fn X509_ATTRIBUTE_dup(xa: *mut X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_EXTENSION_dup(ex: *mut X509_EXTENSION) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_dup(crl: *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_REVOKED_dup(rev: *mut X509_REVOKED) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REQ_dup(req: *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_ALGOR_dup(xn: *mut X509_ALGOR) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_set0(
        alg: *mut X509_ALGOR,
        aobj: *mut ASN1_OBJECT,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ALGOR_get0(
        paobj: *mut *mut ASN1_OBJECT,
        pptype: *mut ::std::os::raw::c_int,
        ppval: *mut *mut ::std::os::raw::c_void,
        algor: *mut X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_ALGOR_set_md(alg: *mut X509_ALGOR, md: *const EVP_MD);
}
extern "C" {
    pub fn X509_ALGOR_cmp(a: *const X509_ALGOR, b: *const X509_ALGOR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_dup(xn: *mut X509_NAME) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_ENTRY_dup(ne: *mut X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_cmp_time(s: *const ASN1_TIME, t: *mut time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_cmp_current_time(s: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_time_adj(
        s: *mut ASN1_TIME,
        adj: ::std::os::raw::c_long,
        t: *mut time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_time_adj_ex(
        s: *mut ASN1_TIME,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
        t: *mut time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_gmtime_adj(s: *mut ASN1_TIME, adj: ::std::os::raw::c_long) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_get_default_cert_area() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_private_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_to_X509_REQ(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_to_X509(
        r: *mut X509_REQ,
        days: ::std::os::raw::c_int,
        pkey: *mut EVP_PKEY,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_ALGOR_new() -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_free(a: *mut X509_ALGOR);
}
extern "C" {
    pub fn d2i_X509_ALGOR(
        a: *mut *mut X509_ALGOR,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn i2d_X509_ALGOR(
        a: *mut X509_ALGOR,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_ALGOR_it"]
    pub static X509_ALGOR_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_ALGORS(
        a: *mut *mut X509_ALGORS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ALGORS;
}
extern "C" {
    pub fn i2d_X509_ALGORS(
        a: *mut X509_ALGORS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_ALGORS_it"]
    pub static X509_ALGORS_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_VAL_new() -> *mut X509_VAL;
}
extern "C" {
    pub fn X509_VAL_free(a: *mut X509_VAL);
}
extern "C" {
    pub fn d2i_X509_VAL(
        a: *mut *mut X509_VAL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_VAL;
}
extern "C" {
    pub fn i2d_X509_VAL(
        a: *mut X509_VAL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_VAL_it"]
    pub static X509_VAL_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_new() -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_PUBKEY_free(a: *mut X509_PUBKEY);
}
extern "C" {
    pub fn d2i_X509_PUBKEY(
        a: *mut *mut X509_PUBKEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY(
        a: *mut X509_PUBKEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_PUBKEY_it"]
    pub static X509_PUBKEY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_set(x: *mut *mut X509_PUBKEY, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get(key: *mut X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey_parameters(
        pkey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PUBKEY(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY(
        a: *mut RSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY(
        a: *mut *mut RSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY(
        a: *mut DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_EC_PUBKEY(
        a: *mut EC_KEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY(
        a: *mut *mut EC_KEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn X509_SIG_new() -> *mut X509_SIG;
}
extern "C" {
    pub fn X509_SIG_free(a: *mut X509_SIG);
}
extern "C" {
    pub fn d2i_X509_SIG(
        a: *mut *mut X509_SIG,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_X509_SIG(
        a: *mut X509_SIG,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_SIG_it"]
    pub static X509_SIG_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_INFO_new() -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn X509_REQ_INFO_free(a: *mut X509_REQ_INFO);
}
extern "C" {
    pub fn d2i_X509_REQ_INFO(
        a: *mut *mut X509_REQ_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn i2d_X509_REQ_INFO(
        a: *mut X509_REQ_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_REQ_INFO_it"]
    pub static X509_REQ_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_new() -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_free(a: *mut X509_REQ);
}
extern "C" {
    pub fn d2i_X509_REQ(
        a: *mut *mut X509_REQ,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ(
        a: *mut X509_REQ,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_REQ_it"]
    pub static X509_REQ_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_new() -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_free(a: *mut X509_ATTRIBUTE);
}
extern "C" {
    pub fn d2i_X509_ATTRIBUTE(
        a: *mut *mut X509_ATTRIBUTE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn i2d_X509_ATTRIBUTE(
        a: *mut X509_ATTRIBUTE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_ATTRIBUTE_it"]
    pub static X509_ATTRIBUTE_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create(
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_EXTENSION_new() -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_free(a: *mut X509_EXTENSION);
}
extern "C" {
    pub fn d2i_X509_EXTENSION(
        a: *mut *mut X509_EXTENSION,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn i2d_X509_EXTENSION(
        a: *mut X509_EXTENSION,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_EXTENSION_it"]
    pub static X509_EXTENSION_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_EXTENSIONS(
        a: *mut *mut X509_EXTENSIONS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSIONS;
}
extern "C" {
    pub fn i2d_X509_EXTENSIONS(
        a: *mut X509_EXTENSIONS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_EXTENSIONS_it"]
    pub static X509_EXTENSIONS_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_ENTRY_new() -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_free(a: *mut X509_NAME_ENTRY);
}
extern "C" {
    pub fn d2i_X509_NAME_ENTRY(
        a: *mut *mut X509_NAME_ENTRY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn i2d_X509_NAME_ENTRY(
        a: *mut X509_NAME_ENTRY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_NAME_ENTRY_it"]
    pub static X509_NAME_ENTRY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_new() -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_free(a: *mut X509_NAME);
}
extern "C" {
    pub fn d2i_X509_NAME(
        a: *mut *mut X509_NAME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME;
}
extern "C" {
    pub fn i2d_X509_NAME(
        a: *mut X509_NAME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_NAME_it"]
    pub static X509_NAME_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_set(xn: *mut *mut X509_NAME, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CINF_new() -> *mut X509_CINF;
}
extern "C" {
    pub fn X509_CINF_free(a: *mut X509_CINF);
}
extern "C" {
    pub fn d2i_X509_CINF(
        a: *mut *mut X509_CINF,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CINF;
}
extern "C" {
    pub fn i2d_X509_CINF(
        a: *mut X509_CINF,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_CINF_it"]
    pub static X509_CINF_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_new() -> *mut X509;
}
extern "C" {
    pub fn X509_free(a: *mut X509);
}
extern "C" {
    pub fn d2i_X509(
        a: *mut *mut X509,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509(a: *mut X509, out: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_it"]
    pub static X509_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CERT_AUX_new() -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn X509_CERT_AUX_free(a: *mut X509_CERT_AUX);
}
extern "C" {
    pub fn d2i_X509_CERT_AUX(
        a: *mut *mut X509_CERT_AUX,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn i2d_X509_CERT_AUX(
        a: *mut X509_CERT_AUX,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_CERT_AUX_it"]
    pub static X509_CERT_AUX_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CERT_PAIR_new() -> *mut X509_CERT_PAIR;
}
extern "C" {
    pub fn X509_CERT_PAIR_free(a: *mut X509_CERT_PAIR);
}
extern "C" {
    pub fn d2i_X509_CERT_PAIR(
        a: *mut *mut X509_CERT_PAIR,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CERT_PAIR;
}
extern "C" {
    pub fn i2d_X509_CERT_PAIR(
        a: *mut X509_CERT_PAIR,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_CERT_PAIR_it"]
    pub static X509_CERT_PAIR_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn i2d_X509_AUX(
        a: *mut X509,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_AUX(
        a: *mut *mut X509,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_re_X509_tbs(
        x: *mut X509,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get0_signature(
        psig: *mut *mut ASN1_BIT_STRING,
        palg: *mut *mut X509_ALGOR,
        x: *const X509,
    );
}
extern "C" {
    pub fn X509_get_signature_nid(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_alias_set1(
        x: *mut X509,
        name: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_keyid_set1(
        x: *mut X509,
        id: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_alias_get0(
        x: *mut X509,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn X509_keyid_get0(
        x: *mut X509,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn X509_TRUST_set_default(
        trust: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut X509,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            trust: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: ::std::os::raw::c_int,
                    arg2: *mut X509,
                    arg3: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn X509_TRUST_set(
        t: *mut ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_trust_object(x: *mut X509, obj: *mut ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_reject_object(x: *mut X509, obj: *mut ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_trust_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_reject_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_REVOKED_new() -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REVOKED_free(a: *mut X509_REVOKED);
}
extern "C" {
    pub fn d2i_X509_REVOKED(
        a: *mut *mut X509_REVOKED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn i2d_X509_REVOKED(
        a: *mut X509_REVOKED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_REVOKED_it"]
    pub static X509_REVOKED_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_INFO_new() -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn X509_CRL_INFO_free(a: *mut X509_CRL_INFO);
}
extern "C" {
    pub fn d2i_X509_CRL_INFO(
        a: *mut *mut X509_CRL_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn i2d_X509_CRL_INFO(
        a: *mut X509_CRL_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_CRL_INFO_it"]
    pub static X509_CRL_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_new() -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_free(a: *mut X509_CRL);
}
extern "C" {
    pub fn d2i_X509_CRL(
        a: *mut *mut X509_CRL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL(
        a: *mut X509_CRL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}X509_CRL_it"]
    pub static X509_CRL_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_add0_revoked(
        crl: *mut X509_CRL,
        rev: *mut X509_REVOKED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_serial(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        serial: *mut ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_cert(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        x: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PKEY_new() -> *mut X509_PKEY;
}
extern "C" {
    pub fn X509_PKEY_free(a: *mut X509_PKEY);
}
extern "C" {
    pub fn i2d_X509_PKEY(
        a: *mut X509_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_PKEY(
        a: *mut *mut X509_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut X509_PKEY;
}
extern "C" {
    pub fn NETSCAPE_SPKI_new() -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_free(a: *mut NETSCAPE_SPKI);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKI(
        a: *mut *mut NETSCAPE_SPKI,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKI(
        a: *mut NETSCAPE_SPKI,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}NETSCAPE_SPKI_it"]
    pub static NETSCAPE_SPKI_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_new() -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_free(a: *mut NETSCAPE_SPKAC);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKAC(
        a: *mut *mut NETSCAPE_SPKAC,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKAC(
        a: *mut NETSCAPE_SPKAC,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}NETSCAPE_SPKAC_it"]
    pub static NETSCAPE_SPKAC_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_new() -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_free(a: *mut NETSCAPE_CERT_SEQUENCE);
}
extern "C" {
    pub fn d2i_NETSCAPE_CERT_SEQUENCE(
        a: *mut *mut NETSCAPE_CERT_SEQUENCE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn i2d_NETSCAPE_CERT_SEQUENCE(
        a: *mut NETSCAPE_CERT_SEQUENCE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}NETSCAPE_CERT_SEQUENCE_it"]
    pub static NETSCAPE_CERT_SEQUENCE_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_INFO_new() -> *mut X509_INFO;
}
extern "C" {
    pub fn X509_INFO_free(a: *mut X509_INFO);
}
extern "C" {
    pub fn X509_NAME_oneline(
        a: *mut X509_NAME,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASN1_verify(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_char,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_digest(
        i2d: i2d_of_void,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_char,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_sign(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_char,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_digest(
        it: *const ASN1_ITEM,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_void,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_verify(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign_ctx(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        asn: *mut ::std::os::raw::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_version(x: *mut X509, version: ::std::os::raw::c_long)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_serialNumber(x: *mut X509, serial: *mut ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_serialNumber(x: *mut X509) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn X509_set_issuer_name(x: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_issuer_name(a: *mut X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_set_subject_name(x: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_subject_name(a: *mut X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_set_notBefore(x: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_notAfter(x: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_pubkey(x: *mut X509, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_pubkey(x: *mut X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get0_pubkey_bitstr(x: *const X509) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn X509_certificate_type(x: *mut X509, pubkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_version(
        x: *mut X509_REQ,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_subject_name(
        req: *mut X509_REQ,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_pubkey(x: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_pubkey(req: *mut X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_extension_nid(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_extension_nids() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_extension_nids(nids: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_REQ_get_extensions(req: *mut X509_REQ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_REQ_add_extensions_nid(
        req: *mut X509_REQ,
        exts: *mut stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add_extensions(
        req: *mut X509_REQ,
        exts: *mut stack_st_X509_EXTENSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_count(req: *const X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_NID(
        req: *const X509_REQ,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_OBJ(
        req: *const X509_REQ,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr(
        req: *const X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_delete_attr(
        req: *mut X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_add1_attr(
        req: *mut X509_REQ,
        attr: *mut X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_OBJ(
        req: *mut X509_REQ,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_NID(
        req: *mut X509_REQ,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_txt(
        req: *mut X509_REQ,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_version(
        x: *mut X509_CRL,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_issuer_name(
        x: *mut X509_CRL,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_lastUpdate(x: *mut X509_CRL, tm: *const ASN1_TIME)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_nextUpdate(x: *mut X509_CRL, tm: *const ASN1_TIME)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sort(crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_set_serialNumber(
        x: *mut X509_REVOKED,
        serial: *mut ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_set_revocationDate(
        r: *mut X509_REVOKED,
        tm: *mut ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_diff(
        base: *mut X509_CRL,
        newer: *mut X509_CRL,
        skey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::std::os::raw::c_uint,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_REQ_check_private_key(
        x509: *mut X509_REQ,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_private_key(x509: *mut X509, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_chain_check_suiteb(
        perror_depth: *mut ::std::os::raw::c_int,
        x: *mut X509,
        chain: *mut stack_st_X509,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_check_suiteb(
        crl: *mut X509_CRL,
        pk: *mut EVP_PKEY,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_chain_up_ref(chain: *mut stack_st_X509) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_issuer_and_serial_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_issuer_and_serial_hash(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_issuer_name_hash(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_subject_name_hash(x: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_hash_old(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_hash_old(x: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_cmp(a: *const X509_NAME, b: *const X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_hash(x: *mut X509_NAME) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_NAME_hash_old(x: *mut X509_NAME) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_CRL_cmp(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_match(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_ex_fp(
        bp: *mut FILE,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_fp(bp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print_fp(bp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_fp(bp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex_fp(
        fp: *mut FILE,
        nm: *mut X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print(
        bp: *mut BIO,
        name: *mut X509_NAME,
        obase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex(
        out: *mut BIO,
        nm: *mut X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_ex(
        bp: *mut BIO,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ocspid_print(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CERT_AUX_print(
        bp: *mut BIO,
        x: *mut X509_CERT_AUX,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_ex(
        bp: *mut BIO,
        x: *mut X509_REQ,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_entry_count(name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_OBJ(
        name: *mut X509_NAME,
        obj: *mut ASN1_OBJECT,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_OBJ(
        name: *mut X509_NAME,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_entry(
        name: *mut X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_delete_entry(
        name: *mut X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry(
        name: *mut X509_NAME,
        ne: *mut X509_NAME_ENTRY,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_OBJ(
        name: *mut X509_NAME,
        obj: *mut ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_txt(
        ne: *mut *mut X509_NAME_ENTRY,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_NID(
        ne: *mut *mut X509_NAME_ENTRY,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_txt(
        name: *mut X509_NAME,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_OBJ(
        ne: *mut *mut X509_NAME_ENTRY,
        obj: *mut ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_object(
        ne: *mut X509_NAME_ENTRY,
        obj: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_data(
        ne: *mut X509_NAME_ENTRY,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_object(ne: *mut X509_NAME_ENTRY) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_data(ne: *mut X509_NAME_ENTRY) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn X509v3_get_ext_count(x: *const stack_st_X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_NID(
        x: *const stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_OBJ(
        x: *const stack_st_X509_EXTENSION,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_critical(
        x: *const stack_st_X509_EXTENSION,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext(
        x: *const stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_delete_ext(
        x: *mut stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_add_ext(
        x: *mut *mut stack_st_X509_EXTENSION,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get_ext_count(x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_NID(
        x: *mut X509,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_OBJ(
        x: *mut X509,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_critical(
        x: *mut X509,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext(x: *mut X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_delete_ext(x: *mut X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_add_ext(
        x: *mut X509,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_d2i(
        x: *mut X509,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_add1_ext_i2d(
        x: *mut X509,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_count(x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_NID(
        x: *mut X509_CRL,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_OBJ(
        x: *mut X509_CRL,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_critical(
        x: *mut X509_CRL,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext(x: *mut X509_CRL, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_delete_ext(x: *mut X509_CRL, loc: ::std::os::raw::c_int)
        -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_add_ext(
        x: *mut X509_CRL,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_d2i(
        x: *mut X509_CRL,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_CRL_add1_ext_i2d(
        x: *mut X509_CRL,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_count(x: *mut X509_REVOKED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_NID(
        x: *mut X509_REVOKED,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_OBJ(
        x: *mut X509_REVOKED,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_critical(
        x: *mut X509_REVOKED,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext(
        x: *mut X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_delete_ext(
        x: *mut X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_add_ext(
        x: *mut X509_REVOKED,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_d2i(
        x: *mut X509_REVOKED,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_REVOKED_add1_ext_i2d(
        x: *mut X509_REVOKED,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_NID(
        ex: *mut *mut X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        crit: ::std::os::raw::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_OBJ(
        ex: *mut *mut X509_EXTENSION,
        obj: *mut ASN1_OBJECT,
        crit: ::std::os::raw::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_set_object(
        ex: *mut X509_EXTENSION,
        obj: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_critical(
        ex: *mut X509_EXTENSION,
        crit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_data(
        ex: *mut X509_EXTENSION,
        data: *mut ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_get_object(ex: *mut X509_EXTENSION) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_EXTENSION_get_data(ne: *mut X509_EXTENSION) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_EXTENSION_get_critical(ex: *mut X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_count(x: *const stack_st_X509_ATTRIBUTE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_NID(
        x: *const stack_st_X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_OBJ(
        sk: *const stack_st_X509_ATTRIBUTE,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr(
        x: *const stack_st_X509_ATTRIBUTE,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_delete_attr(
        x: *mut stack_st_X509_ATTRIBUTE,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attr: *mut X509_ATTRIBUTE,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_OBJ(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_NID(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_txt(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_get0_data_by_OBJ(
        x: *mut stack_st_X509_ATTRIBUTE,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_NID(
        attr: *mut *mut X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_OBJ(
        attr: *mut *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        atrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_txt(
        attr: *mut *mut X509_ATTRIBUTE,
        atrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_object(
        attr: *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_data(
        attr: *mut X509_ATTRIBUTE,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_data(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_count(attr: *mut X509_ATTRIBUTE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_object(attr: *mut X509_ATTRIBUTE) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_type(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_count(key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_NID(
        key: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_OBJ(
        key: *const EVP_PKEY,
        obj: *mut ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr(
        key: *const EVP_PKEY,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_delete_attr(
        key: *mut EVP_PKEY,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr(
        key: *mut EVP_PKEY,
        attr: *mut X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_OBJ(
        key: *mut EVP_PKEY,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_NID(
        key: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_txt(
        key: *mut EVP_PKEY,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_verify_cert(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_find_by_issuer_and_serial(
        sk: *mut stack_st_X509,
        name: *mut X509_NAME,
        serial: *mut ASN1_INTEGER,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_find_by_subject(sk: *mut stack_st_X509, name: *mut X509_NAME) -> *mut X509;
}
extern "C" {
    pub fn PBEPARAM_new() -> *mut PBEPARAM;
}
extern "C" {
    pub fn PBEPARAM_free(a: *mut PBEPARAM);
}
extern "C" {
    pub fn d2i_PBEPARAM(
        a: *mut *mut PBEPARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBEPARAM;
}
extern "C" {
    pub fn i2d_PBEPARAM(
        a: *mut PBEPARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PBEPARAM_it"]
    pub static PBEPARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn PBE2PARAM_new() -> *mut PBE2PARAM;
}
extern "C" {
    pub fn PBE2PARAM_free(a: *mut PBE2PARAM);
}
extern "C" {
    pub fn d2i_PBE2PARAM(
        a: *mut *mut PBE2PARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBE2PARAM;
}
extern "C" {
    pub fn i2d_PBE2PARAM(
        a: *mut PBE2PARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PBE2PARAM_it"]
    pub static PBE2PARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn PBKDF2PARAM_new() -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn PBKDF2PARAM_free(a: *mut PBKDF2PARAM);
}
extern "C" {
    pub fn d2i_PBKDF2PARAM(
        a: *mut *mut PBKDF2PARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn i2d_PBKDF2PARAM(
        a: *mut PBKDF2PARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PBKDF2PARAM_it"]
    pub static PBKDF2PARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS5_pbe_set0_algor(
        algor: *mut X509_ALGOR,
        alg: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_pbe_set(
        alg: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set(
        cipher: *const EVP_CIPHER,
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_iv(
        cipher: *const EVP_CIPHER,
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        aiv: *mut ::std::os::raw::c_uchar,
        prf_nid: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbkdf2_set(
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        prf_nid: ::std::os::raw::c_int,
        keylen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_new() -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_free(a: *mut PKCS8_PRIV_KEY_INFO);
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO(
        a: *mut *mut PKCS8_PRIV_KEY_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO(
        a: *mut PKCS8_PRIV_KEY_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}PKCS8_PRIV_KEY_INFO_it"]
    pub static PKCS8_PRIV_KEY_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn EVP_PKCS82PKEY(p8: *mut PKCS8_PRIV_KEY_INFO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8(pkey: *mut EVP_PKEY) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8_broken(
        pkey: *mut EVP_PKEY,
        broken: ::std::os::raw::c_int,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_set_broken(
        p8: *mut PKCS8_PRIV_KEY_INFO,
        broken: ::std::os::raw::c_int,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_pkey_set0(
        priv_: *mut PKCS8_PRIV_KEY_INFO,
        aobj: *mut ASN1_OBJECT,
        version: ::std::os::raw::c_int,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
        penc: *mut ::std::os::raw::c_uchar,
        penclen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_get0(
        ppkalg: *mut *mut ASN1_OBJECT,
        pk: *mut *const ::std::os::raw::c_uchar,
        ppklen: *mut ::std::os::raw::c_int,
        pa: *mut *mut X509_ALGOR,
        p8: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_set0_param(
        pub_: *mut X509_PUBKEY,
        aobj: *mut ASN1_OBJECT,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
        penc: *mut ::std::os::raw::c_uchar,
        penclen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0_param(
        ppkalg: *mut *mut ASN1_OBJECT,
        pk: *mut *const ::std::os::raw::c_uchar,
        ppklen: *mut ::std::os::raw::c_int,
        pa: *mut *mut X509_ALGOR,
        pub_: *mut X509_PUBKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_trust(
        x: *mut X509,
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0(idx: ::std::os::raw::c_int) -> *mut X509_TRUST;
}
extern "C" {
    pub fn X509_TRUST_get_by_id(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_add(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        ck: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut X509_TRUST,
                arg2: *mut X509,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        name: *mut ::std::os::raw::c_char,
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_cleanup();
}
extern "C" {
    pub fn X509_TRUST_get_flags(xp: *mut X509_TRUST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0_name(xp: *mut X509_TRUST) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_TRUST_get_trust(xp: *mut X509_TRUST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_X509_strings();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PEM_Encode_Seal_st {
    pub encode: EVP_ENCODE_CTX,
    pub md: EVP_MD_CTX,
    pub cipher: EVP_CIPHER_CTX,
}
#[test]
fn bindgen_test_layout_PEM_Encode_Seal_st() {
    assert_eq!(
        ::std::mem::size_of::<PEM_Encode_Seal_st>(),
        312usize,
        concat!("Size of: ", stringify!(PEM_Encode_Seal_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PEM_Encode_Seal_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PEM_Encode_Seal_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PEM_Encode_Seal_st>())).encode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PEM_Encode_Seal_st),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PEM_Encode_Seal_st>())).md as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PEM_Encode_Seal_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PEM_Encode_Seal_st>())).cipher as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PEM_Encode_Seal_st),
            "::",
            stringify!(cipher)
        )
    );
}
pub type PEM_ENCODE_SEAL_CTX = PEM_Encode_Seal_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pem_recip_st {
    pub name: *mut ::std::os::raw::c_char,
    pub dn: *mut X509_NAME,
    pub cipher: ::std::os::raw::c_int,
    pub key_enc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pem_recip_st() {
    assert_eq!(
        ::std::mem::size_of::<pem_recip_st>(),
        24usize,
        concat!("Size of: ", stringify!(pem_recip_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pem_recip_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pem_recip_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_recip_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_recip_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_recip_st>())).dn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_recip_st),
            "::",
            stringify!(dn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_recip_st>())).cipher as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_recip_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_recip_st>())).key_enc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_recip_st),
            "::",
            stringify!(key_enc)
        )
    );
}
pub type PEM_USER = pem_recip_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pem_ctx_st {
    pub type_: ::std::os::raw::c_int,
    pub proc_type: pem_ctx_st__bindgen_ty_1,
    pub domain: *mut ::std::os::raw::c_char,
    pub DEK_info: pem_ctx_st__bindgen_ty_2,
    pub originator: *mut PEM_USER,
    pub num_recipient: ::std::os::raw::c_int,
    pub recipient: *mut *mut PEM_USER,
    pub md: *mut EVP_MD,
    pub md_enc: ::std::os::raw::c_int,
    pub md_len: ::std::os::raw::c_int,
    pub md_data: *mut ::std::os::raw::c_char,
    pub dec: *mut EVP_CIPHER,
    pub key_len: ::std::os::raw::c_int,
    pub key: *mut ::std::os::raw::c_uchar,
    pub data_enc: ::std::os::raw::c_int,
    pub data_len: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pem_ctx_st__bindgen_ty_1 {
    pub version: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pem_ctx_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pem_ctx_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pem_ctx_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pem_ctx_st__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pem_ctx_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pem_ctx_st__bindgen_ty_1>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st__bindgen_ty_1>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st__bindgen_ty_1),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pem_ctx_st__bindgen_ty_2 {
    pub cipher: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pem_ctx_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<pem_ctx_st__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(pem_ctx_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<pem_ctx_st__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(pem_ctx_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st__bindgen_ty_2>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st__bindgen_ty_2),
            "::",
            stringify!(cipher)
        )
    );
}
#[test]
fn bindgen_test_layout_pem_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<pem_ctx_st>(),
        120usize,
        concat!("Size of: ", stringify!(pem_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pem_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pem_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).proc_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(proc_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).domain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).DEK_info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(DEK_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).originator as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(originator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).num_recipient as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(num_recipient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).recipient as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(recipient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).md as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).md_enc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(md_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).md_len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(md_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).md_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).dec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).key_len as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).key as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).data_enc as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(data_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).data_len as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pem_ctx_st>())).data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_ctx_st),
            "::",
            stringify!(data)
        )
    );
}
pub type PEM_CTX = pem_ctx_st;
pub type pem_password_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn PEM_get_EVP_CIPHER_INFO(
        header: *mut ::std::os::raw::c_char,
        cipher: *mut EVP_CIPHER_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_do_header(
        cipher: *mut EVP_CIPHER_INFO,
        data: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio(
        bp: *mut BIO,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio(
        bp: *mut BIO,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio(
        pdata: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_long,
        pnm: *mut *mut ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read_bio(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write_bio(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read_bio(
        bp: *mut BIO,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_write_bio(
        bp: *mut BIO,
        xi: *mut X509_INFO,
        enc: *mut EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cd: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read(
        fp: *mut FILE,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read(
        fp: *mut FILE,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_SealInit(
        ctx: *mut PEM_ENCODE_SEAL_CTX,
        type_: *mut EVP_CIPHER,
        md_type: *mut EVP_MD,
        ek: *mut *mut ::std::os::raw::c_uchar,
        ekl: *mut ::std::os::raw::c_int,
        iv: *mut ::std::os::raw::c_uchar,
        pubk: *mut *mut EVP_PKEY,
        npubk: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_SealUpdate(
        ctx: *mut PEM_ENCODE_SEAL_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *mut ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PEM_SealFinal(
        ctx: *mut PEM_ENCODE_SEAL_CTX,
        sig: *mut ::std::os::raw::c_uchar,
        sigl: *mut ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        priv_: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_SignInit(ctx: *mut EVP_MD_CTX, type_: *mut EVP_MD);
}
extern "C" {
    pub fn PEM_SignUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *mut ::std::os::raw::c_uchar,
        cnt: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn PEM_SignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_def_callback(
        buf: *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_proc_type(buf: *mut ::std::os::raw::c_char, type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PEM_dek_info(
        buf: *mut ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        str: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn PEM_read_bio_X509(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_AUX(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509_AUX(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509_AUX(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_AUX(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_CERT_PAIR(
        bp: *mut BIO,
        x: *mut *mut X509_CERT_PAIR,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CERT_PAIR;
}
extern "C" {
    pub fn PEM_read_X509_CERT_PAIR(
        fp: *mut FILE,
        x: *mut *mut X509_CERT_PAIR,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CERT_PAIR;
}
extern "C" {
    pub fn PEM_write_bio_X509_CERT_PAIR(
        bp: *mut BIO,
        x: *mut X509_CERT_PAIR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_CERT_PAIR(fp: *mut FILE, x: *mut X509_CERT_PAIR)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_REQ(
        bp: *mut BIO,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_read_X509_REQ(
        fp: *mut FILE,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ_NEW(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ_NEW(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_CRL(
        bp: *mut BIO,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_read_X509_CRL(
        fp: *mut FILE,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_write_bio_X509_CRL(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_CRL(fp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS7(
        bp: *mut BIO,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_read_PKCS7(
        fp: *mut FILE,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7(bp: *mut BIO, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS7(fp: *mut FILE, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_NETSCAPE_CERT_SEQUENCE(
        bp: *mut BIO,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_read_NETSCAPE_CERT_SEQUENCE(
        fp: *mut FILE,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_write_bio_NETSCAPE_CERT_SEQUENCE(
        bp: *mut BIO,
        x: *mut NETSCAPE_CERT_SEQUENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_NETSCAPE_CERT_SEQUENCE(
        fp: *mut FILE,
        x: *mut NETSCAPE_CERT_SEQUENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8(
        bp: *mut BIO,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_read_PKCS8(
        fp: *mut FILE,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8(bp: *mut BIO, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8(fp: *mut FILE, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_read_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPublicKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPublicKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPublicKey(bp: *mut BIO, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPublicKey(fp: *mut FILE, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSA_PUBKEY(bp: *mut BIO, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSA_PUBKEY(fp: *mut FILE, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSA_PUBKEY(bp: *mut BIO, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSA_PUBKEY(fp: *mut FILE, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAparams(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAparams(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAparams(bp: *mut BIO, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAparams(fp: *mut FILE, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPKParameters(
        bp: *mut BIO,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_read_ECPKParameters(
        fp: *mut FILE,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_write_bio_ECPKParameters(bp: *mut BIO, x: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_ECPKParameters(fp: *mut FILE, x: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_ECPrivateKey(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_ECPrivateKey(
        fp: *mut FILE,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_EC_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_EC_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_EC_PUBKEY(bp: *mut BIO, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_EC_PUBKEY(fp: *mut FILE, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DHparams(
        bp: *mut BIO,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_read_DHparams(
        fp: *mut FILE,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_write_bio_DHparams(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DHparams(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_DHxparams(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DHxparams(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PrivateKey(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PrivateKey(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PUBKEY(bp: *mut BIO, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PUBKEY(fp: *mut FILE, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey_nid(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey(
        arg1: *mut BIO,
        arg2: *mut EVP_PKEY,
        arg3: *const EVP_CIPHER,
        arg4: *mut ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
        arg6: pem_password_cb,
        arg7: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_bio(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_fp(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey_nid(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cd: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_Parameters(bp: *mut BIO, x: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_Parameters(bp: *mut BIO, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b2i_PrivateKey(
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey(
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PrivateKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PrivateKey_bio(out: *mut BIO, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2b_PublicKey_bio(out: *mut BIO, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b2i_PVK_bio(
        in_: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PVK_bio(
        out: *mut BIO,
        pk: *mut EVP_PKEY,
        enclevel: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_PEM_strings();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmac_ctx_st {
    pub md: *const EVP_MD,
    pub md_ctx: EVP_MD_CTX,
    pub i_ctx: EVP_MD_CTX,
    pub o_ctx: EVP_MD_CTX,
    pub key_length: ::std::os::raw::c_uint,
    pub key: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_hmac_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<hmac_ctx_st>(),
        288usize,
        concat!("Size of: ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hmac_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).i_ctx as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(i_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).o_ctx as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(o_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).key_length as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).key as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(key)
        )
    );
}
pub type HMAC_CTX = hmac_ctx_st;
extern "C" {
    pub fn HMAC_CTX_init(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_cleanup(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Update(
        ctx: *mut HMAC_CTX,
        data: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC(
        evp_md: *const EVP_MD,
        key: *const ::std::os::raw::c_void,
        key_len: ::std::os::raw::c_int,
        d: *const ::std::os::raw::c_uchar,
        n: usize,
        md: *mut ::std::os::raw::c_uchar,
        md_len: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMAC_CTX_copy(dctx: *mut HMAC_CTX, sctx: *mut HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_set_flags(ctx: *mut HMAC_CTX, flags: ::std::os::raw::c_ulong);
}
pub type ssl_crock_st = *mut ssl_st;
pub type TLS_SESSION_TICKET_EXT = tls_session_ticket_ext_st;
pub type SSL_METHOD = ssl_method_st;
pub type SSL_CIPHER = ssl_cipher_st;
pub type SSL_SESSION = ssl_session_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_sigalgs_st {
    _unused: [u8; 0],
}
pub type TLS_SIGALGS = tls_sigalgs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_conf_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CONF_CTX = ssl_conf_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_CIPHER {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_SSL_CIPHER() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_SSL_CIPHER>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_SSL_CIPHER))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_SSL_CIPHER>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_SSL_CIPHER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_SSL_CIPHER>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_SSL_CIPHER),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_protection_profile_st {
    pub name: *const ::std::os::raw::c_char,
    pub id: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_srtp_protection_profile_st() {
    assert_eq!(
        ::std::mem::size_of::<srtp_protection_profile_st>(),
        16usize,
        concat!("Size of: ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_protection_profile_st>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_protection_profile_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_protection_profile_st>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(id)
        )
    );
}
pub type SRTP_PROTECTION_PROFILE = srtp_protection_profile_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SRTP_PROTECTION_PROFILE {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_SRTP_PROTECTION_PROFILE() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_SRTP_PROTECTION_PROFILE>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_SRTP_PROTECTION_PROFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_SRTP_PROTECTION_PROFILE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(stack_st_SRTP_PROTECTION_PROFILE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stack_st_SRTP_PROTECTION_PROFILE>())).stack as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_SRTP_PROTECTION_PROFILE),
            "::",
            stringify!(stack)
        )
    );
}
pub type tls_session_ticket_ext_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type tls_session_secret_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        secret: *mut ::std::os::raw::c_void,
        secret_len: *mut ::std::os::raw::c_int,
        peer_ciphers: *mut stack_st_SSL_CIPHER,
        cipher: *mut *mut SSL_CIPHER,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type custom_ext_add_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut usize,
        al: *mut ::std::os::raw::c_int,
        add_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type custom_ext_free_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        out: *const ::std::os::raw::c_uchar,
        add_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type custom_ext_parse_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        in_: *const ::std::os::raw::c_uchar,
        inlen: usize,
        al: *mut ::std::os::raw::c_int,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_cipher_st {
    pub valid: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub id: ::std::os::raw::c_ulong,
    pub algorithm_mkey: ::std::os::raw::c_ulong,
    pub algorithm_auth: ::std::os::raw::c_ulong,
    pub algorithm_enc: ::std::os::raw::c_ulong,
    pub algorithm_mac: ::std::os::raw::c_ulong,
    pub algorithm_ssl: ::std::os::raw::c_ulong,
    pub algo_strength: ::std::os::raw::c_ulong,
    pub algorithm2: ::std::os::raw::c_ulong,
    pub strength_bits: ::std::os::raw::c_int,
    pub alg_bits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ssl_cipher_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_cipher_st>(),
        88usize,
        concat!("Size of: ", stringify!(ssl_cipher_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_cipher_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cipher_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm_mkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm_mkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm_auth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm_enc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm_mac as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm_ssl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm_ssl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algo_strength as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algo_strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).algorithm2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(algorithm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).strength_bits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(strength_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_cipher_st>())).alg_bits as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cipher_st),
            "::",
            stringify!(alg_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_method_st {
    pub version: ::std::os::raw::c_int,
    pub ssl_new: ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_clear: ::std::option::Option<unsafe extern "C" fn(s: *mut SSL)>,
    pub ssl_free: ::std::option::Option<unsafe extern "C" fn(s: *mut SSL)>,
    pub ssl_accept:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_connect:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_read: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            buf: *mut ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_peek: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            buf: *mut ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_write: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            buf: *const ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_shutdown:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_renegotiate:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_renegotiate_check:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_get_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            st1: ::std::os::raw::c_int,
            stn: ::std::os::raw::c_int,
            mt: ::std::os::raw::c_int,
            max: ::std::os::raw::c_long,
            ok: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long,
    >,
    pub ssl_read_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            type_: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_uchar,
            len: ::std::os::raw::c_int,
            peek: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_write_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            type_: ::std::os::raw::c_int,
            buf_: *const ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_dispatch_alert:
        ::std::option::Option<unsafe extern "C" fn(s: *mut SSL) -> ::std::os::raw::c_int>,
    pub ssl_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            cmd: ::std::os::raw::c_int,
            larg: ::std::os::raw::c_long,
            parg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >,
    pub ssl_ctx_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut SSL_CTX,
            cmd: ::std::os::raw::c_int,
            larg: ::std::os::raw::c_long,
            parg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >,
    pub get_cipher_by_char: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_uchar) -> *const SSL_CIPHER,
    >,
    pub put_cipher_by_char: ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *const SSL_CIPHER,
            ptr: *mut ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
    >,
    pub ssl_pending:
        ::std::option::Option<unsafe extern "C" fn(s: *const SSL) -> ::std::os::raw::c_int>,
    pub num_ciphers: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub get_cipher: ::std::option::Option<
        unsafe extern "C" fn(ncipher: ::std::os::raw::c_uint) -> *const SSL_CIPHER,
    >,
    pub get_ssl_method: ::std::option::Option<
        unsafe extern "C" fn(version: ::std::os::raw::c_int) -> *const ssl_method_st,
    >,
    pub get_timeout: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
    pub ssl3_enc: *mut ssl3_enc_method,
    pub ssl_version: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub ssl_callback_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            cb_id: ::std::os::raw::c_int,
            fp: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_long,
    >,
    pub ssl_ctx_callback_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL_CTX,
            cb_id: ::std::os::raw::c_int,
            fp: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout_ssl_method_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_method_st>(),
        232usize,
        concat!("Size of: ", stringify!(ssl_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_method_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_new as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_clear as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_accept as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_connect as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_read as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_peek as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_peek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_write as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_shutdown as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_renegotiate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_renegotiate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_method_st>())).ssl_renegotiate_check as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_renegotiate_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_get_message as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_get_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_read_bytes as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_write_bytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_method_st>())).ssl_dispatch_alert as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_dispatch_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_ctrl as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_ctx_ctrl as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_ctx_ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_method_st>())).get_cipher_by_char as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(get_cipher_by_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_method_st>())).put_cipher_by_char as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(put_cipher_by_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_pending as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).num_ciphers as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(num_ciphers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).get_cipher as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(get_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).get_ssl_method as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(get_ssl_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).get_timeout as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(get_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl3_enc as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl3_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_version as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_method_st>())).ssl_callback_ctrl as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_callback_ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_method_st>())).ssl_ctx_callback_ctrl as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_method_st),
            "::",
            stringify!(ssl_ctx_callback_ctrl)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_session_st {
    pub ssl_version: ::std::os::raw::c_int,
    pub key_arg_length: ::std::os::raw::c_uint,
    pub key_arg: [::std::os::raw::c_uchar; 8usize],
    pub master_key_length: ::std::os::raw::c_int,
    pub master_key: [::std::os::raw::c_uchar; 48usize],
    pub session_id_length: ::std::os::raw::c_uint,
    pub session_id: [::std::os::raw::c_uchar; 32usize],
    pub sid_ctx_length: ::std::os::raw::c_uint,
    pub sid_ctx: [::std::os::raw::c_uchar; 32usize],
    pub psk_identity_hint: *mut ::std::os::raw::c_char,
    pub psk_identity: *mut ::std::os::raw::c_char,
    pub not_resumable: ::std::os::raw::c_int,
    pub sess_cert: *mut sess_cert_st,
    pub peer: *mut X509,
    pub verify_result: ::std::os::raw::c_long,
    pub references: ::std::os::raw::c_int,
    pub timeout: ::std::os::raw::c_long,
    pub time: ::std::os::raw::c_long,
    pub compress_meth: ::std::os::raw::c_uint,
    pub cipher: *const SSL_CIPHER,
    pub cipher_id: ::std::os::raw::c_ulong,
    pub ciphers: *mut stack_st_SSL_CIPHER,
    pub ex_data: CRYPTO_EX_DATA,
    pub prev: *mut ssl_session_st,
    pub next: *mut ssl_session_st,
    pub tlsext_hostname: *mut ::std::os::raw::c_char,
    pub tlsext_ecpointformatlist_length: usize,
    pub tlsext_ecpointformatlist: *mut ::std::os::raw::c_uchar,
    pub tlsext_ellipticcurvelist_length: usize,
    pub tlsext_ellipticcurvelist: *mut ::std::os::raw::c_uchar,
    pub tlsext_tick: *mut ::std::os::raw::c_uchar,
    pub tlsext_ticklen: usize,
    pub tlsext_tick_lifetime_hint: ::std::os::raw::c_long,
    pub srp_username: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ssl_session_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_session_st>(),
        352usize,
        concat!("Size of: ", stringify!(ssl_session_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_session_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_session_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).ssl_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(ssl_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).key_arg_length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(key_arg_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).key_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(key_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).master_key_length as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(master_key_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).master_key as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(master_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).session_id_length as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(session_id_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).session_id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).sid_ctx_length as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(sid_ctx_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).sid_ctx as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(sid_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).psk_identity_hint as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(psk_identity_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).psk_identity as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(psk_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).not_resumable as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(not_resumable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).sess_cert as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(sess_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).peer as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(peer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).verify_result as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(verify_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).references as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).timeout as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).time as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).compress_meth as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(compress_meth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).cipher as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).cipher_id as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(cipher_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).ciphers as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(ciphers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).ex_data as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).prev as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).next as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).tlsext_hostname as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_hostname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).tlsext_ecpointformatlist_length as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_ecpointformatlist_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).tlsext_ecpointformatlist as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_ecpointformatlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).tlsext_ellipticcurvelist_length as *const _
                as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_ellipticcurvelist_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).tlsext_ellipticcurvelist as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_ellipticcurvelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).tlsext_tick as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).tlsext_ticklen as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_ticklen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_session_st>())).tlsext_tick_lifetime_hint as *const _
                as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(tlsext_tick_lifetime_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_session_st>())).srp_username as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session_st),
            "::",
            stringify!(srp_username)
        )
    );
}
extern "C" {
    pub fn SSL_CTX_set_msg_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                write_p: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_set_msg_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                write_p: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srp_ctx_st {
    pub SRP_cb_arg: *mut ::std::os::raw::c_void,
    pub TLS_ext_srp_username_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SSL,
            arg2: *mut ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub SRP_verify_param_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SSL,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub SRP_give_srp_client_pwd_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SSL,
            arg2: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub login: *mut ::std::os::raw::c_char,
    pub N: *mut BIGNUM,
    pub g: *mut BIGNUM,
    pub s: *mut BIGNUM,
    pub B: *mut BIGNUM,
    pub A: *mut BIGNUM,
    pub a: *mut BIGNUM,
    pub b: *mut BIGNUM,
    pub v: *mut BIGNUM,
    pub info: *mut ::std::os::raw::c_char,
    pub strength: ::std::os::raw::c_int,
    pub srp_Mask: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_srp_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<srp_ctx_st>(),
        128usize,
        concat!("Size of: ", stringify!(srp_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<srp_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(srp_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).SRP_cb_arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(SRP_cb_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srp_ctx_st>())).TLS_ext_srp_username_callback as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(TLS_ext_srp_username_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srp_ctx_st>())).SRP_verify_param_callback as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(SRP_verify_param_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srp_ctx_st>())).SRP_give_srp_client_pwd_callback as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(SRP_give_srp_client_pwd_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).login as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(login)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).N as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).g as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).s as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).B as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).A as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).a as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).b as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).v as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).info as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).strength as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srp_ctx_st>())).srp_Mask as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(srp_ctx_st),
            "::",
            stringify!(srp_Mask)
        )
    );
}
pub type SRP_CTX = srp_ctx_st;
extern "C" {
    pub fn SSL_SRP_CTX_init(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_init(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SRP_CTX_free(ctx: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_free(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_srp_server_param_with_username(
        s: *mut SSL,
        ad: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SRP_generate_server_master_secret(
        s: *mut SSL,
        master_key: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SRP_Calc_A_param(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SRP_generate_client_master_secret(
        s: *mut SSL,
        master_key: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
pub type GEN_SESSION_CB = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *const SSL,
        id: *mut ::std::os::raw::c_uchar,
        id_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_COMP = ssl_comp_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_comp_st {
    pub id: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub method: *mut COMP_METHOD,
}
#[test]
fn bindgen_test_layout_ssl_comp_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_comp_st>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_comp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_comp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_comp_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_comp_st>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_comp_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_comp_st>())).method as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(method)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_COMP {
    pub stack: _STACK,
}
#[test]
fn bindgen_test_layout_stack_st_SSL_COMP() {
    assert_eq!(
        ::std::mem::size_of::<stack_st_SSL_COMP>(),
        32usize,
        concat!("Size of: ", stringify!(stack_st_SSL_COMP))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_st_SSL_COMP>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_st_SSL_COMP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_st_SSL_COMP>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_st_SSL_COMP),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_SSL_SESSION {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_SSL_SESSION() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_SSL_SESSION>(),
        4usize,
        concat!("Size of: ", stringify!(lhash_st_SSL_SESSION))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_SSL_SESSION>(),
        4usize,
        concat!("Alignment of ", stringify!(lhash_st_SSL_SESSION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_SSL_SESSION>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_SSL_SESSION),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st {
    pub method: *const SSL_METHOD,
    pub cipher_list: *mut stack_st_SSL_CIPHER,
    pub cipher_list_by_id: *mut stack_st_SSL_CIPHER,
    pub cert_store: *mut x509_store_st,
    pub sessions: *mut lhash_st_SSL_SESSION,
    pub session_cache_size: ::std::os::raw::c_ulong,
    pub session_cache_head: *mut ssl_session_st,
    pub session_cache_tail: *mut ssl_session_st,
    pub session_cache_mode: ::std::os::raw::c_int,
    pub session_timeout: ::std::os::raw::c_long,
    pub new_session_cb: ::std::option::Option<
        unsafe extern "C" fn(ssl: *mut ssl_st, sess: *mut SSL_SESSION) -> ::std::os::raw::c_int,
    >,
    pub remove_session_cb:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut ssl_ctx_st, sess: *mut SSL_SESSION)>,
    pub get_session_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut ssl_st,
            data: *mut ::std::os::raw::c_uchar,
            len: ::std::os::raw::c_int,
            copy: *mut ::std::os::raw::c_int,
        ) -> *mut SSL_SESSION,
    >,
    pub stats: ssl_ctx_st__bindgen_ty_1,
    pub references: ::std::os::raw::c_int,
    pub app_verify_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut X509_STORE_CTX,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub app_verify_arg: *mut ::std::os::raw::c_void,
    pub default_passwd_callback: pem_password_cb,
    pub default_passwd_callback_userdata: *mut ::std::os::raw::c_void,
    pub client_cert_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            x509: *mut *mut X509,
            pkey: *mut *mut EVP_PKEY,
        ) -> ::std::os::raw::c_int,
    >,
    pub app_gen_cookie_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            cookie: *mut ::std::os::raw::c_uchar,
            cookie_len: *mut ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub app_verify_cookie_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            cookie: *mut ::std::os::raw::c_uchar,
            cookie_len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub ex_data: CRYPTO_EX_DATA,
    pub rsa_md5: *const EVP_MD,
    pub md5: *const EVP_MD,
    pub sha1: *const EVP_MD,
    pub extra_certs: *mut stack_st_X509,
    pub comp_methods: *mut stack_st_SSL_COMP,
    pub info_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *const SSL,
            type_: ::std::os::raw::c_int,
            val: ::std::os::raw::c_int,
        ),
    >,
    pub client_CA: *mut stack_st_X509_NAME,
    pub options: ::std::os::raw::c_ulong,
    pub mode: ::std::os::raw::c_ulong,
    pub max_cert_list: ::std::os::raw::c_long,
    pub cert: *mut cert_st,
    pub read_ahead: ::std::os::raw::c_int,
    pub msg_callback: ::std::option::Option<
        unsafe extern "C" fn(
            write_p: ::std::os::raw::c_int,
            version: ::std::os::raw::c_int,
            content_type: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            len: usize,
            ssl: *mut SSL,
            arg: *mut ::std::os::raw::c_void,
        ),
    >,
    pub msg_callback_arg: *mut ::std::os::raw::c_void,
    pub verify_mode: ::std::os::raw::c_int,
    pub sid_ctx_length: ::std::os::raw::c_uint,
    pub sid_ctx: [::std::os::raw::c_uchar; 32usize],
    pub default_verify_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ok: ::std::os::raw::c_int,
            ctx: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub generate_session_id: GEN_SESSION_CB,
    pub param: *mut X509_VERIFY_PARAM,
    pub quiet_shutdown: ::std::os::raw::c_int,
    pub max_send_fragment: ::std::os::raw::c_uint,
    pub client_cert_engine: *mut ENGINE,
    pub tlsext_servername_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SSL,
            arg2: *mut ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub tlsext_servername_arg: *mut ::std::os::raw::c_void,
    pub tlsext_tick_key_name: [::std::os::raw::c_uchar; 16usize],
    pub tlsext_tick_hmac_key: [::std::os::raw::c_uchar; 16usize],
    pub tlsext_tick_aes_key: [::std::os::raw::c_uchar; 16usize],
    pub tlsext_ticket_key_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            name: *mut ::std::os::raw::c_uchar,
            iv: *mut ::std::os::raw::c_uchar,
            ectx: *mut EVP_CIPHER_CTX,
            hctx: *mut HMAC_CTX,
            enc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tlsext_status_cb: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub tlsext_status_arg: *mut ::std::os::raw::c_void,
    pub tlsext_opaque_prf_input_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SSL,
            peerinput: *mut ::std::os::raw::c_void,
            len: usize,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub tlsext_opaque_prf_input_callback_arg: *mut ::std::os::raw::c_void,
    pub psk_identity_hint: *mut ::std::os::raw::c_char,
    pub psk_client_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            hint: *const ::std::os::raw::c_char,
            identity: *mut ::std::os::raw::c_char,
            max_identity_len: ::std::os::raw::c_uint,
            psk: *mut ::std::os::raw::c_uchar,
            max_psk_len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub psk_server_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            identity: *const ::std::os::raw::c_char,
            psk: *mut ::std::os::raw::c_uchar,
            max_psk_len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub freelist_max_len: ::std::os::raw::c_uint,
    pub wbuf_freelist: *mut ssl3_buf_freelist_st,
    pub rbuf_freelist: *mut ssl3_buf_freelist_st,
    pub srp_ctx: SRP_CTX,
    pub next_protos_advertised_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            buf: *mut *const ::std::os::raw::c_uchar,
            len: *mut ::std::os::raw::c_uint,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_protos_advertised_cb_arg: *mut ::std::os::raw::c_void,
    pub next_proto_select_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            out: *mut *mut ::std::os::raw::c_uchar,
            outlen: *mut ::std::os::raw::c_uchar,
            in_: *const ::std::os::raw::c_uchar,
            inlen: ::std::os::raw::c_uint,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_proto_select_cb_arg: *mut ::std::os::raw::c_void,
    pub srtp_profiles: *mut stack_st_SRTP_PROTECTION_PROFILE,
    pub alpn_select_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            out: *mut *const ::std::os::raw::c_uchar,
            outlen: *mut ::std::os::raw::c_uchar,
            in_: *const ::std::os::raw::c_uchar,
            inlen: ::std::os::raw::c_uint,
            arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub alpn_select_cb_arg: *mut ::std::os::raw::c_void,
    pub alpn_client_proto_list: *mut ::std::os::raw::c_uchar,
    pub alpn_client_proto_list_len: ::std::os::raw::c_uint,
    pub tlsext_ecpointformatlist_length: usize,
    pub tlsext_ecpointformatlist: *mut ::std::os::raw::c_uchar,
    pub tlsext_ellipticcurvelist_length: usize,
    pub tlsext_ellipticcurvelist: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st__bindgen_ty_1 {
    pub sess_connect: ::std::os::raw::c_int,
    pub sess_connect_renegotiate: ::std::os::raw::c_int,
    pub sess_connect_good: ::std::os::raw::c_int,
    pub sess_accept: ::std::os::raw::c_int,
    pub sess_accept_renegotiate: ::std::os::raw::c_int,
    pub sess_accept_good: ::std::os::raw::c_int,
    pub sess_miss: ::std::os::raw::c_int,
    pub sess_timeout: ::std::os::raw::c_int,
    pub sess_cache_full: ::std::os::raw::c_int,
    pub sess_hit: ::std::os::raw::c_int,
    pub sess_cb_hit: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ssl_ctx_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ssl_ctx_st__bindgen_ty_1>(),
        44usize,
        concat!("Size of: ", stringify!(ssl_ctx_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_ctx_st__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_ctx_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_connect as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_connect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_connect_renegotiate
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_connect_renegotiate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_connect_good as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_connect_good)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_accept as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_accept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_accept_renegotiate as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_accept_renegotiate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_accept_good as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_accept_good)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_miss as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_miss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_timeout as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_cache_full as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_cache_full)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_hit as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_hit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st__bindgen_ty_1>())).sess_cb_hit as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st__bindgen_ty_1),
            "::",
            stringify!(sess_cb_hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ssl_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_ctx_st>(),
        800usize,
        concat!("Size of: ", stringify!(ssl_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).cipher_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(cipher_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).cipher_list_by_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(cipher_list_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).cert_store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(cert_store)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).sessions as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(sessions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).session_cache_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(session_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).session_cache_head as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(session_cache_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).session_cache_tail as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(session_cache_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).session_cache_mode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(session_cache_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).session_timeout as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(session_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).new_session_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(new_session_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).remove_session_cb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(remove_session_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).get_session_cb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(get_session_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).stats as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).references as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).app_verify_callback as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(app_verify_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).app_verify_arg as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(app_verify_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).default_passwd_callback as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(default_passwd_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).default_passwd_callback_userdata as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(default_passwd_callback_userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).client_cert_cb as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(client_cert_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).app_gen_cookie_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(app_gen_cookie_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).app_verify_cookie_cb as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(app_verify_cookie_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).ex_data as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).rsa_md5 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(rsa_md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).md5 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).sha1 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(sha1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).extra_certs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(extra_certs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).comp_methods as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(comp_methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).info_callback as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(info_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).client_CA as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(client_CA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).options as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).mode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).max_cert_list as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(max_cert_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).cert as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).read_ahead as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(read_ahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).msg_callback as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(msg_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).msg_callback_arg as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(msg_callback_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).verify_mode as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(verify_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).sid_ctx_length as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(sid_ctx_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).sid_ctx as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(sid_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).default_verify_callback as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(default_verify_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).generate_session_id as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(generate_session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).param as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).quiet_shutdown as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(quiet_shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).max_send_fragment as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(max_send_fragment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).client_cert_engine as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(client_cert_engine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_servername_callback as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_servername_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_servername_arg as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_servername_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_tick_key_name as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_tick_key_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_tick_hmac_key as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_tick_hmac_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_tick_aes_key as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_tick_aes_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_ticket_key_cb as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_ticket_key_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_status_cb as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_status_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_status_arg as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_status_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_opaque_prf_input_callback as *const _
                as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_opaque_prf_input_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_opaque_prf_input_callback_arg as *const _
                as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_opaque_prf_input_callback_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).psk_identity_hint as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(psk_identity_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).psk_client_callback as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(psk_client_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).psk_server_callback as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(psk_server_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).freelist_max_len as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(freelist_max_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).wbuf_freelist as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(wbuf_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).rbuf_freelist as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(rbuf_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).srp_ctx as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(srp_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).next_protos_advertised_cb as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(next_protos_advertised_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).next_protos_advertised_cb_arg as *const _
                as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(next_protos_advertised_cb_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).next_proto_select_cb as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(next_proto_select_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).next_proto_select_cb_arg as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(next_proto_select_cb_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).srtp_profiles as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(srtp_profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).alpn_select_cb as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(alpn_select_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_ctx_st>())).alpn_select_cb_arg as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(alpn_select_cb_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).alpn_client_proto_list as *const _ as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(alpn_client_proto_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).alpn_client_proto_list_len as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(alpn_client_proto_list_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_ecpointformatlist_length as *const _
                as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_ecpointformatlist_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_ecpointformatlist as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_ecpointformatlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_ellipticcurvelist_length as *const _
                as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_ellipticcurvelist_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_ctx_st>())).tlsext_ellipticcurvelist as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ctx_st),
            "::",
            stringify!(tlsext_ellipticcurvelist)
        )
    );
}
extern "C" {
    pub fn SSL_CTX_sessions(ctx: *mut SSL_CTX) -> *mut lhash_st_SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_sess_set_new_cb(
        ctx: *mut SSL_CTX,
        new_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ssl: *mut ssl_st, sess: *mut SSL_SESSION) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_new_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_remove_cb(
        ctx: *mut SSL_CTX,
        remove_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut ssl_ctx_st, sess: *mut SSL_SESSION),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_remove_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX)>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_get_cb(
        ctx: *mut SSL_CTX,
        get_session_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut ssl_st,
                data: *mut ::std::os::raw::c_uchar,
                len: ::std::os::raw::c_int,
                copy: *mut ::std::os::raw::c_int,
            ) -> *mut SSL_SESSION,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_get_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX) -> *mut SSL_SESSION>;
}
extern "C" {
    pub fn SSL_CTX_set_info_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                val: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_info_callback(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX)>;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_cb(
        ctx: *mut SSL_CTX,
        client_cert_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                x509: *mut *mut X509,
                pkey: *mut *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_client_cert_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_engine(
        ctx: *mut SSL_CTX,
        e: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cookie_generate_cb(
        ctx: *mut SSL_CTX,
        app_gen_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::std::os::raw::c_uchar,
                cookie_len: *mut ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cookie_verify_cb(
        ctx: *mut SSL_CTX,
        app_verify_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::std::os::raw::c_uchar,
                cookie_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_next_protos_advertised_cb(
        s: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *const ::std::os::raw::c_uchar,
                outlen: *mut ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_set_next_proto_select_cb(
        s: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *mut ::std::os::raw::c_uchar,
                outlen: *mut ::std::os::raw::c_uchar,
                in_: *const ::std::os::raw::c_uchar,
                inlen: ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_next_proto_negotiated(
        s: *const SSL,
        data: *mut *const ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SSL_select_next_proto(
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_uint,
        client: *const ::std::os::raw::c_uchar,
        client_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_protos(
        ctx: *mut SSL_CTX,
        protos: *const ::std::os::raw::c_uchar,
        protos_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_alpn_protos(
        ssl: *mut SSL,
        protos: *const ::std::os::raw::c_uchar,
        protos_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_select_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *const ::std::os::raw::c_uchar,
                outlen: *mut ::std::os::raw::c_uchar,
                in_: *const ::std::os::raw::c_uchar,
                inlen: ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_alpn_selected(
        ssl: *const SSL,
        data: *mut *const ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SSL_CTX_set_psk_client_callback(
        ctx: *mut SSL_CTX,
        psk_client_callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                hint: *const ::std::os::raw::c_char,
                identity: *mut ::std::os::raw::c_char,
                max_identity_len: ::std::os::raw::c_uint,
                psk: *mut ::std::os::raw::c_uchar,
                max_psk_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
    );
}
extern "C" {
    pub fn SSL_set_psk_client_callback(
        ssl: *mut SSL,
        psk_client_callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                hint: *const ::std::os::raw::c_char,
                identity: *mut ::std::os::raw::c_char,
                max_identity_len: ::std::os::raw::c_uint,
                psk: *mut ::std::os::raw::c_uchar,
                max_psk_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_psk_server_callback(
        ctx: *mut SSL_CTX,
        psk_server_callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                identity: *const ::std::os::raw::c_char,
                psk: *mut ::std::os::raw::c_uchar,
                max_psk_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
    );
}
extern "C" {
    pub fn SSL_set_psk_server_callback(
        ssl: *mut SSL,
        psk_server_callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                identity: *const ::std::os::raw::c_char,
                psk: *mut ::std::os::raw::c_uchar,
                max_psk_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_uint,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_use_psk_identity_hint(
        ctx: *mut SSL_CTX,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_psk_identity_hint(
        s: *mut SSL,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_psk_identity_hint(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_psk_identity(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CTX_add_client_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_server_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_extension_supported(ext_type: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    pub version: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub method: *const SSL_METHOD,
    pub rbio: *mut BIO,
    pub wbio: *mut BIO,
    pub bbio: *mut BIO,
    pub rwstate: ::std::os::raw::c_int,
    pub in_handshake: ::std::os::raw::c_int,
    pub handshake_func:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut SSL) -> ::std::os::raw::c_int>,
    pub server: ::std::os::raw::c_int,
    pub new_session: ::std::os::raw::c_int,
    pub quiet_shutdown: ::std::os::raw::c_int,
    pub shutdown: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_int,
    pub rstate: ::std::os::raw::c_int,
    pub init_buf: *mut BUF_MEM,
    pub init_msg: *mut ::std::os::raw::c_void,
    pub init_num: ::std::os::raw::c_int,
    pub init_off: ::std::os::raw::c_int,
    pub packet: *mut ::std::os::raw::c_uchar,
    pub packet_length: ::std::os::raw::c_uint,
    pub s2: *mut ssl2_state_st,
    pub s3: *mut ssl3_state_st,
    pub d1: *mut dtls1_state_st,
    pub read_ahead: ::std::os::raw::c_int,
    pub msg_callback: ::std::option::Option<
        unsafe extern "C" fn(
            write_p: ::std::os::raw::c_int,
            version: ::std::os::raw::c_int,
            content_type: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            len: usize,
            ssl: *mut SSL,
            arg: *mut ::std::os::raw::c_void,
        ),
    >,
    pub msg_callback_arg: *mut ::std::os::raw::c_void,
    pub hit: ::std::os::raw::c_int,
    pub param: *mut X509_VERIFY_PARAM,
    pub cipher_list: *mut stack_st_SSL_CIPHER,
    pub cipher_list_by_id: *mut stack_st_SSL_CIPHER,
    pub mac_flags: ::std::os::raw::c_int,
    pub enc_read_ctx: *mut EVP_CIPHER_CTX,
    pub read_hash: *mut EVP_MD_CTX,
    pub expand: *mut COMP_CTX,
    pub enc_write_ctx: *mut EVP_CIPHER_CTX,
    pub write_hash: *mut EVP_MD_CTX,
    pub compress: *mut COMP_CTX,
    pub cert: *mut cert_st,
    pub sid_ctx_length: ::std::os::raw::c_uint,
    pub sid_ctx: [::std::os::raw::c_uchar; 32usize],
    pub session: *mut SSL_SESSION,
    pub generate_session_id: GEN_SESSION_CB,
    pub verify_mode: ::std::os::raw::c_int,
    pub verify_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ok: ::std::os::raw::c_int,
            ctx: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >,
    pub info_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *const SSL,
            type_: ::std::os::raw::c_int,
            val: ::std::os::raw::c_int,
        ),
    >,
    pub error: ::std::os::raw::c_int,
    pub error_code: ::std::os::raw::c_int,
    pub psk_client_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            hint: *const ::std::os::raw::c_char,
            identity: *mut ::std::os::raw::c_char,
            max_identity_len: ::std::os::raw::c_uint,
            psk: *mut ::std::os::raw::c_uchar,
            max_psk_len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub psk_server_callback: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            identity: *const ::std::os::raw::c_char,
            psk: *mut ::std::os::raw::c_uchar,
            max_psk_len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub ctx: *mut SSL_CTX,
    pub debug: ::std::os::raw::c_int,
    pub verify_result: ::std::os::raw::c_long,
    pub ex_data: CRYPTO_EX_DATA,
    pub client_CA: *mut stack_st_X509_NAME,
    pub references: ::std::os::raw::c_int,
    pub options: ::std::os::raw::c_ulong,
    pub mode: ::std::os::raw::c_ulong,
    pub max_cert_list: ::std::os::raw::c_long,
    pub first_packet: ::std::os::raw::c_int,
    pub client_version: ::std::os::raw::c_int,
    pub max_send_fragment: ::std::os::raw::c_uint,
    pub tlsext_debug_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut SSL,
            client_server: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_uchar,
            len: ::std::os::raw::c_int,
            arg: *mut ::std::os::raw::c_void,
        ),
    >,
    pub tlsext_debug_arg: *mut ::std::os::raw::c_void,
    pub tlsext_hostname: *mut ::std::os::raw::c_char,
    pub servername_done: ::std::os::raw::c_int,
    pub tlsext_status_type: ::std::os::raw::c_int,
    pub tlsext_status_expected: ::std::os::raw::c_int,
    pub tlsext_ocsp_ids: *mut stack_st_OCSP_RESPID,
    pub tlsext_ocsp_exts: *mut X509_EXTENSIONS,
    pub tlsext_ocsp_resp: *mut ::std::os::raw::c_uchar,
    pub tlsext_ocsp_resplen: ::std::os::raw::c_int,
    pub tlsext_ticket_expected: ::std::os::raw::c_int,
    pub tlsext_ecpointformatlist_length: usize,
    pub tlsext_ecpointformatlist: *mut ::std::os::raw::c_uchar,
    pub tlsext_ellipticcurvelist_length: usize,
    pub tlsext_ellipticcurvelist: *mut ::std::os::raw::c_uchar,
    pub tlsext_opaque_prf_input: *mut ::std::os::raw::c_void,
    pub tlsext_opaque_prf_input_len: usize,
    pub tlsext_session_ticket: *mut TLS_SESSION_TICKET_EXT,
    pub tls_session_ticket_ext_cb: tls_session_ticket_ext_cb_fn,
    pub tls_session_ticket_ext_cb_arg: *mut ::std::os::raw::c_void,
    pub tls_session_secret_cb: tls_session_secret_cb_fn,
    pub tls_session_secret_cb_arg: *mut ::std::os::raw::c_void,
    pub initial_ctx: *mut SSL_CTX,
    pub next_proto_negotiated: *mut ::std::os::raw::c_uchar,
    pub next_proto_negotiated_len: ::std::os::raw::c_uchar,
    pub srtp_profiles: *mut stack_st_SRTP_PROTECTION_PROFILE,
    pub srtp_profile: *mut SRTP_PROTECTION_PROFILE,
    pub tlsext_heartbeat: ::std::os::raw::c_uint,
    pub tlsext_hb_pending: ::std::os::raw::c_uint,
    pub tlsext_hb_seq: ::std::os::raw::c_uint,
    pub renegotiate: ::std::os::raw::c_int,
    pub srp_ctx: SRP_CTX,
    pub alpn_client_proto_list: *mut ::std::os::raw::c_uchar,
    pub alpn_client_proto_list_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ssl_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl_st>(),
        824usize,
        concat!("Size of: ", stringify!(ssl_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).rbio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(rbio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).wbio as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(wbio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).bbio as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(bbio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).rwstate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(rwstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).in_handshake as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(in_handshake)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).handshake_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(handshake_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).server as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).new_session as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(new_session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).quiet_shutdown as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(quiet_shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).shutdown as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).rstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(rstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).init_buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(init_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).init_msg as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(init_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).init_num as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(init_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).init_off as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(init_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).packet as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).packet_length as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(packet_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).s2 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(s2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).s3 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(s3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).d1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).read_ahead as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(read_ahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).msg_callback as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(msg_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).msg_callback_arg as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(msg_callback_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).hit as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(hit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).param as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).cipher_list as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(cipher_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).cipher_list_by_id as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(cipher_list_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).mac_flags as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(mac_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).enc_read_ctx as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(enc_read_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).read_hash as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(read_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).expand as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(expand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).enc_write_ctx as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(enc_write_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).write_hash as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(write_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).compress as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).cert as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).sid_ctx_length as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(sid_ctx_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).sid_ctx as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(sid_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).session as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).generate_session_id as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(generate_session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).verify_mode as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(verify_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).verify_callback as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(verify_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).info_callback as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(info_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).error as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).error_code as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).psk_client_callback as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(psk_client_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).psk_server_callback as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(psk_server_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).ctx as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).debug as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).verify_result as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(verify_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).ex_data as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).client_CA as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(client_CA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).references as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).options as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).mode as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).max_cert_list as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(max_cert_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).first_packet as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(first_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).client_version as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(client_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).max_send_fragment as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(max_send_fragment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_debug_cb as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_debug_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_debug_arg as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_debug_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_hostname as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).servername_done as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(servername_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_status_type as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_status_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_status_expected as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_status_expected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ocsp_ids as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ocsp_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ocsp_exts as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ocsp_exts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ocsp_resp as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ocsp_resp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ocsp_resplen as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ocsp_resplen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ticket_expected as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ticket_expected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tlsext_ecpointformatlist_length as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ecpointformatlist_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ecpointformatlist as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ecpointformatlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tlsext_ellipticcurvelist_length as *const _ as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ellipticcurvelist_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_ellipticcurvelist as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_ellipticcurvelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_opaque_prf_input as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_opaque_prf_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tlsext_opaque_prf_input_len as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_opaque_prf_input_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_session_ticket as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_session_ticket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tls_session_ticket_ext_cb as *const _ as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tls_session_ticket_ext_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tls_session_ticket_ext_cb_arg as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tls_session_ticket_ext_cb_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tls_session_secret_cb as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tls_session_secret_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).tls_session_secret_cb_arg as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tls_session_secret_cb_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).initial_ctx as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(initial_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).next_proto_negotiated as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(next_proto_negotiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).next_proto_negotiated_len as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(next_proto_negotiated_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).srtp_profiles as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(srtp_profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).srtp_profile as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(srtp_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_heartbeat as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_heartbeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_hb_pending as *const _ as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_hb_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).tlsext_hb_seq as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(tlsext_hb_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).renegotiate as *const _ as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(renegotiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).srp_ctx as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(srp_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl_st>())).alpn_client_proto_list as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(alpn_client_proto_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl_st>())).alpn_client_proto_list_len as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_st),
            "::",
            stringify!(alpn_client_proto_list_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl2_state_st {
    pub three_byte_header: ::std::os::raw::c_int,
    pub clear_text: ::std::os::raw::c_int,
    pub escape: ::std::os::raw::c_int,
    pub ssl2_rollback: ::std::os::raw::c_int,
    pub wnum: ::std::os::raw::c_uint,
    pub wpend_tot: ::std::os::raw::c_int,
    pub wpend_buf: *const ::std::os::raw::c_uchar,
    pub wpend_off: ::std::os::raw::c_int,
    pub wpend_len: ::std::os::raw::c_int,
    pub wpend_ret: ::std::os::raw::c_int,
    pub rbuf_left: ::std::os::raw::c_int,
    pub rbuf_offs: ::std::os::raw::c_int,
    pub rbuf: *mut ::std::os::raw::c_uchar,
    pub wbuf: *mut ::std::os::raw::c_uchar,
    pub write_ptr: *mut ::std::os::raw::c_uchar,
    pub padding: ::std::os::raw::c_uint,
    pub rlength: ::std::os::raw::c_uint,
    pub ract_data_length: ::std::os::raw::c_int,
    pub wlength: ::std::os::raw::c_uint,
    pub wact_data_length: ::std::os::raw::c_int,
    pub ract_data: *mut ::std::os::raw::c_uchar,
    pub wact_data: *mut ::std::os::raw::c_uchar,
    pub mac_data: *mut ::std::os::raw::c_uchar,
    pub read_key: *mut ::std::os::raw::c_uchar,
    pub write_key: *mut ::std::os::raw::c_uchar,
    pub challenge_length: ::std::os::raw::c_uint,
    pub challenge: [::std::os::raw::c_uchar; 32usize],
    pub conn_id_length: ::std::os::raw::c_uint,
    pub conn_id: [::std::os::raw::c_uchar; 16usize],
    pub key_material_length: ::std::os::raw::c_uint,
    pub key_material: [::std::os::raw::c_uchar; 48usize],
    pub read_sequence: ::std::os::raw::c_ulong,
    pub write_sequence: ::std::os::raw::c_ulong,
    pub tmp: ssl2_state_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl2_state_st__bindgen_ty_1 {
    pub conn_id_length: ::std::os::raw::c_uint,
    pub cert_type: ::std::os::raw::c_uint,
    pub cert_length: ::std::os::raw::c_uint,
    pub csl: ::std::os::raw::c_uint,
    pub clear: ::std::os::raw::c_uint,
    pub enc: ::std::os::raw::c_uint,
    pub ccl: [::std::os::raw::c_uchar; 32usize],
    pub cipher_spec_length: ::std::os::raw::c_uint,
    pub session_id_length: ::std::os::raw::c_uint,
    pub clen: ::std::os::raw::c_uint,
    pub rlen: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ssl2_state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ssl2_state_st__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(ssl2_state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl2_state_st__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl2_state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).conn_id_length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(conn_id_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).cert_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).cert_length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(cert_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).csl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(csl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).clear as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).enc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).ccl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(ccl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).cipher_spec_length as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(cipher_spec_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).session_id_length as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(session_id_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).clen as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(clen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st__bindgen_ty_1>())).rlen as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st__bindgen_ty_1),
            "::",
            stringify!(rlen)
        )
    );
}
#[test]
fn bindgen_test_layout_ssl2_state_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl2_state_st>(),
        344usize,
        concat!("Size of: ", stringify!(ssl2_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl2_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl2_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).three_byte_header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(three_byte_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).clear_text as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(clear_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).escape as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(escape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).ssl2_rollback as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(ssl2_rollback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wnum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wpend_tot as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wpend_tot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wpend_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wpend_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wpend_off as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wpend_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wpend_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wpend_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wpend_ret as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wpend_ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).rbuf_left as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(rbuf_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).rbuf_offs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(rbuf_offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).rbuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wbuf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).write_ptr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).padding as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).rlength as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(rlength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).ract_data_length as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(ract_data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wlength as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wlength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wact_data_length as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wact_data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).ract_data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(ract_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).wact_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(wact_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).mac_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(mac_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).read_key as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(read_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).write_key as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(write_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).challenge_length as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(challenge_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).challenge as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).conn_id_length as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(conn_id_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).conn_id as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(conn_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl2_state_st>())).key_material_length as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(key_material_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).key_material as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(key_material)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).read_sequence as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(read_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).write_sequence as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(write_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl2_state_st>())).tmp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl2_state_st),
            "::",
            stringify!(tmp)
        )
    );
}
pub type SSL2_STATE = ssl2_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl3_record_st {
    pub type_: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_uint,
    pub off: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_uchar,
    pub input: *mut ::std::os::raw::c_uchar,
    pub comp: *mut ::std::os::raw::c_uchar,
    pub epoch: ::std::os::raw::c_ulong,
    pub seq_num: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_ssl3_record_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl3_record_st>(),
        56usize,
        concat!("Size of: ", stringify!(ssl3_record_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl3_record_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl3_record_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).input as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).comp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).epoch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_record_st>())).seq_num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_record_st),
            "::",
            stringify!(seq_num)
        )
    );
}
pub type SSL3_RECORD = ssl3_record_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl3_buffer_st {
    pub buf: *mut ::std::os::raw::c_uchar,
    pub len: usize,
    pub offset: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ssl3_buffer_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl3_buffer_st>(),
        24usize,
        concat!("Size of: ", stringify!(ssl3_buffer_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl3_buffer_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl3_buffer_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_buffer_st>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_buffer_st),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_buffer_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_buffer_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_buffer_st>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_buffer_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_buffer_st>())).left as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_buffer_st),
            "::",
            stringify!(left)
        )
    );
}
pub type SSL3_BUFFER = ssl3_buffer_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl3_state_st {
    pub flags: ::std::os::raw::c_long,
    pub delay_buf_pop_ret: ::std::os::raw::c_int,
    pub read_sequence: [::std::os::raw::c_uchar; 8usize],
    pub read_mac_secret_size: ::std::os::raw::c_int,
    pub read_mac_secret: [::std::os::raw::c_uchar; 64usize],
    pub write_sequence: [::std::os::raw::c_uchar; 8usize],
    pub write_mac_secret_size: ::std::os::raw::c_int,
    pub write_mac_secret: [::std::os::raw::c_uchar; 64usize],
    pub server_random: [::std::os::raw::c_uchar; 32usize],
    pub client_random: [::std::os::raw::c_uchar; 32usize],
    pub need_empty_fragments: ::std::os::raw::c_int,
    pub empty_fragment_done: ::std::os::raw::c_int,
    pub init_extra: ::std::os::raw::c_int,
    pub rbuf: SSL3_BUFFER,
    pub wbuf: SSL3_BUFFER,
    pub rrec: SSL3_RECORD,
    pub wrec: SSL3_RECORD,
    pub alert_fragment: [::std::os::raw::c_uchar; 2usize],
    pub alert_fragment_len: ::std::os::raw::c_uint,
    pub handshake_fragment: [::std::os::raw::c_uchar; 4usize],
    pub handshake_fragment_len: ::std::os::raw::c_uint,
    pub wnum: ::std::os::raw::c_uint,
    pub wpend_tot: ::std::os::raw::c_int,
    pub wpend_type: ::std::os::raw::c_int,
    pub wpend_ret: ::std::os::raw::c_int,
    pub wpend_buf: *const ::std::os::raw::c_uchar,
    pub handshake_buffer: *mut BIO,
    pub handshake_dgst: *mut *mut EVP_MD_CTX,
    pub change_cipher_spec: ::std::os::raw::c_int,
    pub warn_alert: ::std::os::raw::c_int,
    pub fatal_alert: ::std::os::raw::c_int,
    pub alert_dispatch: ::std::os::raw::c_int,
    pub send_alert: [::std::os::raw::c_uchar; 2usize],
    pub renegotiate: ::std::os::raw::c_int,
    pub total_renegotiations: ::std::os::raw::c_int,
    pub num_renegotiations: ::std::os::raw::c_int,
    pub in_read_app_data: ::std::os::raw::c_int,
    pub client_opaque_prf_input: *mut ::std::os::raw::c_void,
    pub client_opaque_prf_input_len: usize,
    pub server_opaque_prf_input: *mut ::std::os::raw::c_void,
    pub server_opaque_prf_input_len: usize,
    pub tmp: ssl3_state_st__bindgen_ty_1,
    pub previous_client_finished: [::std::os::raw::c_uchar; 64usize],
    pub previous_client_finished_len: ::std::os::raw::c_uchar,
    pub previous_server_finished: [::std::os::raw::c_uchar; 64usize],
    pub previous_server_finished_len: ::std::os::raw::c_uchar,
    pub send_connection_binding: ::std::os::raw::c_int,
    pub next_proto_neg_seen: ::std::os::raw::c_int,
    pub is_probably_safari: ::std::os::raw::c_char,
    pub alpn_selected: *mut ::std::os::raw::c_uchar,
    pub alpn_selected_len: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl3_state_st__bindgen_ty_1 {
    pub cert_verify_md: [::std::os::raw::c_uchar; 128usize],
    pub finish_md: [::std::os::raw::c_uchar; 128usize],
    pub finish_md_len: ::std::os::raw::c_int,
    pub peer_finish_md: [::std::os::raw::c_uchar; 128usize],
    pub peer_finish_md_len: ::std::os::raw::c_int,
    pub message_size: ::std::os::raw::c_ulong,
    pub message_type: ::std::os::raw::c_int,
    pub new_cipher: *const SSL_CIPHER,
    pub dh: *mut DH,
    pub ecdh: *mut EC_KEY,
    pub next_state: ::std::os::raw::c_int,
    pub reuse_message: ::std::os::raw::c_int,
    pub cert_req: ::std::os::raw::c_int,
    pub ctype_num: ::std::os::raw::c_int,
    pub ctype: [::std::os::raw::c_char; 9usize],
    pub ca_names: *mut stack_st_X509_NAME,
    pub use_rsa_tmp: ::std::os::raw::c_int,
    pub key_block_length: ::std::os::raw::c_int,
    pub key_block: *mut ::std::os::raw::c_uchar,
    pub new_sym_enc: *const EVP_CIPHER,
    pub new_hash: *const EVP_MD,
    pub new_mac_pkey_type: ::std::os::raw::c_int,
    pub new_mac_secret_size: ::std::os::raw::c_int,
    pub new_compression: *const SSL_COMP,
    pub cert_request: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ssl3_state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ssl3_state_st__bindgen_ty_1>(),
        528usize,
        concat!("Size of: ", stringify!(ssl3_state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl3_state_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl3_state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).cert_verify_md as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(cert_verify_md)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).finish_md as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(finish_md)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).finish_md_len as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(finish_md_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).peer_finish_md as *const _
                as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(peer_finish_md)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).peer_finish_md_len as *const _
                as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(peer_finish_md_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).message_size as *const _
                as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(message_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).message_type as *const _
                as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_cipher as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).dh as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).ecdh as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(ecdh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).next_state as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(next_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).reuse_message as *const _
                as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(reuse_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).cert_req as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(cert_req)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).ctype_num as *const _ as usize
        },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(ctype_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).ctype as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).ca_names as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(ca_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).use_rsa_tmp as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(use_rsa_tmp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).key_block_length as *const _
                as usize
        },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(key_block_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).key_block as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_sym_enc as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_sym_enc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_hash as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_mac_pkey_type as *const _
                as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_mac_pkey_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_mac_secret_size as *const _
                as usize
        },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_mac_secret_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).new_compression as *const _
                as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(new_compression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st__bindgen_ty_1>())).cert_request as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st__bindgen_ty_1),
            "::",
            stringify!(cert_request)
        )
    );
}
#[test]
fn bindgen_test_layout_ssl3_state_st() {
    assert_eq!(
        ::std::mem::size_of::<ssl3_state_st>(),
        1216usize,
        concat!("Size of: ", stringify!(ssl3_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl3_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl3_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).delay_buf_pop_ret as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(delay_buf_pop_ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).read_sequence as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(read_sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).read_mac_secret_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(read_mac_secret_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).read_mac_secret as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(read_mac_secret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).write_sequence as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(write_sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).write_mac_secret_size as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(write_mac_secret_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).write_mac_secret as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(write_mac_secret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).server_random as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(server_random)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).client_random as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(client_random)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).need_empty_fragments as *const _ as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(need_empty_fragments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).empty_fragment_done as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(empty_fragment_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).init_extra as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(init_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).rbuf as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wbuf as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).rrec as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(rrec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wrec as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wrec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).alert_fragment as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(alert_fragment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).alert_fragment_len as *const _ as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(alert_fragment_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).handshake_fragment as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(handshake_fragment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).handshake_fragment_len as *const _ as usize
        },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(handshake_fragment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wnum as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wpend_tot as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wpend_tot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wpend_type as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wpend_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wpend_ret as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wpend_ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).wpend_buf as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(wpend_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).handshake_buffer as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(handshake_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).handshake_dgst as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(handshake_dgst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).change_cipher_spec as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(change_cipher_spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).warn_alert as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(warn_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).fatal_alert as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(fatal_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).alert_dispatch as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(alert_dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).send_alert as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(send_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).renegotiate as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(renegotiate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).total_renegotiations as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(total_renegotiations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).num_renegotiations as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(num_renegotiations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).in_read_app_data as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(in_read_app_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).client_opaque_prf_input as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(client_opaque_prf_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).client_opaque_prf_input_len as *const _
                as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(client_opaque_prf_input_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).server_opaque_prf_input as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(server_opaque_prf_input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).server_opaque_prf_input_len as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(server_opaque_prf_input_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).tmp as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(tmp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).previous_client_finished as *const _ as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(previous_client_finished)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).previous_client_finished_len as *const _
                as usize
        },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(previous_client_finished_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).previous_server_finished as *const _ as usize
        },
        1121usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(previous_server_finished)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).previous_server_finished_len as *const _
                as usize
        },
        1185usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(previous_server_finished_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).send_connection_binding as *const _ as usize
        },
        1188usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(send_connection_binding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).next_proto_neg_seen as *const _ as usize
        },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(next_proto_neg_seen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ssl3_state_st>())).is_probably_safari as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(is_probably_safari)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).alpn_selected as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(alpn_selected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ssl3_state_st>())).alpn_selected_len as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl3_state_st),
            "::",
            stringify!(alpn_selected_len)
        )
    );
}
pub type SSL3_STATE = ssl3_state_st;
extern "C" {
    pub fn SSL_get_servername(
        s: *const SSL,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_servername_type(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material(
        s: *mut SSL,
        out: *mut ::std::os::raw::c_uchar,
        olen: usize,
        label: *const ::std::os::raw::c_char,
        llen: usize,
        context: *const ::std::os::raw::c_uchar,
        contextlen: usize,
        use_context: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_sigalgs(
        s: *mut SSL,
        idx: ::std::os::raw::c_int,
        psign: *mut ::std::os::raw::c_int,
        phash: *mut ::std::os::raw::c_int,
        psignandhash: *mut ::std::os::raw::c_int,
        rsig: *mut ::std::os::raw::c_uchar,
        rhash: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_shared_sigalgs(
        s: *mut SSL,
        idx: ::std::os::raw::c_int,
        psign: *mut ::std::os::raw::c_int,
        phash: *mut ::std::os::raw::c_int,
        psignandhash: *mut ::std::os::raw::c_int,
        rsig: *mut ::std::os::raw::c_uchar,
        rhash: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_check_chain(
        s: *mut SSL,
        x: *mut X509,
        pk: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_session_ticket_ext_st {
    pub length: ::std::os::raw::c_ushort,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tls_session_ticket_ext_st() {
    assert_eq!(
        ::std::mem::size_of::<tls_session_ticket_ext_st>(),
        16usize,
        concat!("Size of: ", stringify!(tls_session_ticket_ext_st))
    );
    assert_eq!(
        ::std::mem::align_of::<tls_session_ticket_ext_st>(),
        8usize,
        concat!("Alignment of ", stringify!(tls_session_ticket_ext_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tls_session_ticket_ext_st>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_session_ticket_ext_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tls_session_ticket_ext_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_session_ticket_ext_st),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pqueue {
    _unused: [u8; 0],
}
pub type pqueue = *mut _pqueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pitem {
    pub priority: [::std::os::raw::c_uchar; 8usize],
    pub data: *mut ::std::os::raw::c_void,
    pub next: *mut _pitem,
}
#[test]
fn bindgen_test_layout__pitem() {
    assert_eq!(
        ::std::mem::size_of::<_pitem>(),
        24usize,
        concat!("Size of: ", stringify!(_pitem))
    );
    assert_eq!(
        ::std::mem::align_of::<_pitem>(),
        8usize,
        concat!("Alignment of ", stringify!(_pitem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pitem>())).priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pitem),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pitem>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pitem),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pitem>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pitem),
            "::",
            stringify!(next)
        )
    );
}
pub type pitem = _pitem;
pub type piterator = *mut _pitem;
extern "C" {
    pub fn pitem_new(
        prio64be: *mut ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pitem;
}
extern "C" {
    pub fn pitem_free(item: *mut pitem);
}
extern "C" {
    pub fn pqueue_new() -> pqueue;
}
extern "C" {
    pub fn pqueue_free(pq: pqueue);
}
extern "C" {
    pub fn pqueue_insert(pq: pqueue, item: *mut pitem) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_peek(pq: pqueue) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_pop(pq: pqueue) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_find(pq: pqueue, prio64be: *mut ::std::os::raw::c_uchar) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_iterator(pq: pqueue) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_next(iter: *mut piterator) -> *mut pitem;
}
extern "C" {
    pub fn pqueue_print(pq: pqueue);
}
extern "C" {
    pub fn pqueue_size(pq: pqueue) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtls1_bitmap_st {
    pub map: ::std::os::raw::c_ulong,
    pub max_seq_num: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_dtls1_bitmap_st() {
    assert_eq!(
        ::std::mem::size_of::<dtls1_bitmap_st>(),
        16usize,
        concat!("Size of: ", stringify!(dtls1_bitmap_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls1_bitmap_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dtls1_bitmap_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_bitmap_st>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_bitmap_st),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_bitmap_st>())).max_seq_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_bitmap_st),
            "::",
            stringify!(max_seq_num)
        )
    );
}
pub type DTLS1_BITMAP = dtls1_bitmap_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtls1_retransmit_state {
    pub enc_write_ctx: *mut EVP_CIPHER_CTX,
    pub write_hash: *mut EVP_MD_CTX,
    pub compress: *mut COMP_CTX,
    pub session: *mut SSL_SESSION,
    pub epoch: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_dtls1_retransmit_state() {
    assert_eq!(
        ::std::mem::size_of::<dtls1_retransmit_state>(),
        40usize,
        concat!("Size of: ", stringify!(dtls1_retransmit_state))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls1_retransmit_state>(),
        8usize,
        concat!("Alignment of ", stringify!(dtls1_retransmit_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_retransmit_state>())).enc_write_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_retransmit_state),
            "::",
            stringify!(enc_write_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_retransmit_state>())).write_hash as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_retransmit_state),
            "::",
            stringify!(write_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_retransmit_state>())).compress as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_retransmit_state),
            "::",
            stringify!(compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_retransmit_state>())).session as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_retransmit_state),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_retransmit_state>())).epoch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_retransmit_state),
            "::",
            stringify!(epoch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hm_header_st {
    pub type_: ::std::os::raw::c_uchar,
    pub msg_len: ::std::os::raw::c_ulong,
    pub seq: ::std::os::raw::c_ushort,
    pub frag_off: ::std::os::raw::c_ulong,
    pub frag_len: ::std::os::raw::c_ulong,
    pub is_ccs: ::std::os::raw::c_uint,
    pub saved_retransmit_state: dtls1_retransmit_state,
}
#[test]
fn bindgen_test_layout_hm_header_st() {
    assert_eq!(
        ::std::mem::size_of::<hm_header_st>(),
        88usize,
        concat!("Size of: ", stringify!(hm_header_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hm_header_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hm_header_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).msg_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(msg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).frag_off as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).frag_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(frag_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_header_st>())).is_ccs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(is_ccs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hm_header_st>())).saved_retransmit_state as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_header_st),
            "::",
            stringify!(saved_retransmit_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccs_header_st {
    pub type_: ::std::os::raw::c_uchar,
    pub seq: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ccs_header_st() {
    assert_eq!(
        ::std::mem::size_of::<ccs_header_st>(),
        4usize,
        concat!("Size of: ", stringify!(ccs_header_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ccs_header_st>(),
        2usize,
        concat!("Alignment of ", stringify!(ccs_header_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccs_header_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccs_header_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccs_header_st>())).seq as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ccs_header_st),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtls1_timeout_st {
    pub read_timeouts: ::std::os::raw::c_uint,
    pub write_timeouts: ::std::os::raw::c_uint,
    pub num_alerts: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_dtls1_timeout_st() {
    assert_eq!(
        ::std::mem::size_of::<dtls1_timeout_st>(),
        12usize,
        concat!("Size of: ", stringify!(dtls1_timeout_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls1_timeout_st>(),
        4usize,
        concat!("Alignment of ", stringify!(dtls1_timeout_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_timeout_st>())).read_timeouts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_timeout_st),
            "::",
            stringify!(read_timeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_timeout_st>())).write_timeouts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_timeout_st),
            "::",
            stringify!(write_timeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_timeout_st>())).num_alerts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_timeout_st),
            "::",
            stringify!(num_alerts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct record_pqueue_st {
    pub epoch: ::std::os::raw::c_ushort,
    pub q: pqueue,
}
#[test]
fn bindgen_test_layout_record_pqueue_st() {
    assert_eq!(
        ::std::mem::size_of::<record_pqueue_st>(),
        16usize,
        concat!("Size of: ", stringify!(record_pqueue_st))
    );
    assert_eq!(
        ::std::mem::align_of::<record_pqueue_st>(),
        8usize,
        concat!("Alignment of ", stringify!(record_pqueue_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<record_pqueue_st>())).epoch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(record_pqueue_st),
            "::",
            stringify!(epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<record_pqueue_st>())).q as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(record_pqueue_st),
            "::",
            stringify!(q)
        )
    );
}
pub type record_pqueue = record_pqueue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hm_fragment_st {
    pub msg_header: hm_header_st,
    pub fragment: *mut ::std::os::raw::c_uchar,
    pub reassembly: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hm_fragment_st() {
    assert_eq!(
        ::std::mem::size_of::<hm_fragment_st>(),
        104usize,
        concat!("Size of: ", stringify!(hm_fragment_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hm_fragment_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hm_fragment_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_fragment_st>())).msg_header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_fragment_st),
            "::",
            stringify!(msg_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_fragment_st>())).fragment as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_fragment_st),
            "::",
            stringify!(fragment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hm_fragment_st>())).reassembly as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hm_fragment_st),
            "::",
            stringify!(reassembly)
        )
    );
}
pub type hm_fragment = hm_fragment_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dtls1_state_st {
    pub send_cookie: ::std::os::raw::c_uint,
    pub cookie: [::std::os::raw::c_uchar; 256usize],
    pub rcvd_cookie: [::std::os::raw::c_uchar; 256usize],
    pub cookie_len: ::std::os::raw::c_uint,
    pub r_epoch: ::std::os::raw::c_ushort,
    pub w_epoch: ::std::os::raw::c_ushort,
    pub bitmap: DTLS1_BITMAP,
    pub next_bitmap: DTLS1_BITMAP,
    pub handshake_write_seq: ::std::os::raw::c_ushort,
    pub next_handshake_write_seq: ::std::os::raw::c_ushort,
    pub handshake_read_seq: ::std::os::raw::c_ushort,
    pub last_write_sequence: [::std::os::raw::c_uchar; 8usize],
    pub unprocessed_rcds: record_pqueue,
    pub processed_rcds: record_pqueue,
    pub buffered_messages: pqueue,
    pub sent_messages: pqueue,
    pub buffered_app_data: record_pqueue,
    pub listen: ::std::os::raw::c_uint,
    pub link_mtu: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub w_msg_hdr: hm_header_st,
    pub r_msg_hdr: hm_header_st,
    pub timeout: dtls1_timeout_st,
    pub next_timeout: timeval,
    pub timeout_duration: ::std::os::raw::c_ushort,
    pub alert_fragment: [::std::os::raw::c_uchar; 2usize],
    pub alert_fragment_len: ::std::os::raw::c_uint,
    pub handshake_fragment: [::std::os::raw::c_uchar; 12usize],
    pub handshake_fragment_len: ::std::os::raw::c_uint,
    pub retransmitting: ::std::os::raw::c_uint,
    pub change_cipher_spec_ok: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_dtls1_state_st() {
    assert_eq!(
        ::std::mem::size_of::<dtls1_state_st>(),
        896usize,
        concat!("Size of: ", stringify!(dtls1_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls1_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dtls1_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).send_cookie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(send_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).cookie as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).rcvd_cookie as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(rcvd_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).cookie_len as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(cookie_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).r_epoch as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(r_epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).w_epoch as *const _ as usize },
        522usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(w_epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).bitmap as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).next_bitmap as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(next_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).handshake_write_seq as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(handshake_write_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).next_handshake_write_seq as *const _ as usize
        },
        562usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(next_handshake_write_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).handshake_read_seq as *const _ as usize
        },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(handshake_read_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).last_write_sequence as *const _ as usize
        },
        566usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(last_write_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).unprocessed_rcds as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(unprocessed_rcds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).processed_rcds as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(processed_rcds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).buffered_messages as *const _ as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(buffered_messages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).sent_messages as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(sent_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).buffered_app_data as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(buffered_app_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).listen as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(listen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).link_mtu as *const _ as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(link_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).mtu as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).w_msg_hdr as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(w_msg_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).r_msg_hdr as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(r_msg_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).timeout as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).next_timeout as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(next_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).timeout_duration as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(timeout_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).alert_fragment as *const _ as usize },
        866usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(alert_fragment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).alert_fragment_len as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(alert_fragment_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).handshake_fragment as *const _ as usize
        },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(handshake_fragment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).handshake_fragment_len as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(handshake_fragment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_state_st>())).retransmitting as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(retransmitting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_state_st>())).change_cipher_spec_ok as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_state_st),
            "::",
            stringify!(change_cipher_spec_ok)
        )
    );
}
pub type DTLS1_STATE = dtls1_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtls1_record_data_st {
    pub packet: *mut ::std::os::raw::c_uchar,
    pub packet_length: ::std::os::raw::c_uint,
    pub rbuf: SSL3_BUFFER,
    pub rrec: SSL3_RECORD,
}
#[test]
fn bindgen_test_layout_dtls1_record_data_st() {
    assert_eq!(
        ::std::mem::size_of::<dtls1_record_data_st>(),
        96usize,
        concat!("Size of: ", stringify!(dtls1_record_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls1_record_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(dtls1_record_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_record_data_st>())).packet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_record_data_st),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dtls1_record_data_st>())).packet_length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_record_data_st),
            "::",
            stringify!(packet_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_record_data_st>())).rbuf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_record_data_st),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dtls1_record_data_st>())).rrec as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls1_record_data_st),
            "::",
            stringify!(rrec)
        )
    );
}
pub type DTLS1_RECORD_DATA = dtls1_record_data_st;
extern "C" {
    pub fn SSL_CTX_set_tlsext_use_srtp(
        ctx: *mut SSL_CTX,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_use_srtp(
        ctx: *mut SSL,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_srtp_profiles(ssl: *mut SSL) -> *mut stack_st_SRTP_PROTECTION_PROFILE;
}
extern "C" {
    pub fn SSL_get_selected_srtp_profile(s: *mut SSL) -> *mut SRTP_PROTECTION_PROFILE;
}
extern "C" {
    pub fn SSL_get_finished(s: *const SSL, buf: *mut ::std::os::raw::c_void, count: usize)
        -> usize;
}
extern "C" {
    pub fn SSL_get_peer_finished(
        s: *const SSL,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> usize;
}
extern "C" {
    pub fn PEM_read_bio_SSL_SESSION(
        bp: *mut BIO,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_read_SSL_SESSION(
        fp: *mut FILE,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_write_bio_SSL_SESSION(bp: *mut BIO, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_SSL_SESSION(fp: *mut FILE, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_ssl() -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_ssl(ctx: *mut SSL_CTX, client: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_buffer_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_ssl_copy_session_id(to: *mut BIO, from: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ssl_shutdown(ssl_bio: *mut BIO);
}
extern "C" {
    pub fn SSL_CTX_set_cipher_list(
        arg1: *mut SSL_CTX,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_new(meth: *const SSL_METHOD) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_free(arg1: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CTX_set_timeout(
        ctx: *mut SSL_CTX,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_timeout(ctx: *const SSL_CTX) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_cert_store(arg1: *const SSL_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn SSL_CTX_set_cert_store(arg1: *mut SSL_CTX, arg2: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_want(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_clear(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_flush_sessions(ctx: *mut SSL_CTX, tm: ::std::os::raw::c_long);
}
extern "C" {
    pub fn SSL_get_current_cipher(s: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_bits(
        c: *const SSL_CIPHER,
        alg_bits: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_version(c: *const SSL_CIPHER) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_name(c: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_id(c: *const SSL_CIPHER) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_get_fd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_rfd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_wfd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_cipher_list(
        s: *const SSL,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_shared_ciphers(
        s: *const SSL,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_read_ahead(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_pending(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_fd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_rfd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_wfd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_bio(s: *mut SSL, rbio: *mut BIO, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_get_rbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_get_wbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_set_cipher_list(
        s: *mut SSL,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_read_ahead(s: *mut SSL, yes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_verify_mode(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_depth(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_callback(
        s: *const SSL,
    ) -> ::std::option::Option<unsafe extern "C" fn(s: *const SSL) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn SSL_set_verify(
        s: *mut SSL,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ok: ::std::os::raw::c_int,
                ctx: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_set_verify_depth(s: *mut SSL, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_cert_cb(
        s: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey(ssl: *mut SSL, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_ASN1(
        ssl: *mut SSL,
        d: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey(ssl: *mut SSL, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_ASN1(
        pk: ::std::os::raw::c_int,
        ssl: *mut SSL,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate(ssl: *mut SSL, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_ASN1(
        ssl: *mut SSL,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo(
        ctx: *mut SSL_CTX,
        serverinfo: *const ::std::os::raw::c_uchar,
        serverinfo_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_load_client_CA_file(file: *const ::std::os::raw::c_char) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_file_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add_dir_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_load_error_strings();
}
extern "C" {
    pub fn SSL_state_string(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_rstate_string(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_state_string_long(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_rstate_string_long(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_SESSION_get_time(s: *const SSL_SESSION) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_time(
        s: *mut SSL_SESSION,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_get_timeout(s: *const SSL_SESSION) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_timeout(
        s: *mut SSL_SESSION,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_copy_session_id(to: *mut SSL, from: *const SSL);
}
extern "C" {
    pub fn SSL_SESSION_get0_peer(s: *mut SSL_SESSION) -> *mut X509;
}
extern "C" {
    pub fn SSL_SESSION_set1_id_context(
        s: *mut SSL_SESSION,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_new() -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_get_id(
        s: *const SSL_SESSION,
        len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SSL_SESSION_get_compress_id(s: *const SSL_SESSION) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_SESSION_print_fp(fp: *mut FILE, ses: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print(fp: *mut BIO, ses: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_free(ses: *mut SSL_SESSION);
}
extern "C" {
    pub fn i2d_SSL_SESSION(
        in_: *mut SSL_SESSION,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session(to: *mut SSL, session: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_session(s: *mut SSL_CTX, c: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_remove_session(arg1: *mut SSL_CTX, c: *mut SSL_SESSION)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_generate_session_id(
        arg1: *mut SSL_CTX,
        arg2: GEN_SESSION_CB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_generate_session_id(
        arg1: *mut SSL,
        arg2: GEN_SESSION_CB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_has_matching_session_id(
        ssl: *const SSL,
        id: *const ::std::os::raw::c_uchar,
        id_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_SSL_SESSION(
        a: *mut *mut SSL_SESSION,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get_peer_certificate(s: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_peer_cert_chain(s: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_CTX_get_verify_mode(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_depth(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_callback(
        ctx: *const SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *const SSL_CTX) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn SSL_CTX_set_verify(
        ctx: *mut SSL_CTX,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_verify_depth(ctx: *mut SSL_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_cert_verify_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut X509_STORE_CTX,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cert_cb(
        c: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey(ctx: *mut SSL_CTX, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_ASN1(
        ctx: *mut SSL_CTX,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey(ctx: *mut SSL_CTX, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_ASN1(
        pk: ::std::os::raw::c_int,
        ctx: *mut SSL_CTX,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate(ctx: *mut SSL_CTX, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_ASN1(
        ctx: *mut SSL_CTX,
        len: ::std::os::raw::c_int,
        d: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb(ctx: *mut SSL_CTX, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb_userdata(
        ctx: *mut SSL_CTX,
        u: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_check_private_key(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_check_private_key(ctx: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_session_id_context(
        ctx: *mut SSL_CTX,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_new(ctx: *mut SSL_CTX) -> *mut SSL;
}
extern "C" {
    pub fn SSL_set_session_id_context(
        ssl: *mut SSL,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_purpose(
        s: *mut SSL_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_purpose(s: *mut SSL, purpose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_trust(
        s: *mut SSL_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_trust(s: *mut SSL, trust: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_param(
        ctx: *mut SSL_CTX,
        vpm: *mut X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_param(ssl: *mut SSL, vpm: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_param(ctx: *mut SSL_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_get0_param(ssl: *mut SSL) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username(
        ctx: *mut SSL_CTX,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_password(
        ctx: *mut SSL_CTX,
        password: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_strength(
        ctx: *mut SSL_CTX,
        strength: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_client_pwd_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_char,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_verify_param_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_cb_arg(
        ctx: *mut SSL_CTX,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param(
        s: *mut SSL,
        N: *const BIGNUM,
        g: *const BIGNUM,
        sa: *mut BIGNUM,
        v: *mut BIGNUM,
        info: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param_pw(
        s: *mut SSL,
        user: *const ::std::os::raw::c_char,
        pass: *const ::std::os::raw::c_char,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_srp_g(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_N(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_username(s: *mut SSL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_srp_userinfo(s: *mut SSL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_certs_clear(s: *mut SSL);
}
extern "C" {
    pub fn SSL_free(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_accept(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_connect(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_peek(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write(
        ssl: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ctrl(
        ssl: *mut SSL,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_callback_ctrl(
        arg1: *mut SSL,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_ctrl(
        ctx: *mut SSL_CTX,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_callback_ctrl(
        arg1: *mut SSL_CTX,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_get_error(s: *const SSL, ret_code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_version(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CTX_set_ssl_version(
        ctx: *mut SSL_CTX,
        meth: *const SSL_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSLv2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv3_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv3_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv3_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv23_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv23_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv23_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_get_ciphers(s: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_do_handshake(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_abbreviated(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_pending(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_shutdown(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ssl_method(ctx: *mut SSL_CTX) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_get_ssl_method(s: *mut SSL) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_set_ssl_method(s: *mut SSL, method: *const SSL_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_alert_type_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_type_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set_client_CA_list(s: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set_client_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_get_client_CA_list(s: *const SSL) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_CTX_get_client_CA_list(s: *const SSL_CTX) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_client_CA(ssl: *mut SSL, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_CA(ctx: *mut SSL_CTX, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_connect_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_set_accept_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_get_default_timeout(s: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_library_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_description(
        arg1: *const SSL_CIPHER,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_dup_CA_list(sk: *mut stack_st_X509_NAME) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_dup(ssl: *mut SSL) -> *mut SSL;
}
extern "C" {
    pub fn SSL_get_certificate(ssl: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_privatekey(ssl: *const SSL) -> *mut evp_pkey_st;
}
extern "C" {
    pub fn SSL_CTX_get0_certificate(ctx: *const SSL_CTX) -> *mut X509;
}
extern "C" {
    pub fn SSL_CTX_get0_privatekey(ctx: *const SSL_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn SSL_CTX_set_quiet_shutdown(ctx: *mut SSL_CTX, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_quiet_shutdown(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_quiet_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_quiet_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_version(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_paths(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_locations(
        ctx: *mut SSL_CTX,
        CAfile: *const ::std::os::raw::c_char,
        CApath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_session(ssl: *const SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get1_session(ssl: *mut SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get_SSL_CTX(ssl: *const SSL) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_SSL_CTX(ssl: *mut SSL, ctx: *mut SSL_CTX) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_info_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                val: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_get_info_callback(
        ssl: *const SSL,
    ) -> ::std::option::Option<unsafe extern "C" fn(ssl: *const SSL)>;
}
extern "C" {
    pub fn SSL_state(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_state(ssl: *mut SSL, state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_verify_result(ssl: *mut SSL, v: ::std::os::raw::c_long);
}
extern "C" {
    pub fn SSL_get_verify_result(ssl: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_set_ex_data(
        ssl: *mut SSL,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data(
        ssl: *const SSL,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set_ex_data(
        ss: *mut SSL_SESSION,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_data(
        ss: *const SSL_SESSION,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ex_data(
        ssl: *mut SSL_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ex_data(
        ssl: *const SSL_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data_X509_STORE_CTX_idx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tmp_rsa_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut RSA,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_rsa_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut RSA,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_tmp_dh_callback(
        ctx: *mut SSL_CTX,
        dh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_dh_callback(
        ssl: *mut SSL,
        dh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_tmp_ecdh_callback(
        ctx: *mut SSL_CTX,
        ecdh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut EC_KEY,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_ecdh_callback(
        ssl: *mut SSL,
        ecdh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut EC_KEY,
        >,
    );
}
extern "C" {
    pub fn SSL_get_current_compression(s: *mut SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_get_current_expansion(s: *mut SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_COMP_get_name(comp: *const COMP_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_COMP_get_compression_methods() -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_set0_compression_methods(
        meths: *mut stack_st_SSL_COMP,
    ) -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_free_compression_methods();
}
extern "C" {
    pub fn SSL_COMP_add_compression_method(
        id: ::std::os::raw::c_int,
        cm: *mut COMP_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_find(ssl: *mut SSL, ptr: *const ::std::os::raw::c_uchar)
        -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext(
        s: *mut SSL,
        ext_data: *mut ::std::os::raw::c_void,
        ext_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext_cb(
        s: *mut SSL,
        cb: tls_session_ticket_ext_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_secret_cb(
        s: *mut SSL,
        tls_session_secret_cb: tls_session_secret_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_debug(s: *mut SSL, debug: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_cache_hit(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_is_server(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_new() -> *mut SSL_CONF_CTX;
}
extern "C" {
    pub fn SSL_CONF_CTX_finish(cctx: *mut SSL_CONF_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_free(cctx: *mut SSL_CONF_CTX);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_flags(
        cctx: *mut SSL_CONF_CTX,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_clear_flags(
        cctx: *mut SSL_CONF_CTX,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_set1_prefix(
        cctx: *mut SSL_CONF_CTX,
        pre: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl(cctx: *mut SSL_CONF_CTX, ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl_ctx(cctx: *mut SSL_CONF_CTX, ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CONF_cmd(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_argv(
        cctx: *mut SSL_CONF_CTX,
        pargc: *mut ::std::os::raw::c_int,
        pargv: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_value_type(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_SSL_strings();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock_value {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_DIST_POINT {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_NAME {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_NAMES {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl3_enc_method {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess_cert_st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cert_st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl3_buf_freelist_st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_RESPID {
    pub _address: u8,
}
